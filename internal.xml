<?xml version="1.0" encoding="UTF-8"?>
<documents>
<document index="1">
<source>core/cleaner/handlers/base_handler.go</source>
<document_content>package handlers

import (
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
)

// LanguageHandler defines the interface for language-specific processing
type LanguageHandler interface {
	GetCommentTypes() []string
	GetImportTypes() []string
	GetDocCommentPrefix() string
	IsLoggingCall(node *sitter.Node, content []byte) bool
	IsGetterSetter(node *sitter.Node, content []byte) bool
}

// BaseHandler provides common functionality for all language handlers
type BaseHandler struct{}

// IsMethodNamed checks if a node represents a method/function with the given prefix
func (h *BaseHandler) IsMethodNamed(node *sitter.Node, content []byte, prefix string) bool {
	if node.Type() != "method_declaration" &&
		node.Type() != "function_declaration" &&
		node.Type() != "getter_declaration" &&
		node.Type() != "method_definition" {
		return false
	}

	nameNode := node.ChildByFieldName("name")
	if nameNode == nil {
		return false
	}

	name := string(content[nameNode.StartByte():nameNode.EndByte()])
	return strings.HasPrefix(strings.ToLower(name), strings.ToLower(prefix))
}

func stringSliceEqual(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}
</document_content>
</document>
<document index="2">
<source>core/cleaner/handlers/base_handler_test.go</source>
<document_content>package handlers

import (
	"testing"

	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/golang"
)

func TestBaseHandler(t *testing.T) {
	handler := &BaseHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(golang.GetLanguage())

	tests := []struct {
		name     string
		input    string
		prefix   string
		expected bool
	}{
		{
			name:     "get method",
			input:    "package main\nfunc GetName() string { return name }",
			prefix:   "Get",
			expected: true,
		},
		{
			name:     "set method",
			input:    "package main\nfunc SetName(name string) { this.name = name }",
			prefix:   "Set",
			expected: true,
		},
		{
			name:     "non-matching method",
			input:    "package main\nfunc Process() error { return nil }",
			prefix:   "Get",
			expected: false,
		},
		{
			name:     "case insensitive match",
			input:    "package main\nfunc getName() string { return name }",
			prefix:   "Get",
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			// Find the function declaration node
			var funcNode *sitter.Node
			cursor := sitter.NewTreeCursor(tree.RootNode())
			defer cursor.Close()

			ok := cursor.GoToFirstChild()
			for ok {
				if cursor.CurrentNode().Type() == "function_declaration" {
					funcNode = cursor.CurrentNode()
					break
				}
				ok = cursor.GoToNextSibling()
			}

			if funcNode == nil {
				t.Fatal("No function declaration found")
			}

			if got := handler.IsMethodNamed(funcNode, []byte(tt.input), tt.prefix); got != tt.expected {
				t.Errorf("IsMethodNamed() = %v, want %v", got, tt.expected)
			}
		})
	}
}
</document_content>
</document>
<document index="3">
<source>core/cleaner/cleaner.go</source>
<document_content>package cleaner

import (
	"bytes"
	"fmt"
	"io"
	"strings"

	"github.com/drgsn/filefusion/internal/core/cleaner/handlers"
	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/bash"
	"github.com/smacker/go-tree-sitter/cpp"
	"github.com/smacker/go-tree-sitter/csharp"
	"github.com/smacker/go-tree-sitter/css"
	"github.com/smacker/go-tree-sitter/golang"
	"github.com/smacker/go-tree-sitter/html"
	"github.com/smacker/go-tree-sitter/java"
	"github.com/smacker/go-tree-sitter/javascript"
	"github.com/smacker/go-tree-sitter/kotlin"
	"github.com/smacker/go-tree-sitter/php"
	"github.com/smacker/go-tree-sitter/python"
	"github.com/smacker/go-tree-sitter/ruby"
	"github.com/smacker/go-tree-sitter/sql"
	"github.com/smacker/go-tree-sitter/swift"
	"github.com/smacker/go-tree-sitter/typescript/typescript"
)

// Cleaner represents a code cleaner instance that processes source code
// according to the configured options
type Cleaner struct {
	options  *CleanerOptions
	language Language
	handler  handlers.LanguageHandler
}

// NewCleaner creates a new Cleaner instance with the given options and language
func NewCleaner(lang Language, options *CleanerOptions) (*Cleaner, error) {
	if options == nil {
		return nil, fmt.Errorf("cleaner options cannot be nil")
	}

	_, handler, err := getLanguageAndHandler(lang)
	if err != nil {
		return nil, err
	}

	return &Cleaner{
		options:  options,
		language: lang,
		handler:  handler,
	}, nil
}

// getLanguageAndHandler returns the appropriate tree-sitter language parser
// and language handler for the given language
func getLanguageAndHandler(lang Language) (*sitter.Language, handlers.LanguageHandler, error) {
	switch lang {
	case LangGo:
		return golang.GetLanguage(), &handlers.GoHandler{}, nil
	case LangJava:
		return java.GetLanguage(), &handlers.JavaHandler{}, nil
	case LangPython:
		return python.GetLanguage(), &handlers.PythonHandler{}, nil
	case LangSwift:
		return swift.GetLanguage(), &handlers.SwiftHandler{}, nil
	case LangKotlin:
		return kotlin.GetLanguage(), &handlers.KotlinHandler{}, nil
	case LangSQL:
		return sql.GetLanguage(), &handlers.SQLHandler{}, nil
	case LangHTML:
		return html.GetLanguage(), &handlers.HTMLHandler{}, nil
	case LangJavaScript:
		return javascript.GetLanguage(), &handlers.JavaScriptHandler{}, nil
	case LangTypeScript:
		return typescript.GetLanguage(), &handlers.TypeScriptHandler{}, nil
	case LangCSS:
		return css.GetLanguage(), &handlers.CSSHandler{}, nil
	case LangCPP:
		return cpp.GetLanguage(), &handlers.CPPHandler{}, nil
	case LangCSharp:
		return csharp.GetLanguage(), &handlers.CSharpHandler{}, nil
	case LangPHP:
		return php.GetLanguage(), &handlers.PHPHandler{}, nil
	case LangRuby:
		return ruby.GetLanguage(), &handlers.RubyHandler{}, nil
	case LangBash:
		return bash.GetLanguage(), &handlers.BashHandler{}, nil
	default:
		return nil, nil, fmt.Errorf("unsupported language: %s", lang)
	}
}

// Clean processes the input code and returns the cleaned version
func (c *Cleaner) Clean(input []byte) ([]byte, error) {
	if len(input) == 0 {
		return nil, fmt.Errorf("empty input")
	}

	// Create a new parser for each Clean call to avoid concurrency issues
	parser := sitter.NewParser()
	language, _, err := getLanguageAndHandler(c.language)
	if err != nil {
		return nil, fmt.Errorf("failed to get language handler: %w", err)
	}
	parser.SetLanguage(language)

	tree := parser.Parse(nil, input)
	if tree == nil {
		return nil, fmt.Errorf("parsing error: failed to create syntax tree")
	}
	defer tree.Close()

	root := tree.RootNode()
	if root == nil {
		return nil, fmt.Errorf("parsing error: empty syntax tree")
	}

	// Verify the syntax is valid
	if root.HasError() {
		return nil, fmt.Errorf("parsing error: invalid syntax")
	}

	output := make([]byte, len(input))
	copy(output, input)

	if err := c.processNode(root, &output); err != nil {
		return nil, fmt.Errorf("processing error: %w", err)
	}

	if c.options.OptimizeWhitespace {
		output = c.optimizeWhitespace(output)
	}

	return output, nil
}

// processNode recursively processes a node in the syntax tree
func (c *Cleaner) processNode(node *sitter.Node, content *[]byte) error {
	if !c.shouldProcessNode(node, content) {
		return nil
	}

	// Process children in reverse order to maintain correct byte offsets
	for i := int(node.NamedChildCount()) - 1; i >= 0; i-- {
		child := node.NamedChild(i)
		if err := c.processNode(child, content); err != nil {
			return err
		}
	}

	// Check if this node should be removed
	shouldRemove := false

	// Process comments
	for _, commentType := range c.handler.GetCommentTypes() {
		if node.Type() == commentType && c.shouldRemoveComment(node, *content) {
			shouldRemove = true
			break
		}
	}

	// Process logging calls
	if c.options.RemoveLogging && c.handler.IsLoggingCall(node, *content) {
		shouldRemove = true
	}

	// Process getters/setters
	if c.options.RemoveGettersSetters && c.handler.IsGetterSetter(node, *content) {
		shouldRemove = true
	}

	// Remove the node if necessary
	if shouldRemove {
		*content = c.removeNode(node, *content)
	}

	return nil
}

// shouldProcessNode determines if a node should be processed based on its type
// and position in the syntax tree
func (c *Cleaner) shouldProcessNode(node *sitter.Node, content *[]byte) bool {
	// Skip processing for nil nodes or empty content
	if node == nil || len(*content) == 0 {
		return false
	}

	// Skip processing for nodes outside content bounds
	if node.StartByte() >= uint32(len(*content)) || node.EndByte() > uint32(len(*content)) {
		return false
	}

	return true
}

// shouldRemoveComment determines if a comment should be removed based on
// the cleaner options and whether it's a documentation comment
func (c *Cleaner) shouldRemoveComment(node *sitter.Node, content []byte) bool {
	if !c.options.RemoveComments {
		return false
	}

	if c.options.PreserveDocComments {
		commentText := content[node.StartByte():node.EndByte()]
		docPrefix := c.handler.GetDocCommentPrefix()

		// Handle both byte slices and string prefixes
		if bytes.HasPrefix(bytes.TrimSpace(commentText), []byte(docPrefix)) {
			return false
		}

		// Special handling for single-line comments in Go
		if bytes.HasPrefix(bytes.TrimSpace(commentText), []byte("// ")) {
			text := string(bytes.TrimSpace(commentText))
			if strings.HasPrefix(text, "// Doc ") {
				return false
			}
		}
	}

	return true
}

// removeNode removes a node from the content while preserving the surrounding
// content
func (c *Cleaner) removeNode(node *sitter.Node, content []byte) []byte {
	// Get the start and end of the line containing the node
	start := node.StartByte()
	end := node.EndByte()

	// Find start of line
	lineStart := int(start)
	for lineStart > 0 && content[lineStart-1] != '\n' {
		lineStart--
	}

	// Find end of line
	lineEnd := int(end)
	for lineEnd < len(content) && content[lineEnd] != '\n' {
		lineEnd++
	}

	// If the line contains only this node (plus whitespace), remove the entire line
	line := bytes.TrimSpace(content[lineStart:lineEnd])
	nodeContent := bytes.TrimSpace(content[start:end])
	if bytes.Equal(line, nodeContent) {
		return append(content[:lineStart], content[lineEnd:]...)
	}

	// Otherwise just remove the node itself
	return append(content[:start], content[end:]...)
}

// optimizeWhitespace removes excess whitespace and optionally empty lines
// from the content
func (c *Cleaner) optimizeWhitespace(content []byte) []byte {
	if !c.options.OptimizeWhitespace {
		return content
	}

	lines := bytes.Split(content, []byte("\n"))
	var result [][]byte
	var previousLineEmpty bool

	for i := range lines {
		line := bytes.TrimRight(lines[i], " \t")
		isEmpty := len(bytes.TrimSpace(line)) == 0

		if !isEmpty || (!c.options.RemoveEmptyLines && !previousLineEmpty) {
			result = append(result, line)
		}
		previousLineEmpty = isEmpty
	}

	return append(bytes.Join(result, []byte("\n")), '\n')
}

// CleanFile processes a file and writes the cleaned content to the writer
func (c *Cleaner) CleanFile(r io.Reader, w io.Writer) error {
	input, err := io.ReadAll(r)
	if err != nil {
		return fmt.Errorf("reading error: %w", err)
	}

	cleaned, err := c.Clean(input)
	if err != nil {
		return err
	}

	_, err = w.Write(cleaned)
	return err
}
</document_content>
</document>
<document index="4">
<source>core/cleaner/handlers/bash_handler_test.go</source>
<document_content>package handlers

import (
	"strings"
	"testing"

	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/bash"
)

func TestBashHandlerBasics(t *testing.T) {
	handler := &BashHandler{}

	// Test comment types
	commentTypes := handler.GetCommentTypes()
	if len(commentTypes) != 1 || commentTypes[0] != "comment" {
		t.Errorf("Expected ['comment'], got %v", commentTypes)
	}

	// Test import types
	importTypes := handler.GetImportTypes()
	if len(importTypes) != 2 || importTypes[0] != "source_command" || importTypes[1] != "command" {
		t.Errorf("Expected ['source_command', 'command'], got %v", importTypes)
	}

	// Test doc comment prefix
	if prefix := handler.GetDocCommentPrefix(); prefix != "#" {
		t.Errorf("Expected '#', got %s", prefix)
	}
}

func TestBashLoggingCalls(t *testing.T) {
	handler := &BashHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(bash.GetLanguage())

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name:     "stderr redirection",
			input:    "echo 'Error' >&2",
			expected: true,
		},
		{
			name:     "logger command",
			input:    "logger 'System startup complete'",
			expected: true,
		},
		{
			name:     "debug echo",
			input:    "echo \"Debug: process started\"",
			expected: true,
		},
		{
			name:     "debug printf",
			input:    "printf \"Debug: %s\\n\" \"$var\"",
			expected: true,
		},
		{
			name:     "regular echo",
			input:    "echo 'Hello world'",
			expected: false,
		},
		{
			name:     "regular command",
			input:    "ls -l",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			node := tree.RootNode()
			if node == nil {
				t.Fatal("Failed to get root node")
			}

			// Print all node types and their content
			var printNode func(*sitter.Node, int)
			printNode = func(n *sitter.Node, depth int) {
				if n == nil {
					return
				}
				indent := strings.Repeat("  ", depth)
				content := ""
				if n.StartByte() < uint32(len(tt.input)) && n.EndByte() <= uint32(len(tt.input)) {
					content = string([]byte(tt.input)[n.StartByte():n.EndByte()])
				}
				t.Logf("%sNode type: %s, Content: %q", indent, n.Type(), content)
				for i := 0; i < int(n.ChildCount()); i++ {
					printNode(n.Child(i), depth+1)
				}
			}
			printNode(node, 0)

			// Find the first command or redirected_statement node
			var cmdNode *sitter.Node
			var findCommand func(*sitter.Node)
			findCommand = func(n *sitter.Node) {
				if n.Type() == "command" || n.Type() == "redirected_statement" {
					cmdNode = n
					return
				}
				for i := 0; i < int(n.NamedChildCount()); i++ {
					findCommand(n.NamedChild(i))
				}
			}
			findCommand(node)

			if cmdNode == nil {
				t.Fatal("No command node found")
			}

			result := handler.IsLoggingCall(cmdNode, []byte(tt.input))
			if result != tt.expected {
				t.Errorf("Expected IsLoggingCall() = %v for input %q", tt.expected, tt.input)
			}
		})
	}
}

func TestBashGetterSetter(t *testing.T) {
	handler := &BashHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(bash.GetLanguage())

	// Test with a function definition
	input := `function get_value() { echo "$value"; }`
	tree := parser.Parse(nil, []byte(input))
	defer tree.Close()

	node := tree.RootNode()
	// Bash doesn't have traditional getters/setters
	if handler.IsGetterSetter(node, []byte(input)) {
		t.Error("Expected IsGetterSetter to always return false for Bash")
	}
}
</document_content>
</document>
<document index="5">
<source>core/cleaner/cleaner_test.go</source>
<document_content>package cleaner

import (
	"bytes"
	"context"
	"fmt"
	"testing"

	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/golang"
)

type errorReader struct {
	err error
}

func (r *errorReader) Read(p []byte) (n int, err error) {
	return 0, r.err
}

func TestNewCleaner(t *testing.T) {
	tests := []struct {
		name        string
		lang        Language
		options     *CleanerOptions
		shouldError bool
	}{
		{
			name:        "valid Go cleaner",
			lang:        LangGo,
			options:     DefaultOptions(),
			shouldError: false,
		},
		{
			name:        "nil options",
			lang:        LangGo,
			options:     nil,
			shouldError: true,
		},
		{
			name:        "unsupported language",
			lang:        "invalid",
			options:     DefaultOptions(),
			shouldError: true,
		},
		{
			name:        "valid Java cleaner",
			lang:        LangJava,
			options:     DefaultOptions(),
			shouldError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cleaner, err := NewCleaner(tt.lang, tt.options)
			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}
			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}
			if cleaner == nil {
				t.Error("Expected non-nil cleaner")
			}
		})
	}
}

func TestClean(t *testing.T) {
	tests := []struct {
		name           string
		lang           Language
		input          string
		options        *CleanerOptions
		expected       string
		shouldContain  []string
		shouldNotMatch []string
		shouldError    bool
	}{
		{
			name:  "remove Go comments",
			lang:  LangGo,
			input: "package main\n// This is a comment\nfunc main() {}\n/* Block comment */\n",
			options: &CleanerOptions{
				RemoveComments:      true,
				PreserveDocComments: false,
				OptimizeWhitespace:  true,
				RemoveEmptyLines:    true,
			},
			expected: "package main\nfunc main() {}\n",
		},
		{
			name:  "preserve Go doc comments",
			lang:  LangGo,
			input: "package main\n// Regular comment\n/// Doc comment\nfunc main() {}\n",
			options: &CleanerOptions{
				RemoveComments:      true,
				PreserveDocComments: true,
			},
			shouldContain:  []string{"/// Doc comment"},
			shouldNotMatch: []string{"// Regular comment"},
		},
		{
			name:  "remove Java logging",
			lang:  LangJava,
			input: "class Test {\nvoid test() {\nlog.info(\"test\");\nSystem.out.println(\"debug\");\n}\n}",
			options: &CleanerOptions{
				RemoveLogging: true,
			},
			shouldNotMatch: []string{"log.info", "System.out.println"},
		},
		{
			name:  "remove getters",
			lang:  LangJava,
			input: "public class Test {\n    public String getName() { return name; }\n    void otherMethod() {}\n}",
			options: &CleanerOptions{
				RemoveGettersSetters: true,
			},
			shouldContain:  []string{"otherMethod"},
			shouldNotMatch: []string{"getName"},
		},
		{
			name:  "optimize whitespace",
			lang:  LangGo,
			input: "package main\n\n\nfunc main() {\n\n\n}\n\n",
			options: &CleanerOptions{
				OptimizeWhitespace: true,
				RemoveEmptyLines:   true,
			},
			expected: "package main\nfunc main() {\n}\n",
		},
		{
			name:  "invalid syntax",
			lang:  LangGo,
			input: "package main\nfunc main() {",
			options: &CleanerOptions{
				RemoveComments: true,
			},
			shouldError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cleaner, err := NewCleaner(tt.lang, tt.options)
			if err != nil {
				t.Fatalf("Failed to create cleaner: %v", err)
			}

			output, err := cleaner.Clean([]byte(tt.input))
			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			// Check expected exact match
			if tt.expected != "" && string(output) != tt.expected {
				t.Errorf("Expected:\n%s\nGot:\n%s", tt.expected, string(output))
			}

			// Check content that should be present
			for _, s := range tt.shouldContain {
				if !bytes.Contains(output, []byte(s)) {
					t.Errorf("Expected output to contain %q", s)
				}
			}

			// Check content that should be removed
			for _, s := range tt.shouldNotMatch {
				if bytes.Contains(output, []byte(s)) {
					t.Errorf("Expected output to not contain %q", s)
				}
			}
		})
	}
}

func TestCleanFile(t *testing.T) {
	tests := []struct {
		name        string
		input       string
		options     *CleanerOptions
		shouldError bool
	}{
		{
			name:        "valid input",
			input:       "package main\nfunc main() {}\n",
			shouldError: false,
		},
		{
			name:        "invalid reader",
			input:       "",
			shouldError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cleaner, err := NewCleaner(LangGo, DefaultOptions())
			if err != nil {
				t.Fatalf("Failed to create cleaner: %v", err)
			}

			var input bytes.Buffer
			if tt.name == "invalid reader" {
				// Create a custom reader that always returns an error
				r := &errorReader{err: fmt.Errorf("read error")}
				var output bytes.Buffer
				err = cleaner.CleanFile(r, &output)
			} else {
				input.WriteString(tt.input)
				var output bytes.Buffer
				err = cleaner.CleanFile(&input, &output)
			}

			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}
			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}
		})
	}
}

func TestProcessNode(t *testing.T) {
	parser := sitter.NewParser()
	parser.SetLanguage(golang.GetLanguage())

	input := []byte("package main\n// Comment\nfunc main() {}\n")
	tree, err := parser.ParseCtx(context.Background(), nil, input)
	if err != nil {
		t.Fatalf("Failed to parse input: %v", err)
	}
	defer tree.Close()

	tests := []struct {
		name           string
		options        *CleanerOptions
		shouldContain  []string
		shouldNotMatch []string
	}{
		{
			name: "remove comments",
			options: &CleanerOptions{
				RemoveComments:      true,
				PreserveDocComments: false,
			},
			shouldNotMatch: []string{"// Comment"},
		},
		{
			name: "preserve structure",
			options: &CleanerOptions{
				RemoveComments: true,
			},
			shouldContain: []string{"package main", "func main()"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cleaner, err := NewCleaner(LangGo, tt.options)
			if err != nil {
				t.Fatalf("Failed to create cleaner: %v", err)
			}

			content := make([]byte, len(input))
			copy(content, input)

			err = cleaner.processNode(tree.RootNode(), &content)
			if err != nil {
				t.Fatalf("Failed to process node: %v", err)
			}

			// Check content that should be present
			for _, s := range tt.shouldContain {
				if !bytes.Contains(content, []byte(s)) {
					t.Errorf("Expected output to contain %q", s)
				}
			}

			// Check content that should be removed
			for _, s := range tt.shouldNotMatch {
				if bytes.Contains(content, []byte(s)) {
					t.Errorf("Expected output to not contain %q", s)
				}
			}
		})
	}
}

func TestShouldRemoveComment(t *testing.T) {
	parser := sitter.NewParser()
	parser.SetLanguage(golang.GetLanguage())

	tests := []struct {
		name        string
		options     *CleanerOptions
		commentText string
		shouldKeep  bool
	}{
		{
			name: "regular comment with removal enabled",
			options: &CleanerOptions{
				RemoveComments:      true,
				PreserveDocComments: false,
			},
			commentText: "// Regular comment",
			shouldKeep:  false,
		},
		{
			name: "doc comment with preservation enabled",
			options: &CleanerOptions{
				RemoveComments:      true,
				PreserveDocComments: true,
			},
			commentText: "// Doc comment",
			shouldKeep:  true,
		},
		{
			name: "comment with removal disabled",
			options: &CleanerOptions{
				RemoveComments:      false,
				PreserveDocComments: true,
			},
			commentText: "// Any comment",
			shouldKeep:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cleaner, err := NewCleaner(LangGo, tt.options)
			if err != nil {
				t.Fatalf("Failed to create cleaner: %v", err)
			}

			tree, err := parser.ParseCtx(context.Background(), nil, []byte(tt.commentText))
			if err != nil {
				t.Fatalf("Failed to parse input: %v", err)
			}
			defer tree.Close()

			node := tree.RootNode()
			shouldRemove := cleaner.shouldRemoveComment(node, []byte(tt.commentText))

			if shouldRemove == tt.shouldKeep {
				t.Errorf("Expected shouldRemove=%v for comment %q", !tt.shouldKeep, tt.commentText)
			}
		})
	}
}
</document_content>
</document>
<document index="6">
<source>core/cleaner/handlers/bash_handler.go</source>
<document_content>package handlers

import (
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
)

type BashHandler struct {
	BaseHandler
}

func (h *BashHandler) GetCommentTypes() []string {
	return []string{"comment"}
}

func (h *BashHandler) GetImportTypes() []string {
	return []string{"source_command", "command"}
}

func (h *BashHandler) GetDocCommentPrefix() string {
	return "#"
}

func (h *BashHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	if node == nil {
		return false
	}

	nodeType := node.Type()
	if nodeType == "redirected_statement" {
		// If it's a redirected statement, it's a logging call
		return true
	}

	if nodeType != "command" {
		return false
	}

	// Get the full command text for other checks
	if node.StartByte() >= uint32(len(content)) || node.EndByte() > uint32(len(content)) {
		return false
	}
	cmdText := string(content[node.StartByte():node.EndByte()])

	// Check for logging commands
	return strings.Contains(cmdText, "logger") ||
		strings.Contains(cmdText, "echo \"Debug") ||
		strings.Contains(cmdText, "printf \"Debug")
}

func (h *BashHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	return false
}
</document_content>
</document>
<document index="7">
<source>core/cleaner/handlers/cpp_handler.go</source>
<document_content>package handlers

import (
	"bytes"
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
)

type CPPHandler struct {
	BaseHandler
}

func (h *CPPHandler) GetCommentTypes() []string {
	return []string{"comment", "multiline_comment"}
}

func (h *CPPHandler) GetImportTypes() []string {
	return []string{"preproc_include", "using_declaration"}
}

func (h *CPPHandler) GetDocCommentPrefix() string {
	return "///"
}

func (h *CPPHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	if node == nil || (node.Type() != "call_expression" && node.Type() != "binary_expression") {
		return false
	}
	if node.StartByte() >= uint32(len(content)) || node.EndByte() > uint32(len(content)) {
		return false
	}
	callText := content[node.StartByte():node.EndByte()]
	return bytes.Contains(callText, []byte("cout")) ||
		bytes.Contains(callText, []byte("cerr")) ||
		bytes.Contains(callText, []byte("clog")) ||
		bytes.Contains(callText, []byte("printf")) ||
		bytes.Contains(callText, []byte("fprintf")) ||
		bytes.Contains(callText, []byte("log"))
}

func (h *CPPHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	if node == nil || (node.Type() != "function_definition" && node.Type() != "function_declarator") {
		return false
	}
	if node.StartByte() >= uint32(len(content)) || node.EndByte() > uint32(len(content)) {
		return false
	}
	funcText := string(content[node.StartByte():node.EndByte()])

	isGetter := (strings.Contains(strings.ToLower(funcText), "get") && !strings.Contains(strings.ToLower(funcText), "getvalue")) ||
		(strings.Contains(strings.ToLower(funcText), "is") && !strings.Contains(strings.ToLower(funcText), "isvalue"))
	isSetter := strings.Contains(funcText, "set") ||
		strings.Contains(funcText, "Set")

	if isGetter {
		return !strings.Contains(funcText, "void") &&
			strings.Count(funcText, ",") == 0
	}
	if isSetter {
		return strings.Contains(funcText, "void") &&
			strings.Count(funcText, ",") <= 1
	}
	return false
}
</document_content>
</document>
<document index="8">
<source>core/cleaner/handlers/css_handler.go</source>
<document_content>package handlers

import (
	sitter "github.com/smacker/go-tree-sitter"
)

// CSSHandler handles CSS language specifics
type CSSHandler struct {
	BaseHandler
}

func (h *CSSHandler) GetCommentTypes() []string {
	return []string{"comment"}
}

func (h *CSSHandler) GetImportTypes() []string {
	// @import rules are CSS imports
	return []string{"import_statement", "@import"}
}

func (h *CSSHandler) GetDocCommentPrefix() string {
	return "/*"
}

func (h *CSSHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	// CSS doesn't have logging calls
	return false
}

func (h *CSSHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	// CSS doesn't have getters/setters
	return false
}
</document_content>
</document>
<document index="9">
<source>core/cleaner/handlers/cpp_handler_test.go</source>
<document_content>package handlers

import (
	"testing"

	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/cpp"
)

func TestCPPHandlerBasics(t *testing.T) {
	handler := &CPPHandler{}

	// Test comment types
	commentTypes := handler.GetCommentTypes()
	expected := []string{"comment", "multiline_comment"}
	if !stringSliceEqual(commentTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, commentTypes)
	}

	// Test import types
	importTypes := handler.GetImportTypes()
	expected = []string{"preproc_include", "using_declaration"}
	if !stringSliceEqual(importTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, importTypes)
	}

	// Test doc comment prefix
	if prefix := handler.GetDocCommentPrefix(); prefix != "///" {
		t.Errorf("Expected '///', got %s", prefix)
	}
}

func TestCPPLoggingCalls(t *testing.T) {
	handler := &CPPHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(cpp.GetLanguage())

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name:     "cout logging",
			input:    "cout << \"Log message\" << endl;",
			expected: true,
		},
		{
			name:     "cerr logging",
			input:    "cerr << \"Error message\" << endl;",
			expected: true,
		},
		{
			name:     "clog logging",
			input:    "clog << \"Debug info\" << endl;",
			expected: true,
		},
		{
			name:     "printf logging",
			input:    "printf(\"Debug: %s\\n\", message);",
			expected: true,
		},
		{
			name:     "fprintf logging",
			input:    "fprintf(stderr, \"Error: %s\\n\", error);",
			expected: true,
		},
		{
			name:     "custom log call",
			input:    "log(\"Message\");",
			expected: true,
		},
		{
			name:     "regular function call",
			input:    "process(\"data\");",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			node := tree.RootNode()
			var callNode *sitter.Node
			cursor := sitter.NewTreeCursor(node)
			defer cursor.Close()

			// Find the call expression node
			var findCall func(*sitter.Node)
			findCall = func(n *sitter.Node) {
				if n.Type() == "call_expression" || n.Type() == "binary_expression" {
					callNode = n
					return
				}
				for i := 0; i < int(n.NamedChildCount()); i++ {
					findCall(n.NamedChild(i))
				}
			}
			findCall(node)

			if callNode == nil {
				t.Fatal("No call/binary expression node found")
			}

			result := handler.IsLoggingCall(callNode, []byte(tt.input))
			if result != tt.expected {
				t.Errorf("Expected IsLoggingCall() = %v for input %q", tt.expected, tt.input)
			}
		})
	}
}

func TestCPPGetterSetter(t *testing.T) {
	handler := &CPPHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(cpp.GetLanguage())

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name: "getter method",
			input: `string getName() const {
                return name;
            }`,
			expected: true,
		},
		{
			name: "setter method",
			input: `void setName(string value) {
                name = value;
            }`,
			expected: true,
		},
		{
			name: "is getter",
			input: `bool isValid() const {
                return valid;
            }`,
			expected: true,
		},
		{
			name: "regular method",
			input: `void process() {
                doWork();
            }`,
			expected: false,
		},
		{
			name: "complex getter",
			input: `int getValue(int index) {
                return values[index];
            }`,
			expected: false, // Has parameter, not a simple getter
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			node := tree.RootNode()
			var funcNode *sitter.Node
			cursor := sitter.NewTreeCursor(node)
			defer cursor.Close()

			// Find the function definition node
			var findFunc func(*sitter.Node)
			findFunc = func(n *sitter.Node) {
				if n.Type() == "function_definition" {
					funcNode = n
					return
				}
				for i := 0; i < int(n.NamedChildCount()); i++ {
					findFunc(n.NamedChild(i))
				}
			}
			findFunc(node)

			if funcNode == nil {
				t.Fatal("No function definition node found")
			}

			result := handler.IsGetterSetter(funcNode, []byte(tt.input))
			if result != tt.expected {
				t.Errorf("Expected IsGetterSetter() = %v for input %q", tt.expected, tt.input)
			}
		})
	}
}
</document_content>
</document>
<document index="10">
<source>core/cleaner/handlers/csharp_handler.go</source>
<document_content>package handlers

import (
	"bytes"
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
)

// CSharpHandler handles C# language specifics
type CSharpHandler struct {
	BaseHandler
}

func (h *CSharpHandler) GetCommentTypes() []string {
	return []string{"comment", "multiline_comment"}
}

func (h *CSharpHandler) GetImportTypes() []string {
	return []string{"using_directive"}
}

func (h *CSharpHandler) GetDocCommentPrefix() string {
	return "///"
}

func (h *CSharpHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	if node.Type() != "invocation_expression" {
		return false
	}
	callText := content[node.StartByte():node.EndByte()]
	return bytes.Contains(callText, []byte("Console.")) ||
		bytes.Contains(callText, []byte("Debug.")) ||
		bytes.Contains(callText, []byte("Logger.")) ||
		bytes.Contains(callText, []byte("Trace."))
}

func (h *CSharpHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	if node.Type() != "property_declaration" && node.Type() != "method_declaration" {
		return false
	}
	methodText := string(content[node.StartByte():node.EndByte()])

	// Check for auto-implemented properties
	if strings.Contains(methodText, "{ get;") || strings.Contains(methodText, "{ set;") {
		return true
	}

	// Check for traditional getter/setter methods
	if nameNode := node.ChildByFieldName("name"); nameNode != nil {
		name := string(content[nameNode.StartByte():nameNode.EndByte()])
		return strings.HasPrefix(name, "Get") || strings.HasPrefix(name, "Set")
	}

	return false
}
</document_content>
</document>
<document index="11">
<source>core/cleaner/handlers/html_handler.go</source>
<document_content>package handlers

import (
	sitter "github.com/smacker/go-tree-sitter"
)

// HTMLHandler handles HTML language specifics
type HTMLHandler struct {
	BaseHandler
}

func (h *HTMLHandler) GetCommentTypes() []string {
	return []string{"comment"}
}

func (h *HTMLHandler) GetImportTypes() []string {
	// Consider <link> and <script> tags as imports
	return []string{"link_element", "script_element"}
}

func (h *HTMLHandler) GetDocCommentPrefix() string {
	return "<!--"
}

func (h *HTMLHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	// HTML doesn't have traditional logging calls
	return false
}

func (h *HTMLHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	// HTML doesn't have getters/setters
	return false
}
</document_content>
</document>
<document index="12">
<source>core/cleaner/handlers/java_handler_test.go</source>
<document_content>package handlers

import (
	"testing"

	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/java"
)

func TestJavaHandlerBasics(t *testing.T) {
	handler := &JavaHandler{}

	// Test comment types
	commentTypes := handler.GetCommentTypes()
	expected := []string{"line_comment", "block_comment", "javadoc_comment"}
	if !stringSliceEqual(commentTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, commentTypes)
	}

	// Test import types
	importTypes := handler.GetImportTypes()
	expected = []string{"import_declaration"}
	if !stringSliceEqual(importTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, importTypes)
	}

	// Test doc comment prefix
	if prefix := handler.GetDocCommentPrefix(); prefix != "/**" {
		t.Errorf("Expected '/**', got %s", prefix)
	}
}

func TestJavaHandlerLoggingAndGetterSetter(t *testing.T) {
	handler := &JavaHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(java.GetLanguage())

	tests := []struct {
		name      string
		input     string
		isLogging bool
		isGetter  bool
	}{
		{
			name:      "logger field",
			input:     "class Test { void test() { logger.info(\"test\"); } }",
			isLogging: true,
			isGetter:  false,
		},
		{
			name:      "system out",
			input:     "class Test { void test() { System.out.println(\"test\"); } }",
			isLogging: true,
			isGetter:  false,
		},
		{
			name:      "system err",
			input:     "class Test { void test() { System.err.println(\"error\"); } }",
			isLogging: true,
			isGetter:  false,
		},
		{
			name:      "log call",
			input:     "class Test { void test() { log.debug(\"debug\"); } }",
			isLogging: true,
			isGetter:  false,
		},
		{
			name:      "Logger static call",
			input:     "class Test { void test() { Logger.getLogger(Test.class).info(\"test\"); } }",
			isLogging: true,
			isGetter:  false,
		},
		{
			name:      "regular method call",
			input:     "class Test { void test() { process(\"data\"); } }",
			isLogging: false,
			isGetter:  false,
		},
		{
			name:      "getter method",
			input:     "class Test { public String getName() { return name; } }",
			isLogging: false,
			isGetter:  true,
		},
		{
			name:      "setter method",
			input:     "class Test { public void setName(String name) { this.name = name; } }",
			isLogging: false,
			isGetter:  true,
		},
		{
			name:      "boolean getter with is prefix",
			input:     "class Test { public boolean isValid() { return valid; } }",
			isLogging: false,
			isGetter:  true,
		},
		{
			name:      "getter with javadoc",
			input:     "class Test { /** Gets the name */ public String getName() { return name; } }",
			isLogging: false,
			isGetter:  true,
		},
		{
			name:      "regular method",
			input:     "class Test { public void process() { doWork(); } }",
			isLogging: false,
			isGetter:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			// Navigate to find the relevant nodes
			var cursor = sitter.NewTreeCursor(tree.RootNode())
			defer cursor.Close()

			var processNode func(*sitter.Node)
			processNode = func(node *sitter.Node) {
				if node == nil {
					return
				}

				nodeType := node.Type()
				if nodeType == "method_invocation" {
					if got := handler.IsLoggingCall(node, []byte(tt.input)); got != tt.isLogging {
						t.Errorf("IsLoggingCall() = %v, want %v for %s", got, tt.isLogging, nodeType)
					}
				} else if nodeType == "method_declaration" {
					if got := handler.IsGetterSetter(node, []byte(tt.input)); got != tt.isGetter {
						t.Errorf("IsGetterSetter() = %v, want %v for %s", got, tt.isGetter, nodeType)
					}
				}

				// Process children
				for i := 0; i < int(node.NamedChildCount()); i++ {
					child := node.NamedChild(i)
					processNode(child)
				}
			}

			processNode(tree.RootNode())
		})
	}
}
</document_content>
</document>
<document index="13">
<source>core/cleaner/handlers/go_handler.go</source>
<document_content>package handlers

import (
	"bytes"
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
)

// GoHandler handles Go language specifics
type GoHandler struct {
	BaseHandler
}

func (h *GoHandler) GetCommentTypes() []string {
	return []string{"comment"}
}

func (h *GoHandler) GetImportTypes() []string {
	return []string{"import_declaration", "import_spec"}
}

func (h *GoHandler) GetDocCommentPrefix() string {
	return "///"
}

func (h *GoHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	if node.Type() != "call_expression" {
		return false
	}
	callText := content[node.StartByte():node.EndByte()]
	return bytes.Contains(callText, []byte("log.")) ||
		bytes.Contains(callText, []byte("logger.")) ||
		bytes.Contains(callText, []byte("Debug(")) ||
		bytes.Contains(callText, []byte(".Print"))
}

func (h *GoHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	if node.Type() != "function_declaration" {
		return false
	}

	// Get function name
	nameNode := node.ChildByFieldName("name")
	if nameNode == nil {
		return false
	}

	name := string(content[nameNode.StartByte():nameNode.EndByte()])
	return strings.HasPrefix(strings.ToLower(name), "get") ||
		strings.HasPrefix(strings.ToLower(name), "set")
}
</document_content>
</document>
<document index="14">
<source>core/cleaner/handlers/go_handler_test.go</source>
<document_content>package handlers

import (
	"testing"

	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/golang"
)

func TestGoHandlerBasics(t *testing.T) {
	handler := &GoHandler{}

	// Test comment types
	commentTypes := handler.GetCommentTypes()
	expected := []string{"comment"}
	if !stringSliceEqual(commentTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, commentTypes)
	}

	// Test import types
	importTypes := handler.GetImportTypes()
	expected = []string{"import_declaration", "import_spec"}
	if !stringSliceEqual(importTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, importTypes)
	}

	// Test doc comment prefix
	if prefix := handler.GetDocCommentPrefix(); prefix != "///" {
		t.Errorf("Expected '///', got %s", prefix)
	}
}

func TestGoHandlerLoggingAndGetterSetter(t *testing.T) {
	handler := &GoHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(golang.GetLanguage())

	tests := []struct {
		name      string
		input     string
		isLogging bool
		isGetter  bool
	}{
		{
			name:      "log print",
			input:     "package main\nfunc main() { log.Println(\"test\") }",
			isLogging: true,
			isGetter:  false,
		},
		{
			name:      "logger debug",
			input:     "package main\nfunc main() { logger.Debug(\"test\") }",
			isLogging: true,
			isGetter:  false,
		},
		{
			name:      "getter method",
			input:     "package main\nfunc GetName() string { return name }",
			isLogging: false,
			isGetter:  true,
		},
		{
			name:      "setter method",
			input:     "package main\nfunc SetName(name string) { this.name = name }",
			isLogging: false,
			isGetter:  true,
		},
		{
			name:      "regular function",
			input:     "package main\nfunc Process() error { return nil }",
			isLogging: false,
			isGetter:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			var processNode func(*sitter.Node)
			processNode = func(node *sitter.Node) {
				if node == nil {
					return
				}

				nodeType := node.Type()
				if nodeType == "call_expression" {
					if got := handler.IsLoggingCall(node, []byte(tt.input)); got != tt.isLogging {
						t.Errorf("IsLoggingCall() = %v, want %v for %s", got, tt.isLogging, nodeType)
					}
				} else if nodeType == "function_declaration" {
					if got := handler.IsGetterSetter(node, []byte(tt.input)); got != tt.isGetter {
						t.Errorf("IsGetterSetter() = %v, want %v for %s", got, tt.isGetter, nodeType)
					}
				}

				// Process children
				for i := 0; i < int(node.NamedChildCount()); i++ {
					processNode(node.NamedChild(i))
				}
			}

			processNode(tree.RootNode())
		})
	}
}
</document_content>
</document>
<document index="15">
<source>core/cleaner/handlers/kotlin_handler.go</source>
<document_content>package handlers

import (
	"bytes"
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
)

type KotlinHandler struct {
	BaseHandler
}

func (h *KotlinHandler) GetCommentTypes() []string {
	return []string{"comment", "multiline_comment", "kdoc"}
}

func (h *KotlinHandler) GetImportTypes() []string {
	return []string{"import_header"}
}

func (h *KotlinHandler) GetDocCommentPrefix() string {
	return "/**"
}

func (h *KotlinHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	if node == nil || node.Type() != "call_expression" {
		return false
	}

	if node.StartByte() >= uint32(len(content)) || node.EndByte() > uint32(len(content)) {
		return false
	}

	callText := content[node.StartByte():node.EndByte()]
	return bytes.Contains(bytes.ToLower(callText), []byte("println(")) ||
		bytes.Contains(bytes.ToLower(callText), []byte("print(")) ||
		bytes.Contains(callText, []byte("Logger.")) ||
		bytes.Contains(callText, []byte("logger.")) ||
		bytes.Contains(callText, []byte("log."))
}

// findFirstChild recursively searches for a child node of the specified type
func findFirstChild(node *sitter.Node, nodeType string) *sitter.Node {
	if node == nil {
		return nil
	}
	if node.Type() == nodeType {
		return node
	}
	for i := 0; i < int(node.NamedChildCount()); i++ {
		if found := findFirstChild(node.NamedChild(i), nodeType); found != nil {
			return found
		}
	}
	return nil
}

func (h *KotlinHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	if node == nil {
		return false
	}

	// Check for property declarations with getter/setter
	switch node.Type() {
	case "source_file":
		// For source_file nodes, check their children
		for i := 0; i < int(node.NamedChildCount()); i++ {
			child := node.NamedChild(i)
			if h.IsGetterSetter(child, content) {
				return true
			}
		}

	case "property_declaration":
		// Look for getter and setter nodes
		for i := 0; i < int(node.NamedChildCount()); i++ {
			child := node.NamedChild(i)
			if child.Type() == "getter" || child.Type() == "setter" {
				return true
			}
		}

	case "function_declaration":
		// Get the function name
		nameNode := findFirstChild(node, "simple_identifier")
		if nameNode == nil || nameNode.StartByte() >= uint32(len(content)) || nameNode.EndByte() > uint32(len(content)) {
			return false
		}

		name := string(content[nameNode.StartByte():nameNode.EndByte()])
		name = strings.ToLower(name)

		// Check for getter/setter naming patterns
		if strings.HasPrefix(name, "get") || strings.HasPrefix(name, "set") {
			return true
		}
	}

	return false
}
</document_content>
</document>
<document index="16">
<source>core/cleaner/handlers/javascript_handler_test.go</source>
<document_content>package handlers

import (
	"testing"

	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/javascript"
)

func TestJavaScriptHandlerBasics(t *testing.T) {
	handler := &JavaScriptHandler{}

	// Test comment types
	commentTypes := handler.GetCommentTypes()
	expected := []string{"comment", "multiline_comment"}
	if !stringSliceEqual(commentTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, commentTypes)
	}

	// Test import types
	importTypes := handler.GetImportTypes()
	expected = []string{"import_statement", "import_specifier"}
	if !stringSliceEqual(importTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, importTypes)
	}

	// Test doc comment prefix
	if prefix := handler.GetDocCommentPrefix(); prefix != "/**" {
		t.Errorf("Expected '/**', got %s", prefix)
	}
}

func TestJavaScriptHandlerLoggingAndGetterSetter(t *testing.T) {
	handler := &JavaScriptHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(javascript.GetLanguage())

	tests := []struct {
		name      string
		input     string
		isLogging bool
		isGetter  bool
	}{
		{
			name:      "console log",
			input:     "console.log('test');",
			isLogging: true,
			isGetter:  false,
		},
		{
			name:      "logger debug",
			input:     "logger.debug('test');",
			isLogging: true,
			isGetter:  false,
		},
		{
			name:      "getter method",
			input:     "class Test { get name() { return this._name; } }",
			isLogging: false,
			isGetter:  true,
		},
		{
			name:      "setter method",
			input:     "class Test { set name(value) { this._name = value; } }",
			isLogging: false,
			isGetter:  true,
		},
		{
			name:      "regular method",
			input:     "function test() { return true; }",
			isLogging: false,
			isGetter:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			root := tree.RootNode()
			if root == nil {
				t.Fatal("Failed to get root node")
			}

			var checkNode func(*sitter.Node)
			checkNode = func(n *sitter.Node) {
				if n == nil {
					return
				}

				nodeType := n.Type()
				if nodeType == "call_expression" ||
					nodeType == "method_definition" ||
					nodeType == "getter_declaration" ||
					nodeType == "setter_declaration" {
					if got := handler.IsLoggingCall(n, []byte(tt.input)); got != tt.isLogging {
						t.Errorf("IsLoggingCall() = %v, want %v for %s", got, tt.isLogging, nodeType)
					}
					if got := handler.IsGetterSetter(n, []byte(tt.input)); got != tt.isGetter {
						t.Errorf("IsGetterSetter() = %v, want %v for %s", got, tt.isGetter, nodeType)
					}
				}

				for i := 0; i < int(n.ChildCount()); i++ {
					checkNode(n.Child(i))
				}
			}

			checkNode(root)
		})
	}
}
</document_content>
</document>
<document index="17">
<source>core/cleaner/handlers/javascript_handler.go</source>
<document_content>package handlers

import (
	"bytes"
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
)

// JavaScriptHandler handles JavaScript language specifics
type JavaScriptHandler struct {
	BaseHandler
}

func (h *JavaScriptHandler) GetCommentTypes() []string {
	return []string{"comment", "multiline_comment"}
}

func (h *JavaScriptHandler) GetImportTypes() []string {
	return []string{"import_statement", "import_specifier"}
}

func (h *JavaScriptHandler) GetDocCommentPrefix() string {
	return "/**"
}

func (h *JavaScriptHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	if node.Type() != "call_expression" {
		return false
	}
	callText := content[node.StartByte():node.EndByte()]
	return bytes.HasPrefix(callText, []byte("console.")) ||
		bytes.HasPrefix(callText, []byte("logger."))
}

func (h *JavaScriptHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	nodeType := node.Type()
	if nodeType != "method_definition" &&
		nodeType != "getter_declaration" &&
		nodeType != "setter_declaration" {
		return false
	}

	methodText := string(content[node.StartByte():node.EndByte()])
	return strings.HasPrefix(methodText, "get ") ||
		strings.HasPrefix(methodText, "set ") ||
		nodeType == "getter_declaration" ||
		nodeType == "setter_declaration"
}
</document_content>
</document>
<document index="18">
<source>core/cleaner/handlers/php_handler_test.go</source>
<document_content>package handlers

import (
	"testing"

	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/php"
)

func TestPHPHandlerBasics(t *testing.T) {
	handler := &PHPHandler{}

	// Test comment types
	commentTypes := handler.GetCommentTypes()
	expected := []string{"comment", "doc_comment"}
	if !stringSliceEqual(commentTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, commentTypes)
	}

	// Test import types
	importTypes := handler.GetImportTypes()
	expected = []string{"namespace_use_declaration", "require", "require_once", "include", "include_once"}
	if !stringSliceEqual(importTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, importTypes)
	}

	// Test doc comment prefix
	if prefix := handler.GetDocCommentPrefix(); prefix != "/**" {
		t.Errorf("Expected '/**', got %s", prefix)
	}
}

func TestPHPLoggingCalls(t *testing.T) {
	handler := &PHPHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(php.GetLanguage())

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name:     "error_log call",
			input:    "<?php error_log('Error message'); ?>",
			expected: true,
		},
		{
			name:     "print_r call",
			input:    "<?php print_r($data); ?>",
			expected: true,
		},
		{
			name:     "var_dump call",
			input:    "<?php var_dump($variable); ?>",
			expected: true,
		},
		{
			name:     "regular echo",
			input:    "<?php echo 'Hello'; ?>",
			expected: false,
		},
		{
			name:     "regular function call",
			input:    "<?php process($data); ?>",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			node := tree.RootNode()
			var callNode *sitter.Node

			var findCall func(*sitter.Node)
			findCall = func(n *sitter.Node) {
				if n == nil {
					return
				}

				// Debug node types
				t.Logf("Node type: %s", n.Type())

				nodeType := n.Type()
				if nodeType == "function_call_expression" {
					callNode = n
					return
				}

				if nodeType == "echo_statement" {
					callNode = n
					return
				}

				// Try both named and unnamed children
				for i := 0; i < int(n.ChildCount()); i++ {
					findCall(n.Child(i))
				}
			}
			findCall(node)

			if callNode == nil {
				t.Fatalf("No function call node found in input: %s\nAST structure: %s", tt.input, node.String())
			}

			result := handler.IsLoggingCall(callNode, []byte(tt.input))
			if result != tt.expected {
				t.Errorf("Expected IsLoggingCall() = %v for input %q", tt.expected, tt.input)
			}
		})
	}
}

func TestPHPGetterSetter(t *testing.T) {
	handler := &PHPHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(php.GetLanguage())

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name: "getter method",
			input: `<?php
                class Test {
                    public function getName() {
                        return $this->name;
                    }
                }
            ?>`,
			expected: true,
		},
		{
			name: "setter method",
			input: `<?php
                class Test {
                    public function setName($value) {
                        $this->name = $value;
                    }
                }
            ?>`,
			expected: true,
		},
		{
			name: "regular method",
			input: `<?php
                class Test {
                    public function process() {
                        return $this->doWork();
                    }
                }
            ?>`,
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			node := tree.RootNode()
			var methodNode *sitter.Node

			var findMethod func(*sitter.Node)
			findMethod = func(n *sitter.Node) {
				if n == nil {
					return
				}
				if n.Type() == "method_declaration" {
					methodNode = n
					return
				}
				for i := 0; i < int(n.NamedChildCount()); i++ {
					findMethod(n.NamedChild(i))
				}
			}
			findMethod(node)

			if methodNode == nil {
				t.Fatal("No method declaration node found")
			}

			result := handler.IsGetterSetter(methodNode, []byte(tt.input))
			if result != tt.expected {
				t.Errorf("Expected IsGetterSetter() = %v for input %q", tt.expected, tt.input)
			}
		})
	}
}
</document_content>
</document>
<document index="19">
<source>core/cleaner/handlers/python_handler_test.go</source>
<document_content>package handlers

import (
	"testing"

	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/python"
)

func TestPythonHandlerBasics(t *testing.T) {
	handler := &PythonHandler{}

	// Test comment types
	commentTypes := handler.GetCommentTypes()
	if len(commentTypes) != 1 || commentTypes[0] != "comment" {
		t.Errorf("Expected ['comment'], got %v", commentTypes)
	}

	// Test import types
	importTypes := handler.GetImportTypes()
	expected := []string{"import_statement", "import_from_statement"}
	if !stringSliceEqual(importTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, importTypes)
	}

	// Test doc comment prefix
	if prefix := handler.GetDocCommentPrefix(); prefix != `"""` {
		t.Errorf("Expected '\"\"\"', got %s", prefix)
	}
}

func TestPythonHandlerLogging(t *testing.T) {
	handler := &PythonHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(python.GetLanguage())

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name:     "simple print call",
			input:    "print('Debug message')",
			expected: true,
		},
		{
			name:     "print with formatting",
			input:    "print(f'Value is {value}')",
			expected: true,
		},
		{
			name:     "logging module info",
			input:    "logging.info('Info message')",
			expected: true,
		},
		{
			name:     "logging module debug",
			input:    "logging.debug('Debug info')",
			expected: true,
		},
		{
			name:     "logging module error",
			input:    "logging.error('Error occurred')",
			expected: true,
		},
		{
			name:     "logger instance debug",
			input:    "logger.debug('Debug info')",
			expected: true,
		},
		{
			name:     "logger instance info",
			input:    "logger.info('Info message')",
			expected: true,
		},
		{
			name:     "regular function call",
			input:    "process_data('input')",
			expected: false,
		},
		{
			name:     "method call",
			input:    "obj.process()",
			expected: false,
		},
		{
			name:     "print-like method",
			input:    "printer.execute('message')",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			node := tree.RootNode()
			var callNode *sitter.Node
			var findCall func(*sitter.Node)
			findCall = func(n *sitter.Node) {
				if n.Type() == "call" {
					callNode = n
					return
				}
				for i := 0; i < int(n.NamedChildCount()); i++ {
					findCall(n.NamedChild(i))
				}
			}
			findCall(node)

			if callNode == nil {
				t.Fatal("No call node found")
			}

			result := handler.IsLoggingCall(callNode, []byte(tt.input))
			if result != tt.expected {
				t.Errorf("Expected IsLoggingCall() = %v for input %q", tt.expected, tt.input)
			}
		})
	}
}

func TestPythonHandlerGetterSetter(t *testing.T) {
	handler := &PythonHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(python.GetLanguage())

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name: "property getter",
			input: `@property
def name(self):
    return self._name`,
			expected: true,
		},
		{
			name: "property with decorator and docstring",
			input: `@property
def name(self):
    """Get the name value."""
    return self._name`,
			expected: true,
		},
		{
			name: "traditional getter",
			input: `def get_name(self):
    return self._name`,
			expected: true,
		},
		{
			name: "traditional setter",
			input: `def set_name(self, value):
    self._name = value`,
			expected: true,
		},
		{
			name: "get method with validation",
			input: `def get_value(self):
    if self._value is None:
        raise ValueError("Value not set")
    return self._value`,
			expected: true,
		},
		{
			name: "set method with validation",
			input: `def set_value(self, value):
    if value < 0:
        raise ValueError("Value must be positive")
    self._value = value`,
			expected: true,
		},
		{
			name: "regular method",
			input: `def process_data(self):
    return self.data.process()`,
			expected: false,
		},
		{
			name: "get method with args",
			input: `def get_item(self, index):
    return self._items[index]`,
			expected: true,
		},
		{
			name: "method with get prefix",
			input: `def getting_started():
    print("Tutorial")`,
			expected: false,
		},
		{
			name: "non-property decorated method",
			input: `@staticmethod
def get_version():
    return "1.0.0"`,
			expected: true,
		},
		{
			name: "unrelated decorator method",
			input: `@deprecated
def get_legacy_value():
    return old_value`,
			expected: true,
		},
		{
			name: "complex getter",
			input: `def get_calculated_value(self):
    return sum(self._values) / len(self._values)`,
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			node := tree.RootNode()
			var funcNode *sitter.Node
			var findFunc func(*sitter.Node)
			findFunc = func(n *sitter.Node) {
				if n.Type() == "function_definition" {
					funcNode = n
					return
				}
				for i := 0; i < int(n.NamedChildCount()); i++ {
					findFunc(n.NamedChild(i))
				}
			}
			findFunc(node)

			if funcNode == nil {
				t.Fatal("No function definition node found")
			}

			result := handler.IsGetterSetter(funcNode, []byte(tt.input))
			if result != tt.expected {
				t.Errorf("Expected IsGetterSetter() = %v for input %q", tt.expected, tt.input)
			}
		})
	}
}

func TestPythonHandlerEdgeCases(t *testing.T) {
	handler := &PythonHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(python.GetLanguage())

	// Test invalid node
	if handler.IsLoggingCall(nil, []byte("")) {
		t.Error("Expected IsLoggingCall to return false for nil node")
	}
	if handler.IsGetterSetter(nil, []byte("")) {
		t.Error("Expected IsGetterSetter to return false for nil node")
	}

	// Test empty content
	tree := parser.Parse(nil, []byte(""))
	if tree == nil {
		t.Fatal("Failed to parse empty input")
	}
	defer tree.Close()

	node := tree.RootNode()
	if handler.IsLoggingCall(node, []byte("")) {
		t.Error("Expected IsLoggingCall to return false for empty content")
	}
	if handler.IsGetterSetter(node, []byte("")) {
		t.Error("Expected IsGetterSetter to return false for empty content")
	}

	// Test malformed input
	malformed := "def get_value(self:"
	tree = parser.Parse(nil, []byte(malformed))
	if tree == nil {
		t.Fatal("Failed to parse malformed input")
	}
	defer tree.Close()
	node = tree.RootNode()
	if handler.IsGetterSetter(node, []byte(malformed)) {
		t.Error("Expected IsGetterSetter to return false for malformed input")
	}
}
</document_content>
</document>
<document index="20">
<source>core/cleaner/handlers/python_handler.go</source>
<document_content>package handlers

import (
	"bytes"
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
)

type PythonHandler struct {
	BaseHandler
}

func (h *PythonHandler) GetCommentTypes() []string {
	return []string{"comment"}
}

func (h *PythonHandler) GetImportTypes() []string {
	return []string{"import_statement", "import_from_statement"}
}

func (h *PythonHandler) GetDocCommentPrefix() string {
	return "\"\"\""
}

func (h *PythonHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	if node == nil || node.Type() != "call" {
		return false
	}
	if node.StartByte() >= uint32(len(content)) || node.EndByte() > uint32(len(content)) {
		return false
	}
	callText := content[node.StartByte():node.EndByte()]
	return bytes.HasPrefix(callText, []byte("print(")) ||
		bytes.HasPrefix(callText, []byte("logging.")) ||
		bytes.HasPrefix(callText, []byte("logger."))
}

func (h *PythonHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	if node == nil || node.Type() != "function_definition" {
		return false
	}
	if node.StartByte() >= uint32(len(content)) || node.EndByte() > uint32(len(content)) {
		return false
	}

	// Check for property decorator
	parent := node.Parent()
	if parent != nil {
		parentText := string(content[parent.StartByte():parent.EndByte()])
		if strings.Contains(parentText, "@property") {
			return true
		}
	}

	nameNode := node.ChildByFieldName("name")
	if nameNode == nil {
		return false
	}
	name := string(content[nameNode.StartByte():nameNode.EndByte()])
	return strings.HasPrefix(name, "get_") ||
		strings.HasPrefix(name, "set_")
}
</document_content>
</document>
<document index="21">
<source>core/cleaner/handlers/ruby_handler.go</source>
<document_content>package handlers

import (
	"bytes"
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
)

// RubyHandler handles Ruby language specifics
type RubyHandler struct {
	BaseHandler
}

func (h *RubyHandler) GetCommentTypes() []string {
	return []string{"comment"}
}

func (h *RubyHandler) GetImportTypes() []string {
	return []string{"require", "include", "require_relative"}
}

func (h *RubyHandler) GetDocCommentPrefix() string {
	return "#"
}

func (h *RubyHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	if node.Type() != "method_call" {
		return false
	}
	callText := content[node.StartByte():node.EndByte()]
	return bytes.HasPrefix(callText, []byte("puts ")) ||
		bytes.HasPrefix(callText, []byte("print ")) ||
		bytes.HasPrefix(callText, []byte("p ")) ||
		bytes.HasPrefix(callText, []byte("logger."))
}

func (h *RubyHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	if node.Type() != "call" && node.Type() != "method" {
		return false
	}
	methodText := string(content[node.StartByte():node.EndByte()])
	return strings.Contains(methodText, "attr_reader") ||
		strings.Contains(methodText, "attr_writer") ||
		strings.Contains(methodText, "attr_accessor") ||
		strings.HasPrefix(methodText, "def get_") ||
		strings.HasPrefix(methodText, "def set_")
}
</document_content>
</document>
<document index="22">
<source>core/cleaner/handlers/php_handler.go</source>
<document_content>package handlers

import (
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
)

type PHPHandler struct {
	BaseHandler
}

func (h *PHPHandler) GetCommentTypes() []string {
	return []string{"comment", "doc_comment"}
}

func (h *PHPHandler) GetImportTypes() []string {
	return []string{"namespace_use_declaration", "require", "require_once", "include", "include_once"}
}

func (h *PHPHandler) GetDocCommentPrefix() string {
	return "/**"
}

func findNodeOfType(node *sitter.Node, nodeType string) *sitter.Node {
	if node == nil {
		return nil
	}
	if node.Type() == nodeType {
		return node
	}
	for i := 0; i < int(node.NamedChildCount()); i++ {
		if found := findNodeOfType(node.NamedChild(i), nodeType); found != nil {
			return found
		}
	}
	return nil
}

func (h *PHPHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	if node == nil {
		return false
	}

	// Get the function name from the node
	var funcName string
	nodeType := node.Type()

	if nodeType == "function_call_expression" {
		nameNode := node.ChildByFieldName("function")
		if nameNode != nil && nameNode.StartByte() < uint32(len(content)) && nameNode.EndByte() <= uint32(len(content)) {
			funcName = string(content[nameNode.StartByte():nameNode.EndByte()])
		}
	} else if nodeType == "echo_statement" {
		return false
	}

	if funcName == "" {
		return false
	}

	// Check for logging function names
	return funcName == "error_log" ||
		funcName == "print_r" ||
		funcName == "var_dump"
}

func (h *PHPHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	if node == nil {
		return false
	}

	methodNode := findNodeOfType(node, "method_declaration")
	if methodNode == nil {
		return false
	}

	if methodNode.StartByte() >= uint32(len(content)) || methodNode.EndByte() > uint32(len(content)) {
		return false
	}

	methodText := string(content[methodNode.StartByte():methodNode.EndByte()])
	return strings.Contains(methodText, "public function get") ||
		strings.Contains(methodText, "public function set")
}
</document_content>
</document>
<document index="23">
<source>core/cleaner/handlers/kotlin_handler_test.go</source>
<document_content>package handlers

import (
	"testing"

	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/kotlin"
)

func TestKotlinHandlerBasics(t *testing.T) {
	handler := &KotlinHandler{}

	// Test comment types
	commentTypes := handler.GetCommentTypes()
	expected := []string{"comment", "multiline_comment", "kdoc"}
	if !stringSliceEqual(commentTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, commentTypes)
	}

	// Test import types
	importTypes := handler.GetImportTypes()
	expected = []string{"import_header"}
	if !stringSliceEqual(importTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, importTypes)
	}

	// Test doc comment prefix
	if prefix := handler.GetDocCommentPrefix(); prefix != "/**" {
		t.Errorf("Expected '/**', got %s", prefix)
	}
}

func TestKotlinLoggingCalls(t *testing.T) {
	handler := &KotlinHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(kotlin.GetLanguage())

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name:     "println call",
			input:    "println(\"Debug message\")",
			expected: true,
		},
		{
			name:     "print call",
			input:    "print(\"Debug info\")",
			expected: true,
		},
		{
			name:     "Logger call",
			input:    "Logger.debug(\"Debug info\")",
			expected: true,
		},
		{
			name:     "logger instance call",
			input:    "logger.info(\"message\")",
			expected: true,
		},
		{
			name:     "log call",
			input:    "log.info(\"Info message\")",
			expected: true,
		},
		{
			name:     "regular function call",
			input:    "process(\"data\")",
			expected: false,
		},
		{
			name:     "method call",
			input:    "obj.process()",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			node := tree.RootNode()
			var callNode *sitter.Node
			var findCall func(*sitter.Node)
			findCall = func(n *sitter.Node) {
				if n.Type() == "call_expression" {
					callNode = n
					return
				}
				for i := 0; i < int(n.NamedChildCount()); i++ {
					findCall(n.NamedChild(i))
				}
			}
			findCall(node)

			if callNode == nil {
				t.Fatal("No call node found")
			}

			result := handler.IsLoggingCall(callNode, []byte(tt.input))
			if result != tt.expected {
				t.Errorf("Expected IsLoggingCall() = %v for input %q", tt.expected, tt.input)
			}
		})
	}
}

func TestKotlinGetterSetter(t *testing.T) {
	handler := &KotlinHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(kotlin.GetLanguage())

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name: "property with getter",
			input: `var name: String
				get() = field`,
			expected: true,
		},
		{
			name: "property with getter and setter",
			input: `var name: String
				get() = field
				set(value) { field = value }`,
			expected: true,
		},
		{
			name: "getter function",
			input: `fun getName(): String {
				return name
			}`,
			expected: true,
		},
		{
			name: "setter function",
			input: `fun setName(value: String) {
				this.name = value
			}`,
			expected: true,
		},
		{
			name: "regular method",
			input: `fun process() {
				doWork()
			}`,
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			node := tree.RootNode()
			var targetNode *sitter.Node
			var findNode func(*sitter.Node)
			findNode = func(n *sitter.Node) {
				if n == nil {
					return
				}

				t.Logf("Node type: %s, text: %s", n.Type(), string(tt.input[n.StartByte():n.EndByte()]))

				if n.Type() == "property_declaration" || n.Type() == "function_declaration" {
					targetNode = n
					return
				}
				for i := 0; i < int(n.NamedChildCount()); i++ {
					findNode(n.NamedChild(i))
				}
			}
			findNode(node)

			if targetNode == nil {
				t.Fatal("No property or function declaration node found")
			}

			result := handler.IsGetterSetter(targetNode, []byte(tt.input))
			if result != tt.expected {
				t.Errorf("Expected IsGetterSetter() = %v for input %q", tt.expected, tt.input)
			}
		})
	}
}
</document_content>
</document>
<document index="24">
<source>core/cleaner/handlers/sql_handler.go</source>
<document_content>package handlers

import (
    sitter "github.com/smacker/go-tree-sitter"
)

// SQLHandler handles SQL language specifics
type SQLHandler struct {
    BaseHandler
}

func (h *SQLHandler) GetCommentTypes() []string {
    return []string{"comment", "block_comment"}
}

func (h *SQLHandler) GetImportTypes() []string {
    // SQL doesn't have traditional imports, but we can consider these statements
    return []string{"create_extension_statement", "use_statement"}
}

func (h *SQLHandler) GetDocCommentPrefix() string {
    return "--"
}

func (h *SQLHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
    // SQL doesn't have traditional logging calls
    return false
}

func (h *SQLHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
    // SQL doesn't have traditional getters/setters
    return false
}</document_content>
</document>
<document index="25">
<source>core/cleaner/handlers/swift_handler.go</source>
<document_content>package handlers

import (
	"bytes"
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
)

// SwiftHandler handles Swift language specifics
type SwiftHandler struct {
	BaseHandler
}

func (h *SwiftHandler) GetCommentTypes() []string {
	return []string{"comment", "multiline_comment", "documentation_comment"}
}

func (h *SwiftHandler) GetImportTypes() []string {
	return []string{"import_declaration"}
}

func (h *SwiftHandler) GetDocCommentPrefix() string {
	return "///"
}

func (h *SwiftHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	if node.Type() != "call_expression" {
		return false
	}
	callText := content[node.StartByte():node.EndByte()]
	return bytes.HasPrefix(callText, []byte("print(")) ||
		bytes.HasPrefix(callText, []byte("debugPrint(")) ||
		bytes.HasPrefix(callText, []byte("NSLog(")) ||
		bytes.Contains(callText, []byte("logger."))
}

func (h *SwiftHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	nodeType := node.Type()

	// For variable declarations or getter/setter specifiers
	if nodeType == "variable_declaration" || nodeType == "getter_specifier" || nodeType == "setter_specifier" {
		// Look for getter and setter declarations in the node's children
		var findAccessor func(*sitter.Node) bool
		findAccessor = func(n *sitter.Node) bool {
			if n == nil {
				return false
			}

			// Check if this node is a getter or setter
			nType := n.Type()
			if nType == "getter_specifier" || nType == "setter_specifier" {
				return true
			}

			// Check children
			for i := 0; i < int(n.NamedChildCount()); i++ {
				if findAccessor(n.NamedChild(i)) {
					return true
				}
			}
			return false
		}

		return findAccessor(node)
	}

	// For function declarations, check if they look like getters/setters
	if nodeType == "function_declaration" {
		funcText := string(content[node.StartByte():node.EndByte()])
		funcName := ""

		// Find the function name
		for i := 0; i < int(node.NamedChildCount()); i++ {
			child := node.NamedChild(i)
			if child.Type() == "simple_identifier" {
				funcName = string(content[child.StartByte():child.EndByte()])
				break
			}
		}

		// Check if it's a getter/setter
		return (strings.HasPrefix(funcName, "get") && strings.Contains(funcText, "return")) ||
			(strings.HasPrefix(funcName, "set") && strings.Contains(funcText, "="))
	}

	return false
}
</document_content>
</document>
<document index="26">
<source>core/cleaner/handlers/swift_handler_test.go</source>
<document_content>package handlers

import (
	"testing"

	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/swift"
)

func TestSwiftHandlerBasics(t *testing.T) {
	handler := &SwiftHandler{}

	// Test comment types
	commentTypes := handler.GetCommentTypes()
	expected := []string{"comment", "multiline_comment", "documentation_comment"}
	if !stringSliceEqual(commentTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, commentTypes)
	}

	// Test import types
	importTypes := handler.GetImportTypes()
	expected = []string{"import_declaration"}
	if !stringSliceEqual(importTypes, expected) {
		t.Errorf("Expected %v, got %v", expected, importTypes)
	}

	// Test doc comment prefix
	if prefix := handler.GetDocCommentPrefix(); prefix != "///" {
		t.Errorf("Expected '///', got %s", prefix)
	}
}

func TestSwiftLoggingCalls(t *testing.T) {
	handler := &SwiftHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(swift.GetLanguage())

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name:     "print call",
			input:    "print(\"Debug message\")",
			expected: true,
		},
		{
			name:     "debugPrint call",
			input:    "debugPrint(\"Debug info\")",
			expected: true,
		},
		{
			name:     "NSLog call",
			input:    "NSLog(\"Log message\")",
			expected: true,
		},
		{
			name:     "logger call",
			input:    "logger.debug(\"Debug info\")",
			expected: true,
		},
		{
			name:     "regular function call",
			input:    "process(\"data\")",
			expected: false,
		},
		{
			name:     "method call",
			input:    "obj.process()",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			node := tree.RootNode()
			var callNode *sitter.Node
			var findCall func(*sitter.Node)
			findCall = func(n *sitter.Node) {
				if n.Type() == "call_expression" {
					callNode = n
					return
				}
				for i := 0; i < int(n.NamedChildCount()); i++ {
					findCall(n.NamedChild(i))
				}
			}
			findCall(node)

			if callNode == nil {
				t.Fatal("No call node found")
			}

			result := handler.IsLoggingCall(callNode, []byte(tt.input))
			if result != tt.expected {
				t.Errorf("Expected IsLoggingCall() = %v for input %q", tt.expected, tt.input)
			}
		})
	}
}

func TestSwiftGetterSetter(t *testing.T) {
	handler := &SwiftHandler{}
	parser := sitter.NewParser()
	parser.SetLanguage(swift.GetLanguage())

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name: "computed property getter",
			input: `var name: String {
				get { return _name }
			}`,
			expected: true,
		},
		{
			name: "computed property getter and setter",
			input: `var name: String {
				get { return _name }
				set { _name = newValue }
			}`,
			expected: true,
		},
		{
			name: "regular method",
			input: `func process() {
				doWork()
			}`,
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tree := parser.Parse(nil, []byte(tt.input))
			if tree == nil {
				t.Fatal("Failed to parse input")
			}
			defer tree.Close()

			node := tree.RootNode()
			var propNode *sitter.Node
			var findProp func(*sitter.Node)
			findProp = func(n *sitter.Node) {
				if n == nil {
					return
				}

				if n.Type() == "variable_declaration" || n.Type() == "function_declaration" || n.Type() == "getter_specifier" || n.Type() == "setter_specifier" {
					propNode = n
					return
				}

				// Check children first
				for i := 0; i < int(n.NamedChildCount()); i++ {
					child := n.NamedChild(i)
					findProp(child)
					if propNode != nil {
						return
					}
				}
			}
			findProp(node)

			if propNode == nil {
				t.Fatal("No property or function declaration node found")
			}

			result := handler.IsGetterSetter(propNode, []byte(tt.input))
			if result != tt.expected {
				t.Errorf("Expected IsGetterSetter() = %v for input %q", tt.expected, tt.input)
			}
		})
	}
}
</document_content>
</document>
<document index="27">
<source>core/cleaner/types.go</source>
<document_content>package cleaner

// Language represents supported programming languages
type Language string

const (
	LangGo         Language = "go"
	LangJava       Language = "java"
	LangPython     Language = "python"
	LangSwift      Language = "swift"
	LangKotlin     Language = "kotlin"
	LangSQL        Language = "sql"
	LangHTML       Language = "html"
	LangJavaScript Language = "javascript"
	LangTypeScript Language = "typescript"
	LangCSS        Language = "css"
	LangCPP        Language = "cpp"
	LangCSharp     Language = "csharp"
	LangPHP        Language = "php"
	LangRuby       Language = "ruby"
	LangBash       Language = "bash"
)

// GetSupportedLanguages returns a list of all supported languages
func GetSupportedLanguages() []Language {
	return []Language{
		LangGo, LangJava, LangPython, LangSwift, LangKotlin,
		LangSQL, LangHTML, LangJavaScript, LangTypeScript, LangCSS,
		LangCPP, LangCSharp, LangPHP, LangRuby, LangBash,
	}
}
</document_content>
</document>
<document index="28">
<source>core/cleaner/handlers/typescript_handler.go</source>
<document_content>package handlers

// TypeScriptHandler extends JavaScript handler functionality
type TypeScriptHandler struct {
	JavaScriptHandler
}

func (h *TypeScriptHandler) GetImportTypes() []string {
	baseTypes := h.JavaScriptHandler.GetImportTypes()
	return append(baseTypes, "import_require_clause", "import_alias")
}
</document_content>
</document>
<document index="29">
<source>core/finder.go</source>
<document_content>package core

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

// FileFinder is responsible for discovering files that match specified patterns
// while respecting exclusion rules. It handles complex pattern matching including
// glob patterns and directory-specific exclusions.
type FileFinder struct {
	options *MixOptions // Configuration options for file discovery
}

// NewFileFinder creates a new FileFinder instance with the specified options.
//
// Parameters:
//   - options: Configuration settings for file discovery
//
// Returns:
//   - A new FileFinder instance
func NewFileFinder(options *MixOptions) *FileFinder {
	return &FileFinder{options: options}
}

// FindFiles discovers all files in the input directory that match the configured patterns
// while respecting exclusion rules. It uses filepath.WalkDir for efficient directory traversal
// and implements sophisticated pattern matching for both inclusion and exclusion.
//
// The function handles:
// - Multiple inclusion patterns (comma-separated)
// - Multiple exclusion patterns (comma-separated)
// - Special patterns like "**" for recursive matching
// - .git directory exclusion
//
// Returns:
//   - []string: Slice of matched file paths
//   - error: Error if any occurs during file discovery
func (f *FileFinder) FindFiles() ([]string, error) {
	var matches []string

	err := filepath.WalkDir(f.options.InputPath, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return fmt.Errorf("error accessing path %s: %w", path, err)
		}

		info, err := os.Stat(path)
		if err != nil {
			return fmt.Errorf("error getting file info for %s: %w", path, err)
		}

		if info.IsDir() {
			// Skip .git directory entirely
			if d.Name() == ".git" {
				return filepath.SkipDir
			}
			return nil
		}

		// Get path relative to input directory for pattern matching
		relPath, err := filepath.Rel(f.options.InputPath, path)
		if err != nil {
			relPath = path // Fallback to full path if relative path fails
		}

		// Check if file matches patterns
		match, err := f.matchesPattern(relPath, filepath.Base(path))
		if err != nil {
			return err
		}

		if match {
			matches = append(matches, path)
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	if len(matches) == 0 {
		return nil, fmt.Errorf("no files found matching pattern(s) %q (excluding %q) in %s",
			f.options.Pattern, f.options.Exclude, f.options.InputPath)
	}

	return matches, nil
}

// matchesPattern checks if a file matches the inclusion patterns while not matching
// any exclusion patterns. It implements sophisticated pattern matching including:
// - Glob pattern support
// - Directory-specific exclusions using "**"
// - Both filename and full path matching
//
// Parameters:
//   - path: Full relative path to the file
//   - filename: Base name of the file
//
// Returns:
//   - bool: true if the file should be included, false otherwise
//   - error: Error if pattern matching fails
func (f *FileFinder) matchesPattern(path, filename string) (bool, error) {
    // Pattern syntax is already validated at this point
    if f.options.Exclude != "" {
        excludePatterns := strings.Split(f.options.Exclude, ",")
        for _, pattern := range excludePatterns {
            pattern = strings.TrimSpace(pattern)
            if pattern == "" {
                continue
            }
            
            pattern = filepath.FromSlash(pattern)
            pathToCheck := filepath.FromSlash(path)
            
            if strings.Contains(pattern, "**") {
                basePattern := strings.TrimSuffix(pattern, string(filepath.Separator)+"**")
                basePattern = strings.TrimSuffix(basePattern, "**")
                if strings.HasPrefix(pathToCheck, basePattern) {
                    return false, nil
                }
            } else if strings.Contains(pattern, string(filepath.Separator)) {
                matched, _ := filepath.Match(pattern, pathToCheck)
                if matched {
                    return false, nil
                }
            } else {
                matched, _ := filepath.Match(pattern, filename)
                if matched {
                    return false, nil
                }
            }
        }
    }

    patterns := strings.Split(f.options.Pattern, ",")
    for _, pattern := range patterns {
        pattern = strings.TrimSpace(pattern)
        if pattern == "" {
            continue
        }
        
        matched, _ := filepath.Match(pattern, filename)
        if matched {
            return true, nil
        }
    }
    
    return false, nil
}</document_content>
</document>
<document index="30">
<source>core/finder_test.go</source>
<document_content>package core

import (
	"os"
	"path/filepath"
	"testing"
)

func TestFileFinder(t *testing.T) {
	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test files
	files := map[string]string{
		"test1.go":           "package main\n",
		"test2.go":           "package main\n",
		"data.json":          `{"key": "value"}`,
		"config.yaml":        "name: test",
		"subfolder/test.go":  "package sub\n",
		"subfolder/data.txt": "ignored file",
		".hidden/test.go":    "package hidden",
	}

	for path, content := range files {
		fullPath := filepath.Join(tmpDir, path)
		err := os.MkdirAll(filepath.Dir(fullPath), 0755)
		if err != nil {
			t.Fatalf("Failed to create directory: %v", err)
		}
		err = os.WriteFile(fullPath, []byte(content), 0644)
		if err != nil {
			t.Fatalf("Failed to create test file: %v", err)
		}
	}

	tests := []struct {
		name          string
		pattern       string
		exclude       string
		expectedCount int
		shouldError   bool
	}{
		{
			name:          "find all go files",
			pattern:       "*.go",
			expectedCount: 4,
		},
		{
			name:          "find json and yaml",
			pattern:       "*.json,*.yaml",
			expectedCount: 2,
		},
		{
			name:          "exclude subfolder",
			pattern:       "*.go",
			exclude:       "subfolder/**,.hidden/**",
			expectedCount: 2,
		},
		{
			name:        "no matches",
			pattern:     "*.cpp",
			shouldError: true,
		},
		{
			name:        "invalid pattern",
			pattern:     "[",
			shouldError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			finder := NewFileFinder(&MixOptions{
				InputPath: tmpDir,
				Pattern:   tt.pattern,
				Exclude:   tt.exclude,
			})

			files, err := finder.FindFiles()

			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			if len(files) != tt.expectedCount {
				t.Errorf("Expected %d files, got %d", tt.expectedCount, len(files))
			}
		})
	}
}

func TestInvalidPatternHandling(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "filefusion-pattern-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	invalidPatterns := []struct {
		pattern string
		exclude string
	}{
		{pattern: "["},
		{pattern: "*.go", exclude: "["},
		{pattern: "***/invalid"},
		{pattern: "", exclude: "[]"},
	}

	for _, p := range invalidPatterns {
		finder := NewFileFinder(&MixOptions{
			InputPath: tmpDir,
			Pattern:   p.pattern,
			Exclude:   p.exclude,
		})

		_, err := finder.FindFiles()
		if err == nil {
			t.Errorf("Expected error for invalid pattern %q (exclude: %q), got none",
				p.pattern, p.exclude)
		}
	}
}

// TestProcessorConcurrencyAndErrorHandling tests the concurrent processing
// behavior and error handling of the FileProcessor
func TestProcessorConcurrencyAndErrorHandling(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "filefusion-concurrent-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create multiple test files with varying permissions
	files := []struct {
		name        string
		content     string
		permissions os.FileMode
		shouldError bool
	}{
		{"readable.txt", "test content", 0644, false},
		{"unreadable.txt", "test content", 0000, true},
		{"executable.txt", "test content", 0755, false},
	}

	var filePaths []string
	for _, f := range files {
		path := filepath.Join(tmpDir, f.name)
		if err := os.WriteFile(path, []byte(f.content), f.permissions); err != nil {
			t.Fatalf("Failed to create test file %s: %v", f.name, err)
		}
		filePaths = append(filePaths, path)
	}

	processor := NewFileProcessor(&MixOptions{
		InputPath:   tmpDir,
		MaxFileSize: 1024,
	})

	// Test concurrent processing
	contents, err := processor.ProcessFiles(filePaths)
	if err == nil {
		t.Error("Expected error due to unreadable file, got none")
	}

	// Verify that readable files were still processed
	expectedReadable := 2 // readable.txt and executable.txt
	if len(contents) != expectedReadable {
		t.Errorf("Expected %d readable files, got %d", expectedReadable, len(contents))
	}
}

// TestOutputGeneratorSymlinkHandling tests how the OutputGenerator handles
// symlinks in the output path
func TestOutputGeneratorSymlinkHandling(t *testing.T) {
	if os.Getenv("SKIP_SYMLINK_TESTS") != "" {
		t.Skip("Skipping symlink tests")
	}

	tmpDir, err := os.MkdirTemp("", "filefusion-symlink-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create a subdirectory for output
	outputDir := filepath.Join(tmpDir, "output")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		t.Fatalf("Failed to create output directory: %v", err)
	}

	// Create a symlink to the output directory
	symlinkPath := filepath.Join(tmpDir, "symlink")
	if err := os.Symlink(outputDir, symlinkPath); err != nil {
		t.Fatalf("Failed to create symlink: %v", err)
	}

	// Create test content
	contents := []FileContent{
		{
			Path:    "test.go",
			Content: "package main\n",
			Size:    12,
		},
	}

	// Test writing through symlink
	outputPath := filepath.Join(symlinkPath, "output.xml")
	generator := NewOutputGenerator(&MixOptions{
		OutputPath:    outputPath,
		MaxOutputSize: 1024,
		OutputType:    OutputTypeXML,
	})

	if err := generator.Generate(contents); err != nil {
		t.Fatalf("Failed to generate output through symlink: %v", err)
	}

	// Verify file exists in actual directory
	realPath := filepath.Join(outputDir, "output.xml")
	if _, err := os.Stat(realPath); os.IsNotExist(err) {
		t.Error("Output file not created in real directory")
	}
}

// TestEdgeCasePaths tests handling of unusual file paths
func TestEdgeCasePaths(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "filefusion-paths-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	edgeCases := []struct {
		path    string
		content string
	}{
		{"file with spaces.go", "content"},
		{"file#with#hashes.go", "content"},
		{"file_with_.go", "content"},
		{"../outside/attempt.go", "content"},
		{"./inside/./path.go", "content"},
	}

	for _, ec := range edgeCases {
		path := filepath.Join(tmpDir, ec.path)
		if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
			continue // Skip if directory creation fails (e.g., for ../outside)
		}
		if err := os.WriteFile(path, []byte(ec.content), 0644); err != nil {
			continue // Skip if file creation fails
		}
	}

	processor := NewFileProcessor(&MixOptions{
		InputPath:   tmpDir,
		MaxFileSize: 1024,
	})

	paths := []string{
		filepath.Join(tmpDir, "file with spaces.go"),
		filepath.Join(tmpDir, "file#with#hashes.go"),
		filepath.Join(tmpDir, "file_with_.go"),
	}

	contents, err := processor.ProcessFiles(paths)
	if err != nil {
		t.Fatalf("Failed to process edge case paths: %v", err)
	}

	if len(contents) != 3 {
		t.Errorf("Expected 3 processed files, got %d", len(contents))
	}
}
</document_content>
</document>
<document index="31">
<source>core/cleaner/handlers/java_handler.go</source>
<document_content>package handlers

import (
	"bytes"
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
)

// JavaHandler handles Java language specifics
type JavaHandler struct {
	BaseHandler
}

func (h *JavaHandler) GetCommentTypes() []string {
	return []string{"line_comment", "block_comment", "javadoc_comment"}
}

func (h *JavaHandler) GetImportTypes() []string {
	return []string{"import_declaration"}
}

func (h *JavaHandler) GetDocCommentPrefix() string {
	return "/**"
}

func (h *JavaHandler) IsLoggingCall(node *sitter.Node, content []byte) bool {
	// For Java, we need to check both method invocations and the qualifier
	nodeType := node.Type()
	if nodeType != "method_invocation" {
		return false
	}

	// Get the method identifier
	callText := content[node.StartByte():node.EndByte()]

	// Check if it's a logging call
	loggingPatterns := []string{
		"Logger",
		"System.out",
		"System.err",
		"log.",
		"logger.",
	}

	for _, pattern := range loggingPatterns {
		if bytes.Contains(callText, []byte(pattern)) {
			return true
		}
	}

	return false
}

func (h *JavaHandler) IsGetterSetter(node *sitter.Node, content []byte) bool {
	if node.Type() != "method_declaration" {
		return false
	}

	methodText := string(content[node.StartByte():node.EndByte()])

	// Get the method name
	nameNode := node.ChildByFieldName("name")
	if nameNode == nil {
		return false
	}
	name := string(content[nameNode.StartByte():nameNode.EndByte()])
	nameLower := strings.ToLower(name)

	// Check for getter pattern (including boolean getters with 'is' prefix)
	isGetter := (strings.HasPrefix(nameLower, "get") || strings.HasPrefix(nameLower, "is")) &&
		strings.Contains(methodText, "return")

	// Check for setter pattern
	isSetter := strings.HasPrefix(nameLower, "set") &&
		strings.Contains(methodText, "void")

	return isGetter || isSetter
}
</document_content>
</document>
<document index="32">
<source>core/mixer.go</source>
<document_content>package core

import (
	"fmt"
	"path/filepath"
)

// Mixer orchestrates the complete file processing pipeline, coordinating between
// file finding, processing, and output generation components. It implements the main
// business logic for combining multiple files into a single output document.
type Mixer struct {

	// options contains the configuration settings for the mixing process
	options *MixOptions

	// finder handles file discovery based on patterns and exclusions
	finder *FileFinder

	// processor handles reading and processing of individual files
	processor *FileProcessor

	// generator manages output file creation in various formats
	generator *OutputGenerator
}

// NewMixer creates a new Mixer instance with the provided options.
// It initializes all necessary components (finder, processor, and generator)
// but does not validate the options until Mix is called.
//
// Parameters:
//   - options: Configuration settings for the mixing process
//
// Returns:
//   - A new Mixer instance ready for use
func NewMixer(options *MixOptions) *Mixer {
	m := &Mixer{
		options:   options,
		finder:    NewFileFinder(options),
		processor: NewFileProcessor(options),
		generator: NewOutputGenerator(options),
	}
	return m
}

// Mix performs the complete file mixing process in three main steps:
// 1. Finds all files matching the configured patterns
// 2. Processes each file to extract its content
// 3. Generates the final output file in the specified format
//
// The function handles path resolution, including symlinks, and ensures
// all operations are performed safely and in the correct order.
//
// Returns:
//   - error: nil if successful, otherwise an error describing what went wrong
func (m *Mixer) Mix() error {

	// Resolve any symlinks in the input path for consistent handling
	resolvedPath, err := filepath.EvalSymlinks(m.options.InputPath)
	if err != nil {
		return fmt.Errorf("error resolving input path: %w", err)
	}
	m.options.InputPath = resolvedPath

	// Find all files matching the configured patterns
	files, err := m.finder.FindFiles()
	if err != nil {
		return fmt.Errorf("error finding files: %w", err)
	}

	// Process discovered files to extract their content
	processor := NewFileProcessor(m.options)
	contents, err := processor.ProcessFiles(files)
	if err != nil {
		return fmt.Errorf("error processing files: %w", err)
	}

	// Generate the final output file
	if err := m.generator.Generate(contents); err != nil {
		return fmt.Errorf("error generating output: %w", err)
	}

	return nil
}

// GetFoundFiles returns the list of files that were found and processed.
// This method is primarily used for testing and verification purposes,
// allowing inspection of which files were discovered without generating output.
//
// Returns:
//   - []FileContent: Slice of processed file contents
//   - error: nil if successful, otherwise an error describing what went wrong
func (m *Mixer) GetFoundFiles() ([]FileContent, error) {
	files, err := m.finder.FindFiles()
	if err != nil {
		return nil, err
	}
	return m.processor.ProcessFiles(files)
}

// ValidateOptions performs comprehensive validation of the mixer configuration.
// It checks all required fields are set and have valid values before any
// processing begins.
//
// The validation includes checking:
// - Input and output paths are specified
// - File pattern is not empty
// - Size limits are positive values
// - Output format is supported
//
// Returns:
//   - error: nil if validation passes, otherwise a MixError describing the issue
func (m *Mixer) ValidateOptions() error {
	if m.options.InputPath == "" {
		return &MixError{Message: "input path is required"}
	}

	if m.options.OutputPath == "" {
		return &MixError{Message: "output path is required"}
	}

	if m.options.Pattern == "" {
		return &MixError{Message: "pattern cannot be empty"}
	}

	if m.options.MaxFileSize <= 0 {
		return &MixError{Message: "max file size must be greater than 0"}
	}

	if m.options.MaxOutputSize <= 0 {
		return &MixError{Message: "max output size must be greater than 0"}
	}

	switch m.options.OutputType {
	case OutputTypeXML, OutputTypeJSON, OutputTypeYAML:
		// Valid output types
	default:
		return &MixError{Message: fmt.Sprintf("unsupported output type: %s", m.options.OutputType)}
	}

	return nil
}
</document_content>
</document>
<document index="33">
<source>core/output.go</source>
<document_content>package core

import (
	"encoding/json"
	"fmt"
	"os"
	"text/template"

	"gopkg.in/yaml.v3"
)

// OutputGenerator handles the creation of output files in various formats (XML, JSON, YAML).
// It implements safety measures such as:
// - Using temporary files for atomic writes
// - Size limit validation
// - Proper error handling and cleanup
type OutputGenerator struct {
	options *MixOptions // Configuration options for output generation
}

// NewOutputGenerator creates a new OutputGenerator instance with the specified options.
//
// Parameters:
//   - options: Configuration settings for output generation
//
// Returns:
//   - A new OutputGenerator instance
func NewOutputGenerator(options *MixOptions) *OutputGenerator {
	return &OutputGenerator{options: options}
}

// Generate creates an output file containing the provided file contents in the specified format.
// The function implements a safe generation process:
// 1. Creates a temporary file
// 2. Writes content in the specified format
// 3. Validates size constraints
// 4. Atomically moves the file to its final location
//
// Parameters:
//   - contents: Slice of FileContent to include in the output
//
// Returns:
//   - error: nil if successful, otherwise describes what went wrong
func (g *OutputGenerator) Generate(contents []FileContent) error {
	// Create a temporary file for safe writing
	tempFile, err := os.CreateTemp("", "filefusion-*")
	if err != nil {
		return &MixError{
			File:    g.options.OutputPath,
			Message: fmt.Sprintf("error creating temporary file: %v", err),
		}
	}
	tempPath := tempFile.Name()
	defer os.Remove(tempPath) // Clean up temp file in case of failure

	// Generate content in the specified format
	switch g.options.OutputType {
	case OutputTypeJSON:
		err = g.generateJSON(tempFile, contents)
	case OutputTypeYAML:
		err = g.generateYAML(tempFile, contents)
	case OutputTypeXML:
		err = g.generateXML(tempFile, contents)
	default:
		return &MixError{Message: fmt.Sprintf("unsupported output type: %s", g.options.OutputType)}
	}

	if err != nil {
		return err
	}

	// Close the temp file to ensure all content is written
	tempFile.Close()

	// Check the size of the generated file
	info, err := os.Stat(tempPath)
	if err != nil {
		return &MixError{Message: fmt.Sprintf("error checking output file size: %v", err)}
	}

	if info.Size() > g.options.MaxOutputSize {
		return &MixError{
			Message: fmt.Sprintf("output size (%d bytes) exceeds maximum allowed size (%d bytes)",
				info.Size(), g.options.MaxOutputSize),
		}
	}

	// Move temp file to final destination
	return os.Rename(tempPath, g.options.OutputPath)
}

// generateJSON creates a JSON output file with the provided file contents.
// It wraps the contents in a "documents" array and writes it to the specified file.
//
// Parameters:
//   - file: The file to write the JSON output to
//   - contents: Slice of FileContent to include in the output
//
// Returns:
//   - error: nil if successful, otherwise describes what went wrong
func (g *OutputGenerator) generateJSON(file *os.File, contents []FileContent) error {
	// Create wrapper structure for consistent output format
	output := struct {
		Documents []struct {
			Index           int    `json:"index"`
			Source          string `json:"source"`
			DocumentContent string `json:"document_content"`
		} `json:"documents"`
	}{
		Documents: make([]struct {
			Index           int    `json:"index"`
			Source          string `json:"source"`
			DocumentContent string `json:"document_content"`
		}, len(contents)),
	}

	// Fill the structure
	for i, content := range contents {
		output.Documents[i] = struct {
			Index           int    `json:"index"`
			Source          string `json:"source"`
			DocumentContent string `json:"document_content"`
		}{
			Index:           i + 1,
			Source:          content.Path,
			DocumentContent: content.Content,
		}
	}

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(output); err != nil {
		return &MixError{Message: fmt.Sprintf("error encoding JSON: %v", err)}
	}
	return nil
}

// generateYAML writes the content in YAML format with proper indentation.
// The output maintains the same structure as JSON for consistency.
//
// Parameters:
//   - file: Open file to write to
//   - output: Interface containing the data to encode
//
// Returns:
//   - error: nil if successful, error if encoding fails
func (g *OutputGenerator) generateYAML(file *os.File, output interface{}) error {
	// Use same structure as JSON for consistency
	docs := struct {
		Documents []struct {
			Index           int    `yaml:"index"`
			Source          string `yaml:"source"`
			DocumentContent string `yaml:"document_content"`
		} `yaml:"documents"`
	}{}

	// Convert the input to []FileContent
	contents, ok := output.([]FileContent)
	if !ok {
		return &MixError{Message: "invalid input type for YAML generation"}
	}

	// Fill the structure
	docs.Documents = make([]struct {
		Index           int    `yaml:"index"`
		Source          string `yaml:"source"`
		DocumentContent string `yaml:"document_content"`
	}, len(contents))

	for i, content := range contents {
		docs.Documents[i] = struct {
			Index           int    `yaml:"index"`
			Source          string `yaml:"source"`
			DocumentContent string `yaml:"document_content"`
		}{
			Index:           i + 1,
			Source:          content.Path,
			DocumentContent: content.Content,
		}
	}

	encoder := yaml.NewEncoder(file)
	encoder.SetIndent(2)
	if err := encoder.Encode(docs); err != nil {
		return &MixError{Message: fmt.Sprintf("error encoding YAML: %v", err)}
	}
	return nil
}

// generateXML writes the content in XML format using a template.
// The output includes proper XML declaration and document structure.
//
// Parameters:
//   - file: Open file to write to
//   - contents: Slice of FileContent to encode
//
// Returns:
//   - error: nil if successful, error if template execution fails
func (g *OutputGenerator) generateXML(file *os.File, contents []FileContent) error {
	const xmlTemplate = `<?xml version="1.0" encoding="UTF-8"?>
<documents>{{range $index, $file := .}}
<document index="{{add $index 1}}">
<source>{{.Path}}</source>
<document_content>{{.Content}}</document_content>
</document>{{end}}
</documents>`

	t, err := template.New("llm").Funcs(template.FuncMap{
		"add": func(a, b int) int { return a + b },
	}).Parse(xmlTemplate)
	if err != nil {
		return &MixError{Message: fmt.Sprintf("error parsing template: %v", err)}
	}

	if err := t.Execute(file, contents); err != nil {
		return &MixError{Message: fmt.Sprintf("error executing template: %v", err)}
	}
	return nil
}
</document_content>
</document>
<document index="34">
<source>core/mixer_test.go</source>
<document_content>package core

import (
	"os"
	"path/filepath"
	"runtime"
	"testing"
)

func TestMixer(t *testing.T) {
	// Skip symlink tests on Windows
	if runtime.GOOS == "windows" {
		t.Skip("Skipping symlink tests on Windows")
	}

	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-mixer-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test file structure
	files := map[string]string{
		"test1.go":           "package main\nfunc main() {}\n",
		"test2.go":           "package test\nfunc helper() {}\n",
		"data.json":          `{"key": "value"}`,
		"config.yaml":        "name: test",
		"subfolder/test.go":  "package sub\n",
		"subfolder/data.txt": "ignored file",
	}

	// Create the files
	for path, content := range files {
		fullPath := filepath.Join(tmpDir, path)
		err := os.MkdirAll(filepath.Dir(fullPath), 0755)
		if err != nil {
			t.Fatalf("Failed to create directory: %v", err)
		}
		err = os.WriteFile(fullPath, []byte(content), 0644)
		if err != nil {
			t.Fatalf("Failed to create test file: %v", err)
		}
	}

	// Create a symlink for testing symlink handling
	symDir := filepath.Join(tmpDir, "symlink")
	realDir := filepath.Join(tmpDir, "subfolder")
	if err := os.Symlink(realDir, symDir); err != nil {
		t.Fatalf("Failed to create symlink: %v", err)
	}

	tests := []struct {
		name          string
		options       *MixOptions
		expectedFiles int
		shouldError   bool
	}{
		{
			name: "process go files",
			options: &MixOptions{
				InputPath:     tmpDir,
				OutputPath:    filepath.Join(tmpDir, "output.xml"),
				Pattern:       "*.go",
				MaxFileSize:   1024 * 1024,
				MaxOutputSize: 10 * 1024 * 1024,
				OutputType:    OutputTypeXML,
			},
			expectedFiles: 3,
			shouldError:   false,
		},
		{
			name: "process through symlink",
			options: &MixOptions{
				InputPath:     symDir,
				OutputPath:    filepath.Join(tmpDir, "symlink-output.xml"),
				Pattern:       "*.go",
				MaxFileSize:   1024 * 1024,
				MaxOutputSize: 10 * 1024 * 1024,
				OutputType:    OutputTypeXML,
			},
			expectedFiles: 1,
			shouldError:   false,
		},
		{
			name: "invalid output type",
			options: &MixOptions{
				InputPath:     tmpDir,
				OutputPath:    filepath.Join(tmpDir, "output.xml"),
				Pattern:       "*.go",
				MaxFileSize:   1024 * 1024,
				MaxOutputSize: 10 * 1024 * 1024,
				OutputType:    "invalid",
			},
			shouldError: true,
		},
		{
			name: "empty pattern",
			options: &MixOptions{
				InputPath:     tmpDir,
				OutputPath:    filepath.Join(tmpDir, "output.xml"),
				Pattern:       "",
				MaxFileSize:   1024 * 1024,
				MaxOutputSize: 10 * 1024 * 1024,
				OutputType:    OutputTypeXML,
			},
			shouldError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mixer := NewMixer(tt.options)

			// First validate options
			err := mixer.ValidateOptions()
			if tt.shouldError {
				if err == nil {
					t.Error("Expected validation error but got none")
				}
				return
			}
			if err != nil {
				t.Fatalf("Unexpected validation error: %v", err)
			}

			// Then test the mixing process
			err = mixer.Mix()
			if err != nil {
				t.Fatalf("Mix failed: %v", err)
			}

			// Verify output file exists
			if _, err := os.Stat(tt.options.OutputPath); os.IsNotExist(err) {
				t.Error("Output file was not created")
			}

			// Verify found files count
			foundFiles, err := mixer.GetFoundFiles()
			if err != nil {
				t.Fatalf("GetFoundFiles failed: %v", err)
			}

			if len(foundFiles) != tt.expectedFiles {
				t.Errorf("Expected %d files, got %d", tt.expectedFiles, len(foundFiles))
			}
		})
	}
}

func TestMixerValidation(t *testing.T) {
	tests := []struct {
		name       string
		options    *MixOptions
		errMessage string
	}{
		{
			name: "empty input path",
			options: &MixOptions{
				OutputPath:    "output.xml",
				Pattern:       "*.go",
				MaxFileSize:   1024,
				MaxOutputSize: 1024,
				OutputType:    OutputTypeXML,
			},
			errMessage: "input path is required",
		},
		{
			name: "empty output path",
			options: &MixOptions{
				InputPath:     "input",
				Pattern:       "*.go",
				MaxFileSize:   1024,
				MaxOutputSize: 1024,
				OutputType:    OutputTypeXML,
			},
			errMessage: "output path is required",
		},
		{
			name: "empty pattern",
			options: &MixOptions{
				InputPath:     "input",
				OutputPath:    "output.xml",
				MaxFileSize:   1024,
				MaxOutputSize: 1024,
				OutputType:    OutputTypeXML,
			},
			errMessage: "pattern cannot be empty",
		},
		{
			name: "invalid max file size",
			options: &MixOptions{
				InputPath:     "input",
				OutputPath:    "output.xml",
				Pattern:       "*.go",
				MaxFileSize:   0,
				MaxOutputSize: 1024,
				OutputType:    OutputTypeXML,
			},
			errMessage: "max file size must be greater than 0",
		},
		{
			name: "invalid max output size",
			options: &MixOptions{
				InputPath:     "input",
				OutputPath:    "output.xml",
				Pattern:       "*.go",
				MaxFileSize:   1024,
				MaxOutputSize: 0,
				OutputType:    OutputTypeXML,
			},
			errMessage: "max output size must be greater than 0",
		},
		{
			name: "invalid output type",
			options: &MixOptions{
				InputPath:     "input",
				OutputPath:    "output.xml",
				Pattern:       "*.go",
				MaxFileSize:   1024,
				MaxOutputSize: 1024,
				OutputType:    "invalid",
			},
			errMessage: "unsupported output type: invalid",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mixer := NewMixer(tt.options)
			err := mixer.ValidateOptions()

			if err == nil {
				t.Fatal("Expected error but got none")
			}

			if err.Error() != tt.errMessage {
				t.Errorf("Expected error message %q, got %q", tt.errMessage, err.Error())
			}
		})
	}
}

func TestMixError(t *testing.T) {
	tests := []struct {
		name     string
		err      *MixError
		expected string
	}{
		{
			name: "with file and message",
			err: &MixError{
				File:    "test.go",
				Message: "failed to read",
			},
			expected: "file test.go: failed to read",
		},
		{
			name: "with message only",
			err: &MixError{
				Message: "general error",
			},
			expected: "general error",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.err.Error(); got != tt.expected {
				t.Errorf("MixError.Error() = %v, want %v", got, tt.expected)
			}
		})
	}
}
</document_content>
</document>
<document index="35">
<source>core/cleaner/utility_test.go</source>
<document_content>package cleaner

import (
	"testing"
)

func TestDefaultOptions(t *testing.T) {
	options := DefaultOptions()

	if options == nil {
		t.Error("DefaultOptions() returned nil")
	}

	// Test default values
	if !options.RemoveComments {
		t.Error("RemoveComments should be true by default")
	}
	if !options.PreserveDocComments {
		t.Error("PreserveDocComments should be true by default")
	}
	if options.RemoveImports {
		t.Error("RemoveImports should be false by default")
	}
	if !options.RemoveLogging {
		t.Error("RemoveLogging should be true by default")
	}
	if !options.RemoveGettersSetters {
		t.Error("RemoveGettersSetters should be true by default")
	}
	if !options.OptimizeWhitespace {
		t.Error("OptimizeWhitespace should be true by default")
	}
	if !options.RemoveEmptyLines {
		t.Error("RemoveEmptyLines should be true by default")
	}

	// Test logging prefixes
	if options.LoggingPrefixes == nil {
		t.Error("LoggingPrefixes should not be nil")
	}

	expectedLanguages := []Language{
		LangGo, LangJava, LangPython, LangJavaScript,
		LangPHP, LangRuby, LangCSharp, LangSwift,
		LangKotlin,
	}

	for _, lang := range expectedLanguages {
		if prefixes, exists := options.LoggingPrefixes[lang]; !exists {
			t.Errorf("Missing logging prefixes for language: %s", lang)
		} else if len(prefixes) == 0 {
			t.Errorf("Empty logging prefixes for language: %s", lang)
		}
	}
}

func TestGetSupportedLanguages(t *testing.T) {
	langs := GetSupportedLanguages()

	if len(langs) == 0 {
		t.Error("GetSupportedLanguages() returned empty list")
	}

	// Check for required languages
	required := map[Language]bool{
		LangGo:         false,
		LangJava:       false,
		LangPython:     false,
		LangJavaScript: false,
		LangTypeScript: false,
		LangPHP:        false,
		LangRuby:       false,
		LangCSharp:     false,
	}

	for _, lang := range langs {
		if _, ok := required[lang]; ok {
			required[lang] = true
		}
	}

	for lang, found := range required {
		if !found {
			t.Errorf("Required language %s not found in supported languages", lang)
		}
	}
}

func TestNewCleanerValidation(t *testing.T) {
	tests := []struct {
		name        string
		lang        Language
		options     *CleanerOptions
		shouldError bool
	}{
		{
			name:        "nil options",
			lang:        LangGo,
			options:     nil,
			shouldError: true,
		},
		{
			name:        "invalid language",
			lang:        "invalid",
			options:     DefaultOptions(),
			shouldError: true,
		},
		{
			name:        "valid configuration",
			lang:        LangGo,
			options:     DefaultOptions(),
			shouldError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := NewCleaner(tt.lang, tt.options)
			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
				}
			} else {
				if err != nil {
					t.Errorf("Unexpected error: %v", err)
				}
			}
		})
	}
}
</document_content>
</document>
<document index="36">
<source>core/processor.go</source>
<document_content>package core

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/drgsn/filefusion/internal/core/cleaner"
)

// FileResult represents the outcome of processing a single file.
// It can contain either the processed content or an error, but not both.
type FileResult struct {
	Content FileContent // Processed file content and metadata
	Error   error       // Error that occurred during processing, if any
}

// FileProcessor handles the concurrent processing of multiple files,
// including content cleaning when enabled. It manages a pool of cleaners
// for different languages and ensures proper resource cleanup.
type FileProcessor struct {
	options  *MixOptions
	cleaners map[cleaner.Language]*cleaner.Cleaner
	mu       sync.RWMutex
}

// NewFileProcessor creates a new FileProcessor instance with the specified options.
// It initializes the cleaner map if cleaning is enabled but defers actual cleaner
// creation until needed.
func NewFileProcessor(options *MixOptions) *FileProcessor {
	return &FileProcessor{
		options:  options,
		cleaners: make(map[cleaner.Language]*cleaner.Cleaner),
	}
}

// ProcessFiles processes multiple files concurrently using a worker pool pattern.
// It respects file size limits and handles errors gracefully, continuing to process
// files even if some fail.
//
// Parameters:
//   - paths: Slice of file paths to process
//
// Returns:
//   - []FileContent: Slice of successfully processed file contents
//   - error: First error encountered during processing, if any
func (p *FileProcessor) ProcessFiles(paths []string) ([]FileContent, error) {
	// Use reasonable number of workers
	numWorkers := min(len(paths), 10)
	results := make(chan FileResult, len(paths))
	var wg sync.WaitGroup

	// Create a channel for distributing work
	jobs := make(chan string, len(paths))
	for _, path := range paths {
		jobs <- path
	}
	close(jobs)

	// Start worker pool
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for path := range jobs {
				result := p.processFile(path)
				results <- result
			}
		}()
	}

	// Wait for all workers to finish and close results channel
	go func() {
		wg.Wait()
		close(results)
	}()

	// Collect results and handle errors
	var contents []FileContent
	var errors []error

	for result := range results {
		if result.Error != nil {
			errors = append(errors, result.Error)
			continue
		}
		if result.Content.Size > 0 {
			contents = append(contents, result.Content)
		}
	}

	// Return the first error encountered, but still return processed files
	var firstError error
	if len(errors) > 0 {
		firstError = errors[0]
	}

	return contents, firstError
}

// processFile handles the processing of a single file, including reading,
// cleaning (if enabled), and metadata collection.
func (p *FileProcessor) processFile(path string) FileResult {
	// Get file info and perform initial checks
	info, err := os.Stat(path)
	if err != nil {
		return FileResult{
			Error: &MixError{
				File:    path,
				Message: fmt.Sprintf("error getting file info: %v", err),
			},
		}
	}

	if info.IsDir() {
		return FileResult{
			Error: &MixError{
				File:    path,
				Message: "is a directory",
			},
		}
	}

	// Check size limit
	if info.Size() > p.options.MaxFileSize {
		fmt.Fprintf(os.Stderr, "Warning: Skipping %s (size %d bytes exceeds limit %d bytes)\n",
			path, info.Size(), p.options.MaxFileSize)
		return FileResult{}
	}

	// Read file content
	content, err := os.ReadFile(path)
	if err != nil {
		return FileResult{
			Error: &MixError{
				File:    path,
				Message: fmt.Sprintf("error reading file: %v", err),
			},
		}
	}

	// Clean content if enabled and language is supported
	if p.options.CleanerOptions != nil {
		if cleaned, err := p.cleanContent(path, content); err == nil {
			content = cleaned
		} else {
			fmt.Fprintf(os.Stderr, "Warning: Failed to clean %s: %v\n", path, err)
		}
	}

	// Create relative path
	relPath, err := p.createRelativePath(path)
	if err != nil {
		relPath = path
	}

	// Return successful result
	return FileResult{
		Content: FileContent{
			Path:      filepath.ToSlash(relPath),
			Name:      filepath.Base(path),
			Extension: strings.TrimPrefix(filepath.Ext(path), "."),
			Content:   string(content),
			Size:      int64(len(content)),
		},
	}
}

// cleanContent attempts to clean the content using the appropriate language cleaner
func (p *FileProcessor) cleanContent(path string, content []byte) ([]byte, error) {
	lang := p.detectLanguage(path)
	if lang == "" {
		return content, nil
	}

	c, err := p.getOrCreateCleaner(lang)
	if err != nil {
		return nil, err
	}

	return c.Clean(content)
}

// getOrCreateCleaner safely gets or creates a cleaner for the given language
func (p *FileProcessor) getOrCreateCleaner(lang cleaner.Language) (*cleaner.Cleaner, error) {
	// Try to get existing cleaner
	p.mu.RLock()
	c, exists := p.cleaners[lang]
	p.mu.RUnlock()

	if exists {
		return c, nil
	}

	// Create new cleaner if needed
	p.mu.Lock()
	defer p.mu.Unlock()

	// Check again in case another goroutine created it
	if c, exists = p.cleaners[lang]; exists {
		return c, nil
	}

	// Create new cleaner
	c, err := cleaner.NewCleaner(lang, p.options.CleanerOptions)
	if err != nil {
		return nil, err
	}

	p.cleaners[lang] = c
	return c, nil
}

// createRelativePath creates a path relative to the input directory
func (p *FileProcessor) createRelativePath(path string) (string, error) {
	baseDir := filepath.Clean(p.options.InputPath)
	cleanPath := filepath.Clean(path)

	// Convert both paths to slashes for consistent handling
	baseDir = filepath.ToSlash(baseDir)
	cleanPath = filepath.ToSlash(cleanPath)

	relPath := cleanPath
	if strings.HasPrefix(cleanPath, baseDir) {
		relPath = cleanPath[len(baseDir):]
		// Remove leading slash if present
		relPath = strings.TrimPrefix(relPath, "/")
	}

	return relPath, nil
}

// detectLanguage determines the language based on file extension
func (p *FileProcessor) detectLanguage(path string) cleaner.Language {
	ext := strings.ToLower(filepath.Ext(path))
	switch ext {
	case ".go":
		return cleaner.LangGo
	case ".java":
		return cleaner.LangJava
	case ".py":
		return cleaner.LangPython
	case ".js":
		return cleaner.LangJavaScript
	case ".ts":
		return cleaner.LangTypeScript
	case ".html":
		return cleaner.LangHTML
	case ".css":
		return cleaner.LangCSS
	case ".cpp", ".cc", ".h":
		return cleaner.LangCPP
	case ".cs":
		return cleaner.LangCSharp
	case ".php":
		return cleaner.LangPHP
	case ".rb":
		return cleaner.LangRuby
	case ".sh", ".bash":
		return cleaner.LangBash
	case ".swift":
		return cleaner.LangSwift
	case ".kt":
		return cleaner.LangKotlin
	case ".sql":
		return cleaner.LangSQL
	}
	return ""
}

// min returns the smaller of two integers.
// This helper function is used to limit the number of concurrent workers.
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
</document_content>
</document>
<document index="37">
<source>core/cleaner/handlers/typescript_handler_test.go</source>
<document_content>package handlers

import "testing"

func TestTypeScriptHandler(t *testing.T) {
	handler := &TypeScriptHandler{}

	// Verify that TypeScriptHandler extends JavaScriptHandler
	importTypes := handler.GetImportTypes()
	baseImportTypes := handler.JavaScriptHandler.GetImportTypes()

	// All base import types should be included
	for _, baseType := range baseImportTypes {
		found := false
		for _, importType := range importTypes {
			if importType == baseType {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("TypeScript handler missing base import type: %s", baseType)
		}
	}

	// Should have additional TypeScript specific import types
	if len(importTypes) <= len(baseImportTypes) {
		t.Error("TypeScript handler should have additional import types")
	}

	extraTypes := []string{"import_require_clause", "import_alias"}
	for _, extraType := range extraTypes {
		found := false
		for _, importType := range importTypes {
			if importType == extraType {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("TypeScript handler missing import type: %s", extraType)
		}
	}
}
</document_content>
</document>
<document index="38">
<source>core/cleaner/options.go</source>
<document_content>package cleaner

// CleanerOptions defines the configuration options for the code cleaner
type CleanerOptions struct {
	// RemoveComments determines if comments should be removed
	RemoveComments bool

	// PreserveDocComments determines if documentation comments should be preserved
	PreserveDocComments bool

	// RemoveImports determines if import statements should be removed
	RemoveImports bool

	// RemoveLogging determines if logging statements should be removed
	RemoveLogging bool

	// RemoveGettersSetters determines if getter/setter methods should be removed
	RemoveGettersSetters bool

	// OptimizeWhitespace determines if whitespace should be optimized
	OptimizeWhitespace bool

	// RemoveEmptyLines determines if empty lines should be removed
	RemoveEmptyLines bool

	// LoggingPrefixes defines the prefixes of logging statements to remove
	LoggingPrefixes map[Language][]string
}

// DefaultOptions returns a new CleanerOptions with default settings
func DefaultOptions() *CleanerOptions {
	return &CleanerOptions{
		RemoveComments:       true,
		PreserveDocComments:  true,
		RemoveImports:        false,
		RemoveLogging:        true,
		RemoveGettersSetters: true,
		OptimizeWhitespace:   true,
		RemoveEmptyLines:     true,
		LoggingPrefixes: map[Language][]string{
			LangGo:         {"log.", "logger."},
			LangJava:       {"Logger.", "System.out.", "System.err."},
			LangPython:     {"logging.", "logger.", "print(", "print ("},
			LangJavaScript: {"console.", "logger."},
			LangTypeScript: {"console.", "logger."},
			LangPHP:        {"error_log(", "print_r(", "var_dump("},
			LangRuby:       {"puts ", "print ", "p ", "logger."},
			LangCSharp:     {"Console.", "Debug.", "Logger."},
			LangSwift:      {"print(", "debugPrint(", "NSLog("},
			LangKotlin:     {"println(", "print(", "Logger."},
		},
	}
}
</document_content>
</document>
<document index="39">
<source>core/processor_test.go</source>
<document_content>package core

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestFileProcessor(t *testing.T) {
	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test files with specific sizes
	files := map[string]struct {
		size    int64
		content string
	}{
		"small.txt":     {size: 100, content: strings.Repeat("a", 100)},
		"medium.txt":    {size: 1024, content: strings.Repeat("b", 1024)},
		"large.txt":     {size: 2048, content: strings.Repeat("c", 2048)},
		"test/nest.txt": {size: 100, content: strings.Repeat("d", 100)},
	}

	// Create the files
	for name, info := range files {
		path := filepath.Join(tmpDir, name)
		err := os.MkdirAll(filepath.Dir(path), 0755)
		if err != nil {
			t.Fatalf("Failed to create directory for %s: %v", name, err)
		}
		err = os.WriteFile(path, []byte(info.content), 0644)
		if err != nil {
			t.Fatalf("Failed to create test file %s: %v", name, err)
		}
	}

	tests := []struct {
		name          string
		maxSize       int64
		expectedCount int
	}{
		{
			name:          "process all files",
			maxSize:       3000,
			expectedCount: 4,
		},
		{
			name:          "size limit excludes large file",
			maxSize:       1500,
			expectedCount: 3,
		},
		{
			name:          "small size limit",
			maxSize:       500,
			expectedCount: 2,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			processor := NewFileProcessor(&MixOptions{
				InputPath:   tmpDir,
				MaxFileSize: tt.maxSize,
			})

			var paths []string
			for name := range files {
				paths = append(paths, filepath.Join(tmpDir, name))
			}

			contents, err := processor.ProcessFiles(paths)
			if err != nil {
				t.Fatalf("ProcessFiles failed: %v", err)
			}

			if len(contents) != tt.expectedCount {
				t.Errorf("Expected %d files, got %d", tt.expectedCount, len(contents))
			}

			// Verify content integrity
			for _, content := range contents {
				// Convert the content path to be relative to tmpDir for comparison
				relPath, err := filepath.Rel(tmpDir, filepath.Join(tmpDir, content.Path))
				if err != nil {
					t.Fatalf("Failed to get relative path: %v", err)
				}

				expectedInfo, exists := files[relPath]
				if !exists {
					t.Errorf("Unexpected file in results: %s (relative path: %s)", content.Path, relPath)
					continue
				}

				if content.Size != expectedInfo.size {
					t.Errorf("Size mismatch for %s: expected %d, got %d",
						relPath, expectedInfo.size, content.Size)
				}

				if content.Content != expectedInfo.content {
					t.Errorf("Content mismatch for %s", relPath)
				}
			}
		})
	}
}

func TestFileProcessorErrors(t *testing.T) {
	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-error-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create a nested directory structure
	nestedDir := filepath.Join(tmpDir, "nested")
	if err := os.MkdirAll(nestedDir, 0755); err != nil {
		t.Fatalf("Failed to create nested directory: %v", err)
	}

	// Create a test file in the nested directory
	testFile := filepath.Join(nestedDir, "test.txt")
	if err := os.WriteFile(testFile, []byte("test content"), 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Create processor with minimal size to force errors
	processor := NewFileProcessor(&MixOptions{
		InputPath:   tmpDir,
		MaxFileSize: 1, // 1 byte max size to force size-related errors
	})

	tests := []struct {
		name        string
		path        string
		wantErr     bool
		errContains string
	}{
		{
			name:        "process directory as file",
			path:        nestedDir,
			wantErr:     true,
			errContains: "is a directory",
		},
		{
			name:        "process non-existent file",
			path:        filepath.Join(tmpDir, "nonexistent.txt"),
			wantErr:     true,
			errContains: "no such file",
		},
		{
			name:    "process file exceeding size limit",
			path:    testFile,
			wantErr: false, // This should not error as we handle large files gracefully
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := processor.processFile(tt.path)

			if tt.wantErr {
				if result.Error == nil {
					t.Errorf("Expected error for %s", tt.name)
					return
				}
				if tt.errContains != "" && !strings.Contains(strings.ToLower(result.Error.Error()), strings.ToLower(tt.errContains)) {
					t.Errorf("Expected error containing %q, got %q", tt.errContains, result.Error)
				}
			} else {
				if result.Error != nil {
					t.Errorf("Unexpected error: %v", result.Error)
				}
			}
		})
	}
}

func TestProcessorConcurrency(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "filefusion-concurrent-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create multiple test files with varying permissions
	files := []struct {
		name        string
		content     string
		permissions os.FileMode
		shouldError bool
	}{
		{"readable.txt", "test content", 0644, false},
		{"unreadable.txt", "test content", 0000, true},
		{"executable.txt", "test content", 0755, false},
	}

	var filePaths []string
	for _, f := range files {
		path := filepath.Join(tmpDir, f.name)
		if err := os.WriteFile(path, []byte(f.content), f.permissions); err != nil {
			t.Fatalf("Failed to create test file %s: %v", f.name, err)
		}
		filePaths = append(filePaths, path)

		// Set file permissions after creation
		if err := os.Chmod(path, f.permissions); err != nil {
			t.Fatalf("Failed to set permissions for %s: %v", f.name, err)
		}
	}

	processor := NewFileProcessor(&MixOptions{
		InputPath:   tmpDir,
		MaxFileSize: 1024 * 1024, // Increase size limit to 1MB to ensure files are processed
	})

	// Test concurrent processing
	contents, err := processor.ProcessFiles(filePaths)

	// We should get an error because one file is unreadable
	if err == nil {
		t.Error("Expected error due to unreadable file, got none")
	}

	// Verify that readable files were still processed
	// Count only files that were successfully processed
	readableCount := 0
	for _, content := range contents {
		if !strings.Contains(content.Path, "unreadable") {
			readableCount++
		}
	}

	expectedReadable := 2 // readable.txt and executable.txt
	if readableCount != expectedReadable {
		t.Errorf("Expected %d readable files, got %d", expectedReadable, readableCount)
	}
}

func TestProcessorEdgeCases(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "filefusion-paths-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	edgeCases := []struct {
		path    string
		content string
	}{
		{"file with spaces.go", "content"},
		{"file#with#hashes.go", "content"},
		{"file_with_.go", "content"},
		{"../outside/attempt.go", "content"},
		{"./inside/./path.go", "content"},
	}

	for _, ec := range edgeCases {
		path := filepath.Join(tmpDir, ec.path)
		if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
			continue // Skip if directory creation fails (e.g., for ../outside)
		}
		if err := os.WriteFile(path, []byte(ec.content), 0644); err != nil {
			continue // Skip if file creation fails
		}
	}

	processor := NewFileProcessor(&MixOptions{
		InputPath:   tmpDir,
		MaxFileSize: 1024,
	})

	paths := []string{
		filepath.Join(tmpDir, "file with spaces.go"),
		filepath.Join(tmpDir, "file#with#hashes.go"),
		filepath.Join(tmpDir, "file_with_.go"),
	}

	contents, err := processor.ProcessFiles(paths)
	if err != nil {
		t.Fatalf("Failed to process edge case paths: %v", err)
	}

	if len(contents) != 3 {
		t.Errorf("Expected 3 processed files, got %d", len(contents))
	}
}
</document_content>
</document>
<document index="40">
<source>core/output_test.go</source>
<document_content>package core

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"gopkg.in/yaml.v3"
)

func TestOutputGenerator(t *testing.T) {
	// Create test data
	contents := []FileContent{
		{
			Path:      "test1.go",
			Name:      "test1.go",
			Content:   "package main\n",
			Extension: "go",
			Size:      12,
		},
		{
			Path:      "test2.go",
			Name:      "test2.go",
			Content:   "package test\n",
			Extension: "go",
			Size:      12,
		},
	}

	// Create temporary directory for output files
	tmpDir, err := os.MkdirTemp("", "filefusion-output-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	tests := []struct {
		name       string
		outputType OutputType
		validate   func(t *testing.T, path string, contents []FileContent)
	}{
		{
			name:       "JSON output",
			outputType: OutputTypeJSON,
			validate: func(t *testing.T, path string, contents []FileContent) {
				var output struct {
					Documents []struct {
						Index           int    `json:"index"`
						Source          string `json:"source"`
						DocumentContent string `json:"document_content"`
					} `json:"documents"`
				}

				data, err := os.ReadFile(path)
				if err != nil {
					t.Fatalf("Failed to read output file: %v", err)
				}

				if err := json.Unmarshal(data, &output); err != nil {
					t.Fatalf("Failed to parse JSON: %v", err)
				}

				if len(output.Documents) != len(contents) {
					t.Errorf("Expected %d documents, got %d", len(contents), len(output.Documents))
				}

				for i, doc := range output.Documents {
					if doc.Index != i+1 {
						t.Errorf("Expected index %d, got %d", i+1, doc.Index)
					}
					if doc.Source != contents[i].Path {
						t.Errorf("Expected source %s, got %s", contents[i].Path, doc.Source)
					}
					if doc.DocumentContent != contents[i].Content {
						t.Errorf("Content mismatch for document %d", i+1)
					}
				}
			},
		},
		{
			name:       "YAML output",
			outputType: OutputTypeYAML,
			validate: func(t *testing.T, path string, contents []FileContent) {
				var output struct {
					Documents []struct {
						Index           int    `yaml:"index"`
						Source          string `yaml:"source"`
						DocumentContent string `yaml:"document_content"`
					} `yaml:"documents"`
				}

				data, err := os.ReadFile(path)
				if err != nil {
					t.Fatalf("Failed to read output file: %v", err)
				}

				if err := yaml.Unmarshal(data, &output); err != nil {
					t.Fatalf("Failed to parse YAML: %v", err)
				}

				if len(output.Documents) != len(contents) {
					t.Errorf("Expected %d documents, got %d", len(contents), len(output.Documents))
				}

				for i, doc := range output.Documents {
					if doc.Index != i+1 {
						t.Errorf("Expected index %d, got %d", i+1, doc.Index)
					}
					if doc.Source != contents[i].Path {
						t.Errorf("Expected source %s, got %s", contents[i].Path, doc.Source)
					}
					if doc.DocumentContent != contents[i].Content {
						t.Errorf("Content mismatch for document %d", i+1)
					}
				}
			},
		},
		{
			name:       "XML output",
			outputType: OutputTypeXML,
			validate: func(t *testing.T, path string, contents []FileContent) {
				data, err := os.ReadFile(path)
				if err != nil {
					t.Fatalf("Failed to read output file: %v", err)
				}

				xmlContent := string(data)
				if !strings.Contains(xmlContent, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>") {
					t.Error("XML declaration missing")
				}

				if !strings.Contains(xmlContent, "<documents>") {
					t.Error("Root element missing")
				}

				for i, content := range contents {
					expectedIndex := i + 1
					expectedSource := fmt.Sprintf("<source>%s</source>", content.Path)
					expectedContent := fmt.Sprintf("<document_content>%s</document_content>", content.Content)

					if !strings.Contains(xmlContent, fmt.Sprintf("index=\"%d\"", expectedIndex)) {
						t.Errorf("Missing index %d", expectedIndex)
					}
					if !strings.Contains(xmlContent, expectedSource) {
						t.Errorf("Missing source %s", content.Path)
					}
					if !strings.Contains(xmlContent, expectedContent) {
						t.Errorf("Missing content for document %d", expectedIndex)
					}
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			outputPath := filepath.Join(tmpDir, fmt.Sprintf("output-%s", string(tt.outputType)))
			generator := NewOutputGenerator(&MixOptions{
				OutputPath:    outputPath,
				MaxOutputSize: 10 * 1024 * 1024, // 10MB limit for tests
				OutputType:    tt.outputType,
			})

			if err := generator.Generate(contents); err != nil {
				t.Fatalf("Failed to generate output: %v", err)
			}

			tt.validate(t, outputPath, contents)
		})
	}
}

func TestOutputSizeLimit(t *testing.T) {
	// Create temporary directory for output files
	tmpDir, err := os.MkdirTemp("", "filefusion-output-size-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test content that will generate a predictable output size
	largeContent := make([]FileContent, 5)
	contentSize := 1024 * 1024 // 1MB per file
	content := strings.Repeat("x", contentSize)
	for i := range largeContent {
		largeContent[i] = FileContent{
			Path:    fmt.Sprintf("test%d.go", i),
			Name:    fmt.Sprintf("test%d.go", i),
			Content: content,
			Size:    int64(contentSize),
		}
	}

	tests := []struct {
		name        string
		maxSize     int64
		shouldError bool
		outputType  OutputType
	}{
		{
			name:        "within size limit",
			maxSize:     10 * 1024 * 1024, // 10MB
			shouldError: false,
			outputType:  OutputTypeXML,
		},
		{
			name:        "exceeds size limit",
			maxSize:     1 * 1024 * 1024, // 1MB
			shouldError: true,
			outputType:  OutputTypeXML,
		},
		{
			name:        "within size limit json",
			maxSize:     10 * 1024 * 1024,
			shouldError: false,
			outputType:  OutputTypeJSON,
		},
		{
			name:        "exceeds size limit json",
			maxSize:     1 * 1024 * 1024,
			shouldError: true,
			outputType:  OutputTypeJSON,
		},
		{
			name:        "within size limit yaml",
			maxSize:     10 * 1024 * 1024,
			shouldError: false,
			outputType:  OutputTypeYAML,
		},
		{
			name:        "exceeds size limit yaml",
			maxSize:     1 * 1024 * 1024,
			shouldError: true,
			outputType:  OutputTypeYAML,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			outputPath := filepath.Join(tmpDir, fmt.Sprintf("output-%s%s",
				tt.name, string(tt.outputType)))

			generator := NewOutputGenerator(&MixOptions{
				OutputPath:    outputPath,
				MaxOutputSize: tt.maxSize,
				OutputType:    tt.outputType,
			})

			err := generator.Generate(largeContent)

			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
					return
				}
				if !strings.Contains(err.Error(), "output size") {
					t.Errorf("Expected output size error, got: %v", err)
				}
				// Verify the output file was not created
				if _, err := os.Stat(outputPath); !os.IsNotExist(err) {
					t.Error("Output file should not exist")
				}
			} else {
				if err != nil {
					t.Errorf("Unexpected error: %v", err)
					return
				}
				// Verify the output file exists and is within size limit
				info, err := os.Stat(outputPath)
				if err != nil {
					t.Errorf("Failed to stat output file: %v", err)
					return
				}
				if info.Size() > tt.maxSize {
					t.Errorf("Output file size %d exceeds limit %d", info.Size(), tt.maxSize)
				}
			}
		})
	}
}

func TestOutputSymlinkHandling(t *testing.T) {
	if os.Getenv("SKIP_SYMLINK_TESTS") != "" {
		t.Skip("Skipping symlink tests")
	}

	tmpDir, err := os.MkdirTemp("", "filefusion-symlink-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create a subdirectory for output
	outputDir := filepath.Join(tmpDir, "output")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		t.Fatalf("Failed to create output directory: %v", err)
	}

	// Create a symlink to the output directory
	symlinkPath := filepath.Join(tmpDir, "symlink")
	if err := os.Symlink(outputDir, symlinkPath); err != nil {
		t.Fatalf("Failed to create symlink: %v", err)
	}

	// Create test content
	contents := []FileContent{
		{
			Path:    "test.go",
			Content: "package main\n",
			Size:    12,
		},
	}

	// Test writing through symlink
	outputPath := filepath.Join(symlinkPath, "output.xml")
	generator := NewOutputGenerator(&MixOptions{
		OutputPath:    outputPath,
		MaxOutputSize: 1024,
		OutputType:    OutputTypeXML,
	})

	if err := generator.Generate(contents); err != nil {
		t.Fatalf("Failed to generate output through symlink: %v", err)
	}

	// Verify file exists in actual directory
	realPath := filepath.Join(outputDir, "output.xml")
	if _, err := os.Stat(realPath); os.IsNotExist(err) {
		t.Error("Output file not created in real directory")
	}
}
</document_content>
</document>
<document index="41">
<source>core/types.go</source>
<document_content>package core

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/drgsn/filefusion/internal/core/cleaner"
)

type FileContent struct {
	Path      string `json:"path"`
	Name      string `json:"name"`
	Content   string `json:"content"`
	Extension string `json:"extension"`
	Size      int64  `json:"size"`
}

type OutputType string

const (
	OutputTypeXML  OutputType = "XML"
	OutputTypeJSON OutputType = "JSON"
	OutputTypeYAML OutputType = "YAML"
)

type MixOptions struct {
	InputPath      string
	OutputPath     string
	Pattern        string
	Exclude        string
	MaxFileSize    int64
	MaxOutputSize  int64
	OutputType     OutputType
	CleanerOptions *cleaner.CleanerOptions
}

func validatePattern(pattern string) error {
	if pattern == "" {
		return fmt.Errorf("pattern cannot be empty")
	}

	patterns := strings.Split(pattern, ",")
	for _, p := range patterns {
		p = strings.TrimSpace(p)
		if p == "" {
			continue
		}

		// Try to match against a test string to verify pattern syntax
		if _, err := filepath.Match(p, "test"); err != nil {
			return fmt.Errorf("syntax error in pattern %q: %w", p, err)
		}
	}
	return nil
}

func validateExcludePatterns(exclude string) error {
	if exclude == "" {
		return nil
	}

	patterns := strings.Split(exclude, ",")
	for _, p := range patterns {
		p = strings.TrimSpace(p)
		if p == "" {
			continue
		}

		// Skip validation for glob patterns with **
		if strings.Contains(p, "**") {
			continue
		}

		// Try to match against a test string to verify pattern syntax
		if _, err := filepath.Match(p, "test"); err != nil {
			return fmt.Errorf("invalid exclusion pattern %q: %w", p, err)
		}
	}
	return nil
}

func (m *MixOptions) Validate() error {
	if m.InputPath == "" {
		return &MixError{Message: "input path is required"}
	}
	if m.OutputPath == "" {
		return &MixError{Message: "output path is required"}
	}
	if err := validatePattern(m.Pattern); err != nil {
		return err
	}
	if err := validateExcludePatterns(m.Exclude); err != nil {
		return err
	}
	if m.MaxFileSize <= 0 {
		return &MixError{Message: "max file size must be greater than 0"}
	}
	if m.MaxOutputSize <= 0 {
		return &MixError{Message: "max output size must be greater than 0"}
	}
	switch m.OutputType {
	case OutputTypeXML, OutputTypeJSON, OutputTypeYAML:
	default:
		return &MixError{Message: fmt.Sprintf("unsupported output type: %s", m.OutputType)}
	}
	return nil
}

type MixError struct {
	File    string
	Message string
}

func (e *MixError) Error() string {
	if e.File != "" {
		return "file " + e.File + ": " + e.Message
	}
	return e.Message
}
</document_content>
</document>
</documents>