
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>filefusion: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/drgsn/filefusion/cmd/filefusion/main.go (88.5%)</option>
				
				<option value="file1">github.com/drgsn/filefusion/internal/core/mixer.go (85.3%)</option>
				
				<option value="file2">github.com/drgsn/filefusion/internal/core/types.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/drgsn/filefusion/internal/core"
        "github.com/spf13/cobra"
)

type FileInfo struct {
        Path string `json:"path"`
        Size int64  `json:"size"`
}

var (
        outputPath  string
        pattern     string
        exclude     string
        maxFileSize string
        jsonOutput  bool
)

var rootCmd = &amp;cobra.Command{
        Use:   "filefusion [paths...]",
        Short: "Filefusion - File concatenation tool optimized for LLM usage",
        Long: `Filefusion concatenates files into a format optimized for Large Language Models (LLMs).
It preserves file metadata and structures the output in an XML-like or JSON format.
Complete documentation is available at https://github.com/drgsn/filefusion`,
        RunE: runMix,
}

func init() <span class="cov8" title="1">{
        rootCmd.PersistentFlags().StringVarP(&amp;outputPath, "output", "o", "", "output file path (if not specified, generates files based on input paths)")
        rootCmd.PersistentFlags().StringVarP(&amp;pattern, "pattern", "p", "*.go,*.json,*.yaml,*.yml", "comma-separated file patterns (e.g., '*.go,*.json')")
        rootCmd.PersistentFlags().StringVarP(&amp;exclude, "exclude", "e", "", "comma-separated patterns to exclude (e.g., 'build/**,*.jar')")
        rootCmd.PersistentFlags().StringVar(&amp;maxFileSize, "max-size", "10MB", "maximum size per file")
}</span>

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

func deriveOutputPath(inputPath string) string <span class="cov8" title="1">{
        // Get the last component of the path
        base := filepath.Base(strings.TrimSuffix(inputPath, string(os.PathSeparator)))

        // If it's a file, use its name with .xml extension
        if ext := filepath.Ext(base); ext != "" </span><span class="cov8" title="1">{
                return base + ".xml"
        }</span>

        // For directories, append .xml
        <span class="cov8" title="1">return base + ".xml"</span>
}

func runMix(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{

        if len(args) == 0 </span><span class="cov8" title="1">{
                currentDir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get current directory: %w", err)
                }</span>
                <span class="cov8" title="1">args = []string{currentDir}</span>
        }

        // Validate pattern first
        <span class="cov8" title="1">if pattern == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("pattern cannot be empty")
        }</span>

        // Parse max file size
        <span class="cov8" title="1">maxBytes, err := parseSize(maxFileSize)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid max-size value: %w", err)
        }</span>

        // If output path is specified, validate and determine output type
        <span class="cov8" title="1">var globalOutputType core.OutputType
        if outputPath != "" </span><span class="cov8" title="1">{
                ext := strings.ToLower(filepath.Ext(outputPath))
                switch ext </span>{
                case ".json":<span class="cov8" title="1">
                        globalOutputType = core.OutputTypeJSON</span>
                case ".yaml", ".yml":<span class="cov8" title="1">
                        globalOutputType = core.OutputTypeYAML</span>
                case ".xml":<span class="cov8" title="1">
                        globalOutputType = core.OutputTypeXML</span>
                default:<span class="cov8" title="1">
                        return fmt.Errorf("invalid output file extension: must be .xml, .json, .yaml, or .yml")</span>
                }
        }

        // Process each input path
        <span class="cov8" title="1">for _, inputPath := range args </span><span class="cov8" title="1">{
                // Determine output path and type for this input
                var currentOutputPath string
                var outputType core.OutputType

                if outputPath != "" </span><span class="cov8" title="1">{
                        // Use global output path if specified
                        currentOutputPath = outputPath
                        outputType = globalOutputType
                }</span> else<span class="cov8" title="1"> {
                        // Generate output path based on input path
                        currentOutputPath = deriveOutputPath(inputPath)
                        outputType = core.OutputTypeXML // Default to XML for auto-generated paths
                }</span>

                // Create mixer options
                <span class="cov8" title="1">options := &amp;core.MixOptions{
                        InputPath:   inputPath,
                        OutputPath:  currentOutputPath,
                        Pattern:     pattern,
                        Exclude:     exclude,
                        MaxFileSize: maxBytes,
                        OutputType:  outputType,
                }

                // First, scan for files and check total size
                files, totalSize, err := scanFiles(options)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("error processing %s: %w", inputPath, err)
                }</span>

                // Print summary before processing
                <span class="cov8" title="1">fmt.Printf("Processing %s:\n", inputPath)
                fmt.Printf("Found %d files matching pattern\n", len(files))
                fmt.Printf("Total size: %s\n", formatSize(totalSize))

                // Check if total size exceeds maximum
                if totalSize &gt; maxBytes </span><span class="cov0" title="0">{
                        fmt.Printf("\nError: Total size (%s) exceeds maximum allowed size (%s)\n",
                                formatSize(totalSize), maxFileSize)
                        fmt.Println("\nMatching files:")

                        for _, file := range files </span><span class="cov0" title="0">{
                                fmt.Printf("- %s (%s)\n", file.Path, formatSize(file.Size))
                        }</span>

                        <span class="cov0" title="0">return fmt.Errorf("total size exceeds maximum allowed size for %s", inputPath)</span>
                }

                // Create and run mixer
                <span class="cov8" title="1">mixer := core.NewMixer(options)
                if err := mixer.Mix(); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("error mixing %s: %w", inputPath, err)
                }</span>

                <span class="cov8" title="1">fmt.Printf("Successfully created %s\n\n", currentOutputPath)

                // If using a global output path, only process the first input
                if outputPath != "" </span><span class="cov8" title="1">{
                        fmt.Println("Note: Using specified output path. Additional inputs will be ignored.")
                        break</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func scanFiles(options *core.MixOptions) ([]FileInfo, int64, error) <span class="cov8" title="1">{
        var files []FileInfo
        var totalSize int64

        // Prepare patterns
        patterns := strings.Split(options.Pattern, ",")
        for i := range patterns </span><span class="cov8" title="1">{
                patterns[i] = strings.TrimSpace(patterns[i])
        }</span>

        // Prepare exclude patterns
        <span class="cov8" title="1">var excludePatterns []string
        if options.Exclude != "" </span><span class="cov8" title="1">{
                excludePatterns = strings.Split(options.Exclude, ",")
                for i := range excludePatterns </span><span class="cov8" title="1">{
                        excludePatterns[i] = strings.TrimSpace(excludePatterns[i])
                }</span>
        }

        <span class="cov8" title="1">err := filepath.Walk(options.InputPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories
                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        // Skip .git directory
                        if filepath.Base(path) == ".git" </span><span class="cov8" title="1">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }

                // Get relative path for pattern matching
                <span class="cov8" title="1">relPath, err := filepath.Rel(options.InputPath, path)
                if err != nil </span><span class="cov0" title="0">{
                        relPath = path
                }</span>

                // Check exclusions first
                <span class="cov8" title="1">for _, pattern := range excludePatterns </span><span class="cov8" title="1">{
                        if pattern == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Handle directory wildcards
                        <span class="cov8" title="1">if strings.Contains(pattern, "**") </span><span class="cov8" title="1">{
                                pattern = strings.ReplaceAll(pattern, "**", "*")
                                if matched, _ := filepath.Match(pattern, relPath); matched </span><span class="cov8" title="1">{
                                        return nil
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if matched, _ := filepath.Match(pattern, relPath); matched </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                        }
                }

                // Check if file matches any inclusion pattern
                <span class="cov8" title="1">for _, pattern := range patterns </span><span class="cov8" title="1">{
                        match, err := filepath.Match(pattern, filepath.Base(path))
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                                // Check file size
                                if info.Size() &lt;= options.MaxFileSize </span><span class="cov8" title="1">{
                                        files = append(files, FileInfo{
                                                Path: relPath,
                                                Size: info.Size(),
                                        })
                                        totalSize += info.Size()
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">return files, totalSize, nil</span>
}

// parseSize converts a size string (e.g., "10MB") to bytes

func parseSize(size string) (int64, error) <span class="cov8" title="1">{
        // Remove all spaces and convert to uppercase
        size = strings.ToUpper(strings.ReplaceAll(size, " ", ""))

        if size == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("size cannot be empty")
        }</span>

        <span class="cov8" title="1">var multiplier int64 = 1
        var value string

        // Check for valid suffix first
        switch </span>{
        case strings.HasSuffix(size, "TB"):<span class="cov8" title="1">
                multiplier = 1024 * 1024 * 1024 * 1024
                value = strings.TrimSuffix(size, "TB")</span>
        case strings.HasSuffix(size, "GB"):<span class="cov8" title="1">
                multiplier = 1024 * 1024 * 1024
                value = strings.TrimSuffix(size, "GB")</span>
        case strings.HasSuffix(size, "MB"):<span class="cov8" title="1">
                multiplier = 1024 * 1024
                value = strings.TrimSuffix(size, "MB")</span>
        case strings.HasSuffix(size, "KB"):<span class="cov8" title="1">
                multiplier = 1024
                value = strings.TrimSuffix(size, "KB")</span>
        case strings.HasSuffix(size, "B"):<span class="cov8" title="1">
                value = strings.TrimSuffix(size, "B")</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("invalid size format: must end with B, KB, MB, GB, or TB")</span>
        }

        // Parse the numeric value
        <span class="cov8" title="1">num, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid size number: %w", err)
        }</span>

        // Check for negative numbers
        <span class="cov8" title="1">if num &lt;= 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("size must be a positive number")
        }</span>

        <span class="cov8" title="1">return num * multiplier, nil</span>
}

// formatSize converts bytes to a human-readable string
func formatSize(bytes int64) string <span class="cov8" title="1">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov8" title="1">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov8" title="1">{
                div *= unit
                exp++
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package core

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "text/template"

        "gopkg.in/yaml.v3"
)

// FileResult represents the result of processing a single file
type FileResult struct {
        Content FileContent
        Error   error
}

// Mixer handles file concatenation
type Mixer struct {
        options *MixOptions
}

// NewMixer creates a new Mixer instance
func NewMixer(options *MixOptions) *Mixer <span class="cov8" title="1">{
        if options.MaxFileSize == 0 </span><span class="cov8" title="1">{
                options.MaxFileSize = 10 * 1024 * 1024 // Default 10MB
        }</span>
        <span class="cov8" title="1">return &amp;Mixer{options: options}</span>
}

// Mix processes and concatenates files
func (m *Mixer) Mix() error <span class="cov8" title="1">{
        // Find all matching files
        files, err := m.findFiles()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error finding files: %w", err)
        }</span>

        // Read and process files concurrently
        <span class="cov8" title="1">contents, err := m.readFilesConcurrently(files)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading files: %w", err)
        }</span>

        // Generate LLM-optimized output
        <span class="cov8" title="1">return m.generateLLMOutput(contents)</span>
}

// matchesAnyPattern checks if a file matches any of the provided patterns
func (m *Mixer) matchesAnyPattern(path, filename string) (bool, error) <span class="cov8" title="1">{
        // First check exclusions
        if m.options.Exclude != "" </span><span class="cov8" title="1">{
                excludePatterns := strings.Split(m.options.Exclude, ",")
                for _, pattern := range excludePatterns </span><span class="cov8" title="1">{
                        pattern = strings.TrimSpace(pattern)
                        if pattern == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Convert all slashes to platform-specific separator
                        <span class="cov8" title="1">pattern = filepath.FromSlash(pattern)
                        pathToCheck := filepath.FromSlash(path)

                        // Handle directory-based exclusions with **
                        if strings.Contains(pattern, "**") </span><span class="cov8" title="1">{
                                basePattern := strings.TrimSuffix(pattern, string(filepath.Separator)+"**")
                                basePattern = strings.TrimSuffix(basePattern, "**")

                                // Check if the path starts with the base pattern (excluding the **)
                                if strings.HasPrefix(pathToCheck, basePattern) </span><span class="cov8" title="1">{
                                        return false, nil
                                }</span>
                        } else<span class="cov8" title="1"> if strings.Contains(pattern, string(filepath.Separator)) </span><span class="cov0" title="0">{
                                // Handle path-based exclusions (contains path separator)
                                if match, err := filepath.Match(pattern, pathToCheck); err != nil </span><span class="cov0" title="0">{
                                        return false, fmt.Errorf("invalid exclusion pattern %q: %w", pattern, err)
                                }</span> else<span class="cov0" title="0"> if match </span><span class="cov0" title="0">{
                                        return false, nil
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // Handle file-based exclusions (no path separator)
                                if match, err := filepath.Match(pattern, filename); err != nil </span><span class="cov0" title="0">{
                                        return false, fmt.Errorf("invalid exclusion pattern %q: %w", pattern, err)
                                }</span> else<span class="cov8" title="1"> if match </span><span class="cov8" title="1">{
                                        return false, nil
                                }</span>
                        }
                }
        }

        // Then check inclusion patterns
        <span class="cov8" title="1">patterns := strings.Split(m.options.Pattern, ",")
        for _, pattern := range patterns </span><span class="cov8" title="1">{
                pattern = strings.TrimSpace(pattern)
                if pattern == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // For inclusion patterns, we only match against the filename
                <span class="cov8" title="1">match, err := filepath.Match(pattern, filename)
                if err != nil </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("invalid pattern %q: %w", pattern, err)
                }</span>
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

// findFiles finds all files matching any of the patterns recursively
func (m *Mixer) findFiles() ([]string, error) <span class="cov8" title="1">{
        var matches []string

        err := filepath.Walk(m.options.InputPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("error accessing path %s: %w", path, err)
                }</span>

                // Skip directories themselves
                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Get relative path for pattern matching
                <span class="cov8" title="1">relPath, err := filepath.Rel(m.options.InputPath, path)
                if err != nil </span><span class="cov0" title="0">{
                        relPath = path
                }</span>

                // Check if file matches patterns
                <span class="cov8" title="1">match, err := m.matchesAnyPattern(relPath, filepath.Base(path))
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        matches = append(matches, path)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(matches) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no files found matching pattern(s) %q (excluding %q) in %s",
                        m.options.Pattern, m.options.Exclude, m.options.InputPath)
        }</span>

        <span class="cov8" title="1">return matches, nil</span>
}

// readFilesConcurrently reads all files concurrently using worker pool
func (m *Mixer) readFilesConcurrently(paths []string) ([]FileContent, error) <span class="cov8" title="1">{
        numWorkers := min(len(paths), 10) // Limit max number of concurrent workers
        results := make(chan FileResult, len(paths))
        var wg sync.WaitGroup

        // Create a channel for distributing work
        jobs := make(chan string, len(paths))
        for _, path := range paths </span><span class="cov8" title="1">{
                jobs &lt;- path
        }</span>
        <span class="cov8" title="1">close(jobs)

        // Start worker pool
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for path := range jobs </span><span class="cov8" title="1">{
                                result := m.processFile(path)
                                results &lt;- result
                        }</span>
                }()
        }

        // Wait for all workers to finish in a separate goroutine
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(results)
        }</span>()

        // Collect results and handle errors
        <span class="cov8" title="1">var contents []FileContent
        var errors []error

        for result := range results </span><span class="cov8" title="1">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        errors = append(errors, result.Error)
                        continue</span>
                }
                <span class="cov8" title="1">if result.Content.Size &gt; 0 </span><span class="cov8" title="1">{ // Skip empty results (from skipped files)
                        contents = append(contents, result.Content)
                }</span>
        }

        // If any errors occurred, return the first one
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return nil, errors[0]
        }</span>

        <span class="cov8" title="1">return contents, nil</span>
}

// processFile handles reading and processing of a single file
func (m *Mixer) processFile(path string) FileResult <span class="cov8" title="1">{
        // Get file info
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return FileResult{
                        Error: &amp;MixError{
                                File:    path,
                                Message: fmt.Sprintf("error getting file info: %v", err),
                        },
                }
        }</span>

        // Skip if file is too large
        <span class="cov8" title="1">if info.Size() &gt; m.options.MaxFileSize </span><span class="cov8" title="1">{
                fmt.Fprintf(os.Stderr, "Warning: Skipping %s (size %d bytes exceeds limit %d bytes)\n",
                        path, info.Size(), m.options.MaxFileSize)
                return FileResult{} // Return empty result for skipped files
        }</span>

        // Read file content
        <span class="cov8" title="1">content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return FileResult{
                        Error: &amp;MixError{
                                File:    path,
                                Message: fmt.Sprintf("error reading file: %v", err),
                        },
                }
        }</span>

        // Get relative path from input directory
        <span class="cov8" title="1">relPath, err := filepath.Rel(m.options.InputPath, path)
        if err != nil </span><span class="cov0" title="0">{
                relPath = path // Fallback to full path if relative path cannot be determined
        }</span>

        <span class="cov8" title="1">return FileResult{
                Content: FileContent{
                        Path:      relPath,
                        Name:      filepath.Base(path),
                        Extension: strings.TrimPrefix(filepath.Ext(path), "."),
                        Content:   string(content),
                        Size:      info.Size(),
                },
        }</span>
}

// generateLLMOutput generates output optimized for LLM consumption
func (m *Mixer) generateLLMOutput(contents []FileContent) error <span class="cov8" title="1">{
        file, err := os.Create(m.options.OutputPath)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;MixError{
                        File:    m.options.OutputPath,
                        Message: fmt.Sprintf("error creating output file: %v", err),
                }
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Common structure for JSON and YAML output
        type Document struct {
                Index           int    `json:"index" yaml:"index"`
                Source          string `json:"source" yaml:"source"`
                DocumentContent string `json:"document_content" yaml:"document_content"`
        }

        type Output struct {
                Documents []Document `json:"documents" yaml:"documents"`
        }

        // Convert contents to output format
        output := Output{
                Documents: make([]Document, len(contents)),
        }

        for i, content := range contents </span><span class="cov8" title="1">{
                output.Documents[i] = Document{
                        Index:           i + 1,
                        Source:          content.Path,
                        DocumentContent: content.Content,
                }
        }</span>

        <span class="cov8" title="1">switch m.options.OutputType </span>{
        case OutputTypeJSON:<span class="cov8" title="1">
                encoder := json.NewEncoder(file)
                encoder.SetIndent("", "  ")
                if err := encoder.Encode(output); err != nil </span><span class="cov0" title="0">{
                        return &amp;MixError{Message: fmt.Sprintf("error encoding JSON: %v", err)}
                }</span>
                <span class="cov8" title="1">return nil</span>

        case OutputTypeYAML:<span class="cov8" title="1">
                encoder := yaml.NewEncoder(file)
                encoder.SetIndent(2)
                if err := encoder.Encode(output); err != nil </span><span class="cov0" title="0">{
                        return &amp;MixError{Message: fmt.Sprintf("error encoding YAML: %v", err)}
                }</span>
                <span class="cov8" title="1">return nil</span>

        case OutputTypeXML:<span class="cov8" title="1">
                // XML output
                const xmlTemplate = `&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;documents&gt;{{range $index, $file := .}}
&lt;document index="{{add $index 1}}"&gt;
&lt;source&gt;{{.Path}}&lt;/source&gt;
&lt;document_content&gt;{{.Content}}&lt;/document_content&gt;
&lt;/document&gt;{{end}}
&lt;/documents&gt;`

                // Create template with custom functions
                t, err := template.New("llm").Funcs(template.FuncMap{
                        "add": func(a, b int) int </span><span class="cov8" title="1">{ return a + b }</span>,
                }).Parse(xmlTemplate)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return &amp;MixError{Message: fmt.Sprintf("error parsing template: %v", err)}
                }</span>

                // Execute template
                <span class="cov8" title="1">if err := t.Execute(file, contents); err != nil </span><span class="cov0" title="0">{
                        return &amp;MixError{Message: fmt.Sprintf("error executing template: %v", err)}
                }</span>
                <span class="cov8" title="1">return nil</span>

        default:<span class="cov0" title="0">
                return &amp;MixError{Message: fmt.Sprintf("unsupported output type: %s", m.options.OutputType)}</span>
        }
}

// min returns the smaller of two integers
func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

// FileContent represents a file's content and metadata
type FileContent struct {
        Path      string `json:"path"`      // Path to the file (relative to input directory)
        Name      string `json:"name"`      // Name of the file
        Content   string `json:"content"`   // Content of the file
        Extension string `json:"extension"` // File extension without dot
        Size      int64  `json:"size"`      // File size in bytes
}

// OutputType represents the type of output format
type OutputType string

const (
        OutputTypeXML  OutputType = "XML"
        OutputTypeJSON OutputType = "JSON"
        OutputTypeYAML OutputType = "YAML"
)

// MixOptions represents configuration options for the mixer
type MixOptions struct {
        InputPath   string     // Directory to process
        OutputPath  string     // Output file path
        Pattern     string     // Comma-separated file matching patterns
        Exclude     string     // Comma-separated exclusion patterns
        MaxFileSize int64      // Maximum total size in bytes
        OutputType  OutputType // Type of output format
}

// MixError represents an error that occurred during mixing
type MixError struct {
        File    string // File where error occurred
        Message string // Error message
}

// Error implements the error interface for MixError
func (e *MixError) Error() string <span class="cov8" title="1">{
        if e.File != "" </span><span class="cov8" title="1">{
                return "file " + e.File + ": " + e.Message
        }</span>
        <span class="cov0" title="0">return e.Message</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
