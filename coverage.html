
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>filefusion: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/drgsn/filefusion/cmd/filefusion/main.go (88.9%)</option>
				
				<option value="file1">github.com/drgsn/filefusion/internal/core/cleaner/cleaner.go (78.9%)</option>
				
				<option value="file2">github.com/drgsn/filefusion/internal/core/cleaner/handlers/base_handler.go (69.2%)</option>
				
				<option value="file3">github.com/drgsn/filefusion/internal/core/cleaner/handlers/bash_handler.go (80.0%)</option>
				
				<option value="file4">github.com/drgsn/filefusion/internal/core/cleaner/handlers/cpp_handler.go (81.0%)</option>
				
				<option value="file5">github.com/drgsn/filefusion/internal/core/cleaner/handlers/csharp_handler.go (0.0%)</option>
				
				<option value="file6">github.com/drgsn/filefusion/internal/core/cleaner/handlers/css_handler.go (0.0%)</option>
				
				<option value="file7">github.com/drgsn/filefusion/internal/core/cleaner/handlers/go_handler.go (78.6%)</option>
				
				<option value="file8">github.com/drgsn/filefusion/internal/core/cleaner/handlers/html_handler.go (100.0%)</option>
				
				<option value="file9">github.com/drgsn/filefusion/internal/core/cleaner/handlers/java_handler.go (87.0%)</option>
				
				<option value="file10">github.com/drgsn/filefusion/internal/core/cleaner/handlers/javascript_handler.go (100.0%)</option>
				
				<option value="file11">github.com/drgsn/filefusion/internal/core/cleaner/handlers/kotlin_handler.go (73.7%)</option>
				
				<option value="file12">github.com/drgsn/filefusion/internal/core/cleaner/handlers/php_handler.go (69.7%)</option>
				
				<option value="file13">github.com/drgsn/filefusion/internal/core/cleaner/handlers/python_handler.go (87.0%)</option>
				
				<option value="file14">github.com/drgsn/filefusion/internal/core/cleaner/handlers/ruby_handler.go (100.0%)</option>
				
				<option value="file15">github.com/drgsn/filefusion/internal/core/cleaner/handlers/sql_handler.go (100.0%)</option>
				
				<option value="file16">github.com/drgsn/filefusion/internal/core/cleaner/handlers/swift_handler.go (77.4%)</option>
				
				<option value="file17">github.com/drgsn/filefusion/internal/core/cleaner/handlers/typescript_handler.go (100.0%)</option>
				
				<option value="file18">github.com/drgsn/filefusion/internal/core/cleaner/options.go (100.0%)</option>
				
				<option value="file19">github.com/drgsn/filefusion/internal/core/cleaner/types.go (100.0%)</option>
				
				<option value="file20">github.com/drgsn/filefusion/internal/core/finder.go (72.7%)</option>
				
				<option value="file21">github.com/drgsn/filefusion/internal/core/mixer.go (84.8%)</option>
				
				<option value="file22">github.com/drgsn/filefusion/internal/core/output.go (81.2%)</option>
				
				<option value="file23">github.com/drgsn/filefusion/internal/core/processor.go (56.0%)</option>
				
				<option value="file24">github.com/drgsn/filefusion/internal/core/types.go (7.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/drgsn/filefusion/internal/core"
        "github.com/drgsn/filefusion/internal/core/cleaner"
        "github.com/spf13/cobra"
)

// FileInfo represents basic information about a processed file
type FileInfo struct {
        Path string
        Size int64
}

// Command-line flags
var (
        // Core flags
        outputPath    string
        pattern       string
        exclude       string
        maxFileSize   string
        maxOutputSize string
        dryRun        bool

        // Cleaner flags
        cleanEnabled         bool
        removeComments       bool
        preserveDocComments  bool
        removeImports        bool
        removeLogging        bool
        removeGettersSetters bool
        optimizeWhitespace   bool
        removeEmptyLines     bool
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "filefusion [paths...]",
        Short: "Filefusion - File concatenation tool optimized for LLM usage",
        Long: `Filefusion concatenates files into a format optimized for Large Language Models (LLMs).
It preserves file metadata and structures the output in an XML-like or JSON format.
Complete documentation is available at https://github.com/drgsn/filefusion`,
        RunE: runMix,
}

func init() <span class="cov1" title="1">{
        initCoreFlags()
        initCleanerFlags()
}</span>

// initCoreFlags initializes the core command-line flags
func initCoreFlags() <span class="cov1" title="1">{
        rootCmd.PersistentFlags().StringVarP(&amp;outputPath, "output", "o", "", "output file path")
        rootCmd.PersistentFlags().StringVarP(&amp;pattern, "pattern", "p", "*.go,*.json,*.yaml,*.yml", "file patterns")
        rootCmd.PersistentFlags().StringVarP(&amp;exclude, "exclude", "e", "", "exclude patterns")
        rootCmd.PersistentFlags().StringVar(&amp;maxFileSize, "max-file-size", "10MB", "maximum size for individual input files")
        rootCmd.PersistentFlags().StringVar(&amp;maxOutputSize, "max-output-size", "50MB", "maximum size for output file")
        rootCmd.PersistentFlags().BoolVar(&amp;dryRun, "dry-run", false, "Show the list of files that will be processed")
}</span>

// initCleanerFlags initializes the code cleaner flags
func initCleanerFlags() <span class="cov1" title="1">{
        rootCmd.PersistentFlags().BoolVar(&amp;cleanEnabled, "clean", false, "enable code cleaning")
        rootCmd.PersistentFlags().BoolVar(&amp;removeComments, "clean-remove-comments", true, "remove comments during cleaning")
        rootCmd.PersistentFlags().BoolVar(&amp;preserveDocComments, "clean-preserve-doc-comments", true, "preserve documentation comments")
        rootCmd.PersistentFlags().BoolVar(&amp;removeImports, "clean-remove-imports", false, "remove import statements")
        rootCmd.PersistentFlags().BoolVar(&amp;removeLogging, "clean-remove-logging", true, "remove logging statements")
        rootCmd.PersistentFlags().BoolVar(&amp;removeGettersSetters, "clean-remove-getters-setters", true, "remove getter/setter methods")
        rootCmd.PersistentFlags().BoolVar(&amp;optimizeWhitespace, "clean-optimize-whitespace", true, "optimize whitespace")
        rootCmd.PersistentFlags().BoolVar(&amp;removeEmptyLines, "clean-remove-empty-lines", true, "remove empty lines")
}</span>

// main is the entry point of the application
func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

// runMix implements the main program logic
// In cmd/filefusion/main.go, modify the runMix function:

func runMix(cmd *cobra.Command, args []string) error <span class="cov7" title="22">{
    // Validate pattern first
    if pattern == "" </span><span class="cov1" title="1">{
        return fmt.Errorf("pattern cannot be empty")
    }</span>

    // Add pattern validation
    <span class="cov7" title="21">if err := validatePattern(pattern); err != nil </span><span class="cov1" title="1">{
        return err
    }</span>

    <span class="cov7" title="20">args, err := validateAndGetPaths(args)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov7" title="20">sizeLimits, err := parseSizeLimits()
    if err != nil </span><span class="cov4" title="6">{
        return err
    }</span>

    <span class="cov6" title="14">outputType, err := validateOutputType()
    if err != nil </span><span class="cov2" title="2">{
        return err
    }</span>

    <span class="cov6" title="12">return processInputPaths(args, sizeLimits, outputType)</span>
}

func validatePattern(pattern string) error <span class="cov7" title="21">{
    patterns := strings.Split(pattern, ",")
    for _, p := range patterns </span><span class="cov9" title="55">{
        p = strings.TrimSpace(p)
        if p == "" </span><span class="cov0" title="0">{
            continue</span>
        }
        <span class="cov9" title="55">if _, err := filepath.Match(p, "test"); err != nil </span><span class="cov1" title="1">{
            return fmt.Errorf("syntax error in pattern %q: %w", p, err)
        }</span>
    }
    <span class="cov7" title="20">return nil</span>
}

// validateAndGetPaths validates input paths and returns them
func validateAndGetPaths(args []string) ([]string, error) <span class="cov7" title="20">{
        if len(args) == 0 </span><span class="cov1" title="1">{
                currentDir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get current directory: %w", err)
                }</span>
                <span class="cov1" title="1">args = []string{currentDir}</span>
        }
        <span class="cov7" title="20">return args, nil</span>
}

// parseSizeLimits parses the size limit flags
func parseSizeLimits() (*struct{ maxFile, maxOutput int64 }, error) <span class="cov7" title="20">{
        maxFileSizeBytes, err := parseSize(maxFileSize)
        if err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("invalid max-file-size value: %w", err)
        }</span>

        <span class="cov6" title="17">maxOutputSizeBytes, err := parseSize(maxOutputSize)
        if err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("invalid max-output-size value: %w", err)
        }</span>

        <span class="cov6" title="14">return &amp;struct{ maxFile, maxOutput int64 }{
                maxFile:   maxFileSizeBytes,
                maxOutput: maxOutputSizeBytes,
        }, nil</span>
}

// validateOutputType validates and returns the output type
func validateOutputType() (core.OutputType, error) <span class="cov6" title="14">{
        if outputPath == "" </span><span class="cov3" title="4">{
                return core.OutputTypeXML, nil
        }</span>

        <span class="cov5" title="10">ext := strings.ToLower(filepath.Ext(outputPath))
        switch ext </span>{
        case ".json":<span class="cov2" title="2">
                return core.OutputTypeJSON, nil</span>
        case ".yaml", ".yml":<span class="cov1" title="1">
                return core.OutputTypeYAML, nil</span>
        case ".xml":<span class="cov4" title="5">
                return core.OutputTypeXML, nil</span>
        default:<span class="cov2" title="2">
                return "", fmt.Errorf("invalid output file extension: must be .xml, .json, .yaml, or .yml")</span>
        }
}

// processInputPaths processes each input path
func processInputPaths(args []string, sizes *struct{ maxFile, maxOutput int64 }, outputType core.OutputType) error <span class="cov6" title="12">{
        cleanerOpts := createCleanerOptions()

        for _, inputPath := range args </span><span class="cov6" title="13">{
                if err := processPath(inputPath, sizes, outputType, cleanerOpts); err != nil </span><span class="cov3" title="3">{
                        return err
                }</span>

                <span class="cov5" title="10">if outputPath != "" </span><span class="cov5" title="7">{
                        fmt.Println("Note: Using specified output path. Additional inputs will be ignored.")
                        break</span>
                }
        }

        <span class="cov5" title="9">return nil</span>
}

// createCleanerOptions creates cleaner options if cleaning is enabled
func createCleanerOptions() *cleaner.CleanerOptions <span class="cov6" title="12">{
        if !cleanEnabled </span><span class="cov6" title="12">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;cleaner.CleanerOptions{
                RemoveComments:       removeComments,
                PreserveDocComments:  preserveDocComments,
                RemoveImports:        removeImports,
                RemoveLogging:        removeLogging,
                RemoveGettersSetters: removeGettersSetters,
                OptimizeWhitespace:   optimizeWhitespace,
                RemoveEmptyLines:     removeEmptyLines,
        }</span>
}

// processPath processes a single input path
func processPath(inputPath string, sizes *struct{ maxFile, maxOutput int64 }, outputType core.OutputType, cleanerOpts *cleaner.CleanerOptions) error <span class="cov6" title="13">{
        currentOutputPath := getOutputPath(inputPath)

        options := &amp;core.MixOptions{
                InputPath:      inputPath,
                OutputPath:     currentOutputPath,
                Pattern:        pattern,
                Exclude:        exclude,
                MaxFileSize:    sizes.maxFile,
                MaxOutputSize:  sizes.maxOutput,
                OutputType:     outputType,
                CleanerOptions: cleanerOpts,
        }

        files, totalSize, err := scanFiles(options)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("error processing %s: %w", inputPath, err)
        }</span>

        <span class="cov6" title="12">if err := displaySummary(inputPath, files, totalSize); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="12">if dryRun </span><span class="cov1" title="1">{
                fmt.Println("\nDry run complete. No files will be processed.")
                return nil
        }</span>

        <span class="cov5" title="11">return finalizeProcessing(options, files, totalSize)</span>
}

// getOutputPath determines the output path for the current input
func getOutputPath(inputPath string) string <span class="cov6" title="13">{
        if outputPath != "" </span><span class="cov5" title="8">{
                return outputPath
        }</span>
        <span class="cov4" title="5">return deriveOutputPath(inputPath)</span>
}

// deriveOutputPath generates an output file path based on the input path
func deriveOutputPath(inputPath string) string <span class="cov5" title="11">{
        base := filepath.Base(strings.TrimSuffix(inputPath, string(os.PathSeparator)))
        if ext := filepath.Ext(base); ext != "" </span><span class="cov3" title="3">{
                return base + ".xml"
        }</span>
        <span class="cov5" title="8">return base + ".xml"</span>
}

// displaySummary shows the processing summary
func displaySummary(inputPath string, files []FileInfo, totalSize int64) error <span class="cov6" title="12">{
        fmt.Printf("Processing %s:\n", inputPath)
        fmt.Printf("Found %d files matching pattern\n", len(files))
        if cleanEnabled </span><span class="cov0" title="0">{
                fmt.Printf("Uncompressed size: %s\n", formatSize(totalSize))
                fmt.Printf("Final size (with --clean): will be calculated after processing\n")
        }</span> else<span class="cov6" title="12"> {
                fmt.Printf("Total size: %s\n", formatSize(totalSize))
        }</span>

        <span class="cov6" title="12">fmt.Println("\nMatched files:")
        for _, file := range files </span><span class="cov7" title="22">{
                fmt.Printf("- %s (%s)\n", file.Path, formatSize(file.Size))
        }</span>

        <span class="cov6" title="12">return nil</span>
}

// finalizeProcessing performs the final processing steps
func finalizeProcessing(options *core.MixOptions, files []FileInfo, totalSize int64) error <span class="cov5" title="11">{
        if totalSize &gt; options.MaxOutputSize </span><span class="cov2" title="2">{
                return fmt.Errorf("output size (%s) exceeds maximum allowed size (%s)",
                        formatSize(totalSize), formatSize(options.MaxOutputSize))
        }</span>

        <span class="cov5" title="9">mixer := core.NewMixer(options)
        if err := mixer.Mix(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error mixing %s: %w", options.InputPath, err)
        }</span>

        // Display final size if clean is enabled
        <span class="cov5" title="9">if cleanEnabled </span><span class="cov0" title="0">{
                if info, err := os.Stat(options.OutputPath); err == nil </span><span class="cov0" title="0">{
                        fmt.Printf("\nFinal size (with --clean): %s\n", formatSize(info.Size()))
                }</span>
        }

        <span class="cov5" title="9">return nil</span>
}

// scanFiles discovers and validates files to be processed
func scanFiles(options *core.MixOptions) ([]FileInfo, int64, error) <span class="cov6" title="17">{
        var files []FileInfo
        var totalSize int64

        patterns := strings.Split(options.Pattern, ",")
        for i := range patterns </span><span class="cov8" title="39">{
                patterns[i] = strings.TrimSpace(patterns[i])
        }</span>

        <span class="cov6" title="17">var excludePatterns []string
        if options.Exclude != "" </span><span class="cov1" title="1">{
                excludePatterns = strings.Split(options.Exclude, ",")
                for i := range excludePatterns </span><span class="cov1" title="1">{
                        excludePatterns[i] = strings.TrimSpace(excludePatterns[i])
                }</span>
        }

        <span class="cov6" title="17">err := filepath.Walk(options.InputPath, func(path string, info os.FileInfo, err error) error </span><span class="cov10" title="79">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="79">if info.IsDir() </span><span class="cov7" title="25">{
                        if filepath.Base(path) == ".git" </span><span class="cov3" title="4">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov7" title="21">return nil</span>
                }

                <span class="cov9" title="54">relPath, err := filepath.Rel(options.InputPath, path)
                if err != nil </span><span class="cov0" title="0">{
                        relPath = path
                }</span>

                <span class="cov9" title="54">if shouldIncludeFile(relPath, patterns, excludePatterns, info, options.MaxFileSize) </span><span class="cov8" title="33">{
                        files = append(files, FileInfo{
                                Path: relPath,
                                Size: info.Size(),
                        })
                        totalSize += info.Size()
                }</span>

                <span class="cov9" title="54">return nil</span>
        })

        <span class="cov6" title="17">if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov6" title="17">if len(files) == 0 </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("no files found matching pattern(s) %q (excluding %q) in %s",
                        options.Pattern, options.Exclude, options.InputPath)
        }</span>

        <span class="cov6" title="16">return files, totalSize, nil</span>
}

// shouldIncludeFile determines if a file should be included in processing
func shouldIncludeFile(relPath string, patterns, excludePatterns []string, info os.FileInfo, maxSize int64) bool <span class="cov9" title="54">{
        // Check exclusions first
        for _, pattern := range excludePatterns </span><span class="cov4" title="5">{
                if pattern == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="5">if matchesExcludePattern(pattern, relPath) </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Check size limit
        <span class="cov9" title="53">if info.Size() &gt; maxSize </span><span class="cov5" title="10">{
                return false
        }</span>

        // Check inclusion patterns
        <span class="cov8" title="43">for _, pattern := range patterns </span><span class="cov9" title="59">{
                if pattern == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov9" title="59">match, err := filepath.Match(pattern, filepath.Base(relPath))
                if err == nil &amp;&amp; match </span><span class="cov8" title="33">{
                        return true
                }</span>
        }

        <span class="cov5" title="10">return false</span>
}

// matchesExcludePattern checks if a path matches an exclude pattern
func matchesExcludePattern(pattern, path string) bool <span class="cov4" title="5">{
        if strings.Contains(pattern, "**") </span><span class="cov4" title="5">{
                pattern = strings.ReplaceAll(pattern, "**", "*")
                matched, _ := filepath.Match(pattern, path)
                return matched
        }</span>

        <span class="cov0" title="0">matched, _ := filepath.Match(pattern, path)
        return matched</span>
}

// parseSize converts a size string to bytes
func parseSize(size string) (int64, error) <span class="cov8" title="46">{
        size = strings.ToUpper(strings.ReplaceAll(size, " ", ""))
        if size == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("size cannot be empty")
        }</span>

        <span class="cov8" title="46">var multiplier int64 = 1
        var value string

        switch </span>{
        case strings.HasSuffix(size, "TB"):<span class="cov1" title="1">
                multiplier = 1024 * 1024 * 1024 * 1024
                value = strings.TrimSuffix(size, "TB")</span>
        case strings.HasSuffix(size, "GB"):<span class="cov1" title="1">
                multiplier = 1024 * 1024 * 1024
                value = strings.TrimSuffix(size, "GB")</span>
        case strings.HasSuffix(size, "MB"):<span class="cov8" title="37">
                multiplier = 1024 * 1024
                value = strings.TrimSuffix(size, "MB")</span>
        case strings.HasSuffix(size, "KB"):<span class="cov1" title="1">
                multiplier = 1024
                value = strings.TrimSuffix(size, "KB")</span>
        case strings.HasSuffix(size, "B"):<span class="cov2" title="2">
                value = strings.TrimSuffix(size, "B")</span>
        default:<span class="cov3" title="4">
                return 0, fmt.Errorf("invalid size format: must end with B, KB, MB, GB, or TB")</span>
        }

        <span class="cov8" title="42">num, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov2" title="2">{
                return 0, fmt.Errorf("invalid size number: %w", err)
        }</span>

        <span class="cov8" title="40">if num &lt;= 0 </span><span class="cov3" title="3">{
                return 0, fmt.Errorf("size must be a positive number")
        }</span>

        <span class="cov8" title="37">return num * multiplier, nil</span>
}

// formatSize converts bytes to a human-readable string
func formatSize(bytes int64) string <span class="cov8" title="43">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov7" title="25">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov6" title="18">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov6" title="13">{
                div *= unit
                exp++
        }</span>
        <span class="cov6" title="18">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cleaner

import (
        "bytes"
        "fmt"
        "io"
        "strings"

        "github.com/drgsn/filefusion/internal/core/cleaner/handlers"
        sitter "github.com/smacker/go-tree-sitter"
        "github.com/smacker/go-tree-sitter/bash"
        "github.com/smacker/go-tree-sitter/cpp"
        "github.com/smacker/go-tree-sitter/csharp"
        "github.com/smacker/go-tree-sitter/css"
        "github.com/smacker/go-tree-sitter/golang"
        "github.com/smacker/go-tree-sitter/html"
        "github.com/smacker/go-tree-sitter/java"
        "github.com/smacker/go-tree-sitter/javascript"
        "github.com/smacker/go-tree-sitter/kotlin"
        "github.com/smacker/go-tree-sitter/php"
        "github.com/smacker/go-tree-sitter/python"
        "github.com/smacker/go-tree-sitter/ruby"
        "github.com/smacker/go-tree-sitter/sql"
        "github.com/smacker/go-tree-sitter/swift"
        "github.com/smacker/go-tree-sitter/typescript/typescript"
)

// Cleaner represents a code cleaner instance that processes source code
// according to the configured options
type Cleaner struct {
        options  *CleanerOptions
        language Language
        handler  handlers.LanguageHandler
}

// NewCleaner creates a new Cleaner instance with the given options and language
func NewCleaner(lang Language, options *CleanerOptions) (*Cleaner, error) <span class="cov6" title="20">{
        if options == nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("cleaner options cannot be nil")
        }</span>

        <span class="cov6" title="18">_, handler, err := getLanguageAndHandler(lang)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="16">return &amp;Cleaner{
                options:  options,
                language: lang,
                handler:  handler,
        }, nil</span>
}

// getLanguageAndHandler returns the appropriate tree-sitter language parser
// and language handler for the given language
func getLanguageAndHandler(lang Language) (*sitter.Language, handlers.LanguageHandler, error) <span class="cov6" title="25">{
        switch lang </span>{
        case LangGo:<span class="cov6" title="18">
                return golang.GetLanguage(), &amp;handlers.GoHandler{}, nil</span>
        case LangJava:<span class="cov3" title="5">
                return java.GetLanguage(), &amp;handlers.JavaHandler{}, nil</span>
        case LangPython:<span class="cov0" title="0">
                return python.GetLanguage(), &amp;handlers.PythonHandler{}, nil</span>
        case LangSwift:<span class="cov0" title="0">
                return swift.GetLanguage(), &amp;handlers.SwiftHandler{}, nil</span>
        case LangKotlin:<span class="cov0" title="0">
                return kotlin.GetLanguage(), &amp;handlers.KotlinHandler{}, nil</span>
        case LangSQL:<span class="cov0" title="0">
                return sql.GetLanguage(), &amp;handlers.SQLHandler{}, nil</span>
        case LangHTML:<span class="cov0" title="0">
                return html.GetLanguage(), &amp;handlers.HTMLHandler{}, nil</span>
        case LangJavaScript:<span class="cov0" title="0">
                return javascript.GetLanguage(), &amp;handlers.JavaScriptHandler{}, nil</span>
        case LangTypeScript:<span class="cov0" title="0">
                return typescript.GetLanguage(), &amp;handlers.TypeScriptHandler{}, nil</span>
        case LangCSS:<span class="cov0" title="0">
                return css.GetLanguage(), &amp;handlers.CSSHandler{}, nil</span>
        case LangCPP:<span class="cov0" title="0">
                return cpp.GetLanguage(), &amp;handlers.CPPHandler{}, nil</span>
        case LangCSharp:<span class="cov0" title="0">
                return csharp.GetLanguage(), &amp;handlers.CSharpHandler{}, nil</span>
        case LangPHP:<span class="cov0" title="0">
                return php.GetLanguage(), &amp;handlers.PHPHandler{}, nil</span>
        case LangRuby:<span class="cov0" title="0">
                return ruby.GetLanguage(), &amp;handlers.RubyHandler{}, nil</span>
        case LangBash:<span class="cov0" title="0">
                return bash.GetLanguage(), &amp;handlers.BashHandler{}, nil</span>
        default:<span class="cov2" title="2">
                return nil, nil, fmt.Errorf("unsupported language: %s", lang)</span>
        }
}

// Clean processes the input code and returns the cleaned version
func (c *Cleaner) Clean(input []byte) ([]byte, error) <span class="cov4" title="7">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty input")
        }</span>

        // Create a new parser for each Clean call to avoid concurrency issues
        <span class="cov4" title="7">parser := sitter.NewParser()
        language, _, err := getLanguageAndHandler(c.language)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get language handler: %w", err)
        }</span>
        <span class="cov4" title="7">parser.SetLanguage(language)

        tree := parser.Parse(nil, input)
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing error: failed to create syntax tree")
        }</span>
        <span class="cov4" title="7">defer tree.Close()

        root := tree.RootNode()
        if root == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing error: empty syntax tree")
        }</span>

        // Verify the syntax is valid
        <span class="cov4" title="7">if root.HasError() </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("parsing error: invalid syntax")
        }</span>

        <span class="cov4" title="6">output := make([]byte, len(input))
        copy(output, input)

        if err := c.processNode(root, &amp;output); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("processing error: %w", err)
        }</span>

        <span class="cov4" title="6">if c.options.OptimizeWhitespace </span><span class="cov2" title="3">{
                output = c.optimizeWhitespace(output)
        }</span>

        <span class="cov4" title="6">return output, nil</span>
}

// processNode recursively processes a node in the syntax tree
func (c *Cleaner) processNode(node *sitter.Node, content *[]byte) error <span class="cov8" title="91">{
        if !c.shouldProcessNode(node, content) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Process children in reverse order to maintain correct byte offsets
        <span class="cov8" title="91">for i := int(node.NamedChildCount()) - 1; i &gt;= 0; i-- </span><span class="cov8" title="83">{
                child := node.NamedChild(i)
                if err := c.processNode(child, content); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Check if this node should be removed
        <span class="cov8" title="91">shouldRemove := false

        // Process comments
        for _, commentType := range c.handler.GetCommentTypes() </span><span class="cov10" title="177">{
                if node.Type() == commentType &amp;&amp; c.shouldRemoveComment(node, *content) </span><span class="cov3" title="5">{
                        shouldRemove = true
                        break</span>
                }
        }

        // Process logging calls
        <span class="cov8" title="91">if c.options.RemoveLogging &amp;&amp; c.handler.IsLoggingCall(node, *content) </span><span class="cov2" title="2">{
                shouldRemove = true
        }</span>

        // Process getters/setters
        <span class="cov8" title="91">if c.options.RemoveGettersSetters &amp;&amp; c.handler.IsGetterSetter(node, *content) </span><span class="cov1" title="1">{
                shouldRemove = true
        }</span>

        // Remove the node if necessary
        <span class="cov8" title="91">if shouldRemove </span><span class="cov4" title="8">{
                *content = c.removeNode(node, *content)
        }</span>

        <span class="cov8" title="91">return nil</span>
}

// shouldProcessNode determines if a node should be processed based on its type
// and position in the syntax tree
func (c *Cleaner) shouldProcessNode(node *sitter.Node, content *[]byte) bool <span class="cov8" title="91">{
        // Skip processing for nil nodes or empty content
        if node == nil || len(*content) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Skip processing for nodes outside content bounds
        <span class="cov8" title="91">if node.StartByte() &gt;= uint32(len(*content)) || node.EndByte() &gt; uint32(len(*content)) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="91">return true</span>
}

// shouldRemoveComment determines if a comment should be removed based on
// the cleaner options and whether it's a documentation comment
func (c *Cleaner) shouldRemoveComment(node *sitter.Node, content []byte) bool <span class="cov4" title="9">{
        if !c.options.RemoveComments </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov4" title="8">if c.options.PreserveDocComments </span><span class="cov2" title="3">{
                commentText := content[node.StartByte():node.EndByte()]
                docPrefix := c.handler.GetDocCommentPrefix()

                // Handle both byte slices and string prefixes
                if bytes.HasPrefix(bytes.TrimSpace(commentText), []byte(docPrefix)) </span><span class="cov1" title="1">{
                        return false
                }</span>

                // Special handling for single-line comments in Go
                <span class="cov2" title="2">if bytes.HasPrefix(bytes.TrimSpace(commentText), []byte("// ")) </span><span class="cov2" title="2">{
                        text := string(bytes.TrimSpace(commentText))
                        if strings.HasPrefix(text, "// Doc ") </span><span class="cov1" title="1">{
                                return false
                        }</span>
                }
        }

        <span class="cov4" title="6">return true</span>
}

// removeNode removes a node from the content while preserving the surrounding
// content
func (c *Cleaner) removeNode(node *sitter.Node, content []byte) []byte <span class="cov4" title="8">{
        // Get the start and end of the line containing the node
        start := node.StartByte()
        end := node.EndByte()

        // Find start of line
        lineStart := int(start)
        for lineStart &gt; 0 &amp;&amp; content[lineStart-1] != '\n' </span><span class="cov3" title="4">{
                lineStart--
        }</span>

        // Find end of line
        <span class="cov4" title="8">lineEnd := int(end)
        for lineEnd &lt; len(content) &amp;&amp; content[lineEnd] != '\n' </span><span class="cov2" title="2">{
                lineEnd++
        }</span>

        // If the line contains only this node (plus whitespace), remove the entire line
        <span class="cov4" title="8">line := bytes.TrimSpace(content[lineStart:lineEnd])
        nodeContent := bytes.TrimSpace(content[start:end])
        if bytes.Equal(line, nodeContent) </span><span class="cov4" title="6">{
                return append(content[:lineStart], content[lineEnd:]...)
        }</span>

        // Otherwise just remove the node itself
        <span class="cov2" title="2">return append(content[:start], content[end:]...)</span>
}

// optimizeWhitespace removes excess whitespace and optionally empty lines
// from the content
func (c *Cleaner) optimizeWhitespace(content []byte) []byte <span class="cov2" title="3">{
        if !c.options.OptimizeWhitespace </span><span class="cov0" title="0">{
                return content
        }</span>

        <span class="cov2" title="3">lines := bytes.Split(content, []byte("\n"))
        var result [][]byte
        var previousLineEmpty bool

        for i := range lines </span><span class="cov5" title="17">{
                line := bytes.TrimRight(lines[i], " \t")
                isEmpty := len(bytes.TrimSpace(line)) == 0

                if !isEmpty || (!c.options.RemoveEmptyLines &amp;&amp; !previousLineEmpty) </span><span class="cov4" title="7">{
                        result = append(result, line)
                }</span>
                <span class="cov5" title="17">previousLineEmpty = isEmpty</span>
        }

        <span class="cov2" title="3">return append(bytes.Join(result, []byte("\n")), '\n')</span>
}

// CleanFile processes a file and writes the cleaned content to the writer
func (c *Cleaner) CleanFile(r io.Reader, w io.Writer) error <span class="cov2" title="2">{
        input, err := io.ReadAll(r)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("reading error: %w", err)
        }</span>

        <span class="cov1" title="1">cleaned, err := c.Clean(input)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">_, err = w.Write(cleaned)
        return err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
)

// LanguageHandler defines the interface for language-specific processing
type LanguageHandler interface {
        GetCommentTypes() []string
        GetImportTypes() []string
        GetDocCommentPrefix() string
        IsLoggingCall(node *sitter.Node, content []byte) bool
        IsGetterSetter(node *sitter.Node, content []byte) bool
}

// BaseHandler provides common functionality for all language handlers
type BaseHandler struct{}

// IsMethodNamed checks if a node represents a method/function with the given prefix
func (h *BaseHandler) IsMethodNamed(node *sitter.Node, content []byte, prefix string) bool <span class="cov4" title="4">{
        if node.Type() != "method_declaration" &amp;&amp;
                node.Type() != "function_declaration" &amp;&amp;
                node.Type() != "getter_declaration" &amp;&amp;
                node.Type() != "method_definition" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="4">nameNode := node.ChildByFieldName("name")
        if nameNode == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="4">name := string(content[nameNode.StartByte():nameNode.EndByte()])
        return strings.HasPrefix(strings.ToLower(name), strings.ToLower(prefix))</span>
}

func stringSliceEqual(a, b []string) bool <span class="cov8" title="21">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="21">for i, v := range a </span><span class="cov10" title="43">{
                if v != b[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="21">return true</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
)

type BashHandler struct {
        BaseHandler
}

func (h *BashHandler) GetCommentTypes() []string <span class="cov1" title="1">{
        return []string{"comment"}
}</span>

func (h *BashHandler) GetImportTypes() []string <span class="cov1" title="1">{
        return []string{"source_command", "command"}
}</span>

func (h *BashHandler) GetDocCommentPrefix() string <span class="cov1" title="1">{
        return "#"
}</span>

func (h *BashHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov10" title="6">{
        if node == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov10" title="6">nodeType := node.Type()
        if nodeType == "redirected_statement" </span><span class="cov1" title="1">{
                // If it's a redirected statement, it's a logging call
                return true
        }</span>

        <span class="cov9" title="5">if nodeType != "command" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Get the full command text for other checks
        <span class="cov9" title="5">if node.StartByte() &gt;= uint32(len(content)) || node.EndByte() &gt; uint32(len(content)) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov9" title="5">cmdText := string(content[node.StartByte():node.EndByte()])

        // Check for logging commands
        return strings.Contains(cmdText, "logger") ||
                strings.Contains(cmdText, "echo \"Debug") ||
                strings.Contains(cmdText, "printf \"Debug")</span>
}

func (h *BashHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov1" title="1">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "bytes"
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
)

type CPPHandler struct {
        BaseHandler
}

func (h *CPPHandler) GetCommentTypes() []string <span class="cov1" title="1">{
        return []string{"comment", "multiline_comment"}
}</span>

func (h *CPPHandler) GetImportTypes() []string <span class="cov1" title="1">{
        return []string{"preproc_include", "using_declaration"}
}</span>

func (h *CPPHandler) GetDocCommentPrefix() string <span class="cov1" title="1">{
        return "///"
}</span>

func (h *CPPHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov10" title="7">{
        if node == nil || (node.Type() != "call_expression" &amp;&amp; node.Type() != "binary_expression") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov10" title="7">if node.StartByte() &gt;= uint32(len(content)) || node.EndByte() &gt; uint32(len(content)) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov10" title="7">callText := content[node.StartByte():node.EndByte()]
        return bytes.Contains(callText, []byte("cout")) ||
                bytes.Contains(callText, []byte("cerr")) ||
                bytes.Contains(callText, []byte("clog")) ||
                bytes.Contains(callText, []byte("printf")) ||
                bytes.Contains(callText, []byte("fprintf")) ||
                bytes.Contains(callText, []byte("log"))</span>
}

func (h *CPPHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov8" title="5">{
        if node == nil || (node.Type() != "function_definition" &amp;&amp; node.Type() != "function_declarator") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="5">if node.StartByte() &gt;= uint32(len(content)) || node.EndByte() &gt; uint32(len(content)) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="5">funcText := string(content[node.StartByte():node.EndByte()])

        isGetter := (strings.Contains(strings.ToLower(funcText), "get") &amp;&amp; !strings.Contains(strings.ToLower(funcText), "getvalue")) ||
                (strings.Contains(strings.ToLower(funcText), "is") &amp;&amp; !strings.Contains(strings.ToLower(funcText), "isvalue"))
        isSetter := strings.Contains(funcText, "set") ||
                strings.Contains(funcText, "Set")

        if isGetter </span><span class="cov4" title="2">{
                return !strings.Contains(funcText, "void") &amp;&amp;
                        strings.Count(funcText, ",") == 0
        }</span>
        <span class="cov6" title="3">if isSetter </span><span class="cov1" title="1">{
                return strings.Contains(funcText, "void") &amp;&amp;
                        strings.Count(funcText, ",") &lt;= 1
        }</span>
        <span class="cov4" title="2">return false</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "bytes"
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
)

// CSharpHandler handles C# language specifics
type CSharpHandler struct {
        BaseHandler
}

func (h *CSharpHandler) GetCommentTypes() []string <span class="cov0" title="0">{
        return []string{"comment", "multiline_comment"}
}</span>

func (h *CSharpHandler) GetImportTypes() []string <span class="cov0" title="0">{
        return []string{"using_directive"}
}</span>

func (h *CSharpHandler) GetDocCommentPrefix() string <span class="cov0" title="0">{
        return "///"
}</span>

func (h *CSharpHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov0" title="0">{
        if node.Type() != "invocation_expression" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">callText := content[node.StartByte():node.EndByte()]
        return bytes.Contains(callText, []byte("Console.")) ||
                bytes.Contains(callText, []byte("Debug.")) ||
                bytes.Contains(callText, []byte("Logger.")) ||
                bytes.Contains(callText, []byte("Trace."))</span>
}

func (h *CSharpHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov0" title="0">{
        if node.Type() != "property_declaration" &amp;&amp; node.Type() != "method_declaration" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">methodText := string(content[node.StartByte():node.EndByte()])

        // Check for auto-implemented properties
        if strings.Contains(methodText, "{ get;") || strings.Contains(methodText, "{ set;") </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check for traditional getter/setter methods
        <span class="cov0" title="0">if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                name := string(content[nameNode.StartByte():nameNode.EndByte()])
                return strings.HasPrefix(name, "Get") || strings.HasPrefix(name, "Set")
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        sitter "github.com/smacker/go-tree-sitter"
)

// CSSHandler handles CSS language specifics
type CSSHandler struct {
        BaseHandler
}

func (h *CSSHandler) GetCommentTypes() []string <span class="cov0" title="0">{
        return []string{"comment"}
}</span>

func (h *CSSHandler) GetImportTypes() []string <span class="cov0" title="0">{
        // @import rules are CSS imports
        return []string{"import_statement", "@import"}
}</span>

func (h *CSSHandler) GetDocCommentPrefix() string <span class="cov0" title="0">{
        return "/*"
}</span>

func (h *CSSHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov0" title="0">{
        // CSS doesn't have logging calls
        return false
}</span>

func (h *CSSHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov0" title="0">{
        // CSS doesn't have getters/setters
        return false
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "bytes"
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
)

// GoHandler handles Go language specifics
type GoHandler struct {
        BaseHandler
}

func (h *GoHandler) GetCommentTypes() []string <span class="cov1" title="1">{
        return []string{"comment"}
}</span>

func (h *GoHandler) GetImportTypes() []string <span class="cov1" title="1">{
        return []string{"import_declaration", "import_spec"}
}</span>

func (h *GoHandler) GetDocCommentPrefix() string <span class="cov1" title="1">{
        return "///"
}</span>

func (h *GoHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov4" title="2">{
        if node.Type() != "call_expression" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="2">callText := content[node.StartByte():node.EndByte()]
        return bytes.Contains(callText, []byte("log.")) ||
                bytes.Contains(callText, []byte("logger.")) ||
                bytes.Contains(callText, []byte("Debug(")) ||
                bytes.Contains(callText, []byte(".Print"))</span>
}

func (h *GoHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov10" title="5">{
        if node.Type() != "function_declaration" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Get function name
        <span class="cov10" title="5">nameNode := node.ChildByFieldName("name")
        if nameNode == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov10" title="5">name := string(content[nameNode.StartByte():nameNode.EndByte()])
        return strings.HasPrefix(strings.ToLower(name), "get") ||
                strings.HasPrefix(strings.ToLower(name), "set")</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        sitter "github.com/smacker/go-tree-sitter"
)

// HTMLHandler handles HTML language specifics
type HTMLHandler struct {
        BaseHandler
}

func (h *HTMLHandler) GetCommentTypes() []string <span class="cov1" title="1">{
        return []string{"comment"}
}</span>

func (h *HTMLHandler) GetImportTypes() []string <span class="cov1" title="1">{
        // Consider &lt;link&gt; and &lt;script&gt; tags as imports
        return []string{"link_element", "script_element"}
}</span>

func (h *HTMLHandler) GetDocCommentPrefix() string <span class="cov1" title="1">{
        return "&lt;!--"
}</span>

func (h *HTMLHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov10" title="5">{
        // HTML doesn't have traditional logging calls
        return false
}</span>

func (h *HTMLHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov10" title="5">{
        // HTML doesn't have getters/setters
        return false
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "bytes"
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
)

// JavaHandler handles Java language specifics
type JavaHandler struct {
        BaseHandler
}

func (h *JavaHandler) GetCommentTypes() []string <span class="cov1" title="1">{
        return []string{"line_comment", "block_comment", "javadoc_comment"}
}</span>

func (h *JavaHandler) GetImportTypes() []string <span class="cov1" title="1">{
        return []string{"import_declaration"}
}</span>

func (h *JavaHandler) GetDocCommentPrefix() string <span class="cov1" title="1">{
        return "/**"
}</span>

func (h *JavaHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov6" title="8">{
        // For Java, we need to check both method invocations and the qualifier
        nodeType := node.Type()
        if nodeType != "method_invocation" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Get the method identifier
        <span class="cov6" title="8">callText := content[node.StartByte():node.EndByte()]

        // Check if it's a logging call
        loggingPatterns := []string{
                "Logger",
                "System.out",
                "System.err",
                "log.",
                "logger.",
        }

        for _, pattern := range loggingPatterns </span><span class="cov10" title="26">{
                if bytes.Contains(callText, []byte(pattern)) </span><span class="cov5" title="6">{
                        return true
                }</span>
        }

        <span class="cov2" title="2">return false</span>
}

func (h *JavaHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov7" title="11">{
        if node.Type() != "method_declaration" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov7" title="11">methodText := string(content[node.StartByte():node.EndByte()])

        // Get the method name
        nameNode := node.ChildByFieldName("name")
        if nameNode == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov7" title="11">name := string(content[nameNode.StartByte():nameNode.EndByte()])
        nameLower := strings.ToLower(name)

        // Check for getter pattern (including boolean getters with 'is' prefix)
        isGetter := (strings.HasPrefix(nameLower, "get") || strings.HasPrefix(nameLower, "is")) &amp;&amp;
                strings.Contains(methodText, "return")

        // Check for setter pattern
        isSetter := strings.HasPrefix(nameLower, "set") &amp;&amp;
                strings.Contains(methodText, "void")

        return isGetter || isSetter</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "bytes"
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
)

// JavaScriptHandler handles JavaScript language specifics
type JavaScriptHandler struct {
        BaseHandler
}

func (h *JavaScriptHandler) GetCommentTypes() []string <span class="cov1" title="1">{
        return []string{"comment", "multiline_comment"}
}</span>

func (h *JavaScriptHandler) GetImportTypes() []string <span class="cov8" title="3">{
        return []string{"import_statement", "import_specifier"}
}</span>

func (h *JavaScriptHandler) GetDocCommentPrefix() string <span class="cov1" title="1">{
        return "/**"
}</span>

func (h *JavaScriptHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov10" title="4">{
        if node.Type() != "call_expression" </span><span class="cov5" title="2">{
                return false
        }</span>
        <span class="cov5" title="2">callText := content[node.StartByte():node.EndByte()]
        return bytes.HasPrefix(callText, []byte("console.")) ||
                bytes.HasPrefix(callText, []byte("logger."))</span>
}

func (h *JavaScriptHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov10" title="4">{
        nodeType := node.Type()
        if nodeType != "method_definition" &amp;&amp;
                nodeType != "getter_declaration" &amp;&amp;
                nodeType != "setter_declaration" </span><span class="cov5" title="2">{
                return false
        }</span>

        <span class="cov5" title="2">methodText := string(content[node.StartByte():node.EndByte()])
        return strings.HasPrefix(methodText, "get ") ||
                strings.HasPrefix(methodText, "set ") ||
                nodeType == "getter_declaration" ||
                nodeType == "setter_declaration"</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "bytes"
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
)

type KotlinHandler struct {
        BaseHandler
}

func (h *KotlinHandler) GetCommentTypes() []string <span class="cov1" title="1">{
        return []string{"comment", "multiline_comment", "kdoc"}
}</span>

func (h *KotlinHandler) GetImportTypes() []string <span class="cov1" title="1">{
        return []string{"import_header"}
}</span>

func (h *KotlinHandler) GetDocCommentPrefix() string <span class="cov1" title="1">{
        return "/**"
}</span>

func (h *KotlinHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov8" title="13">{
        if node == nil || node.Type() != "call_expression" </span><span class="cov4" title="3">{
                return false
        }</span>

        <span class="cov7" title="10">if node.StartByte() &gt;= uint32(len(content)) || node.EndByte() &gt; uint32(len(content)) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov7" title="10">callText := content[node.StartByte():node.EndByte()]
        return bytes.Contains(bytes.ToLower(callText), []byte("println(")) ||
                bytes.Contains(bytes.ToLower(callText), []byte("print(")) ||
                bytes.Contains(callText, []byte("Logger.")) ||
                bytes.Contains(callText, []byte("logger.")) ||
                bytes.Contains(callText, []byte("log."))</span>
}

// findFirstChild recursively searches for a child node of the specified type
func findFirstChild(node *sitter.Node, nodeType string) *sitter.Node <span class="cov10" title="21">{
        if node == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov9" title="20">if node.Type() == nodeType </span><span class="cov3" title="2">{
                return node
        }</span>
        <span class="cov9" title="18">for i := 0; i &lt; int(node.NamedChildCount()); i++ </span><span class="cov9" title="16">{
                if found := findFirstChild(node.NamedChild(i), nodeType); found != nil </span><span class="cov7" title="8">{
                        return found
                }</span>
        }
        <span class="cov7" title="10">return nil</span>
}

func (h *KotlinHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov8" title="13">{
        if node == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // If we get a source_file, we need to check its children
        <span class="cov8" title="12">if node.Type() == "source_file" </span><span class="cov3" title="2">{
                // First, look for property_declaration
                var propertyFound bool
                for i := 0; i &lt; int(node.NamedChildCount()); i++ </span><span class="cov1" title="1">{
                        child := node.NamedChild(i)
                        if child.Type() == "property_declaration" </span><span class="cov0" title="0">{
                                propertyFound = true
                                break</span>
                        }
                }

                // If we found a property, check for getter/setter siblings
                <span class="cov3" title="2">if propertyFound </span><span class="cov0" title="0">{
                        for i := 0; i &lt; int(node.NamedChildCount()); i++ </span><span class="cov0" title="0">{
                                child := node.NamedChild(i)
                                if child.Type() == "getter" || child.Type() == "setter" </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }

                // Check for getter/setter functions
                <span class="cov3" title="2">for i := 0; i &lt; int(node.NamedChildCount()); i++ </span><span class="cov1" title="1">{
                        child := node.NamedChild(i)
                        if child.Type() == "function_declaration" </span><span class="cov0" title="0">{
                                // Find the simple_identifier node which contains the function name
                                for j := 0; j &lt; int(child.NamedChildCount()); j++ </span><span class="cov0" title="0">{
                                        nameNode := child.NamedChild(j)
                                        if nameNode.Type() == "simple_identifier" </span><span class="cov0" title="0">{
                                                name := string(content[nameNode.StartByte():nameNode.EndByte()])
                                                if strings.HasPrefix(strings.ToLower(name), "get") || strings.HasPrefix(strings.ToLower(name), "set") </span><span class="cov0" title="0">{
                                                        return true
                                                }</span>
                                                <span class="cov0" title="0">break</span> // Found the name node, no need to continue
                                        }
                                }
                        }
                }
                <span class="cov3" title="2">return false</span>
        }

        <span class="cov7" title="10">switch node.Type() </span>{
        case "property_declaration":<span class="cov6" title="7">
                // For property declarations, check siblings for getter/setter
                if parent := node.Parent(); parent != nil </span><span class="cov6" title="7">{
                        for i := 0; i &lt; int(parent.NamedChildCount()); i++ </span><span class="cov9" title="15">{
                                child := parent.NamedChild(i)
                                if child.Type() == "getter" || child.Type() == "setter" </span><span class="cov6" title="7">{
                                        return true
                                }</span>
                        }
                }
        case "getter", "setter":<span class="cov0" title="0">
                return true</span>
        case "function_declaration":<span class="cov4" title="3">
                // Find the simple_identifier node which contains the function name
                for i := 0; i &lt; int(node.NamedChildCount()); i++ </span><span class="cov4" title="3">{
                        nameNode := node.NamedChild(i)
                        if nameNode.Type() == "simple_identifier" </span><span class="cov4" title="3">{
                                name := string(content[nameNode.StartByte():nameNode.EndByte()])
                                if strings.HasPrefix(strings.ToLower(name), "get") || strings.HasPrefix(strings.ToLower(name), "set") </span><span class="cov3" title="2">{
                                        return true
                                }</span>
                                <span class="cov1" title="1">break</span> // Found the name node, no need to continue
                        }
                }
        }

        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
)

type PHPHandler struct {
        BaseHandler
}

func (h *PHPHandler) GetCommentTypes() []string <span class="cov1" title="1">{
        return []string{"comment", "doc_comment"}
}</span>

func (h *PHPHandler) GetImportTypes() []string <span class="cov1" title="1">{
        return []string{"namespace_use_declaration", "require", "require_once", "include", "include_once"}
}</span>

func (h *PHPHandler) GetDocCommentPrefix() string <span class="cov1" title="1">{
        return "/**"
}</span>

func findNodeOfType(node *sitter.Node, nodeType string) *sitter.Node <span class="cov7" title="3">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov7" title="3">if node.Type() == nodeType </span><span class="cov7" title="3">{
                return node
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; int(node.NamedChildCount()); i++ </span><span class="cov0" title="0">{
                if found := findNodeOfType(node.NamedChild(i), nodeType); found != nil </span><span class="cov0" title="0">{
                        return found
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (h *PHPHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov10" title="5">{
        if node == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Get the function name from the node
        <span class="cov10" title="5">var funcName string
        nodeType := node.Type()

        if nodeType == "function_call_expression" </span><span class="cov8" title="4">{
                nameNode := node.ChildByFieldName("function")
                if nameNode != nil &amp;&amp; nameNode.StartByte() &lt; uint32(len(content)) &amp;&amp; nameNode.EndByte() &lt;= uint32(len(content)) </span><span class="cov8" title="4">{
                        funcName = string(content[nameNode.StartByte():nameNode.EndByte()])
                }</span>
        } else<span class="cov1" title="1"> if nodeType == "echo_statement" </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov8" title="4">if funcName == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for logging function names
        <span class="cov8" title="4">return funcName == "error_log" ||
                funcName == "print_r" ||
                funcName == "var_dump"</span>
}

func (h *PHPHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov7" title="3">{
        if node == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov7" title="3">methodNode := findNodeOfType(node, "method_declaration")
        if methodNode == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov7" title="3">if methodNode.StartByte() &gt;= uint32(len(content)) || methodNode.EndByte() &gt; uint32(len(content)) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov7" title="3">methodText := string(content[methodNode.StartByte():methodNode.EndByte()])
        return strings.Contains(methodText, "public function get") ||
                strings.Contains(methodText, "public function set")</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "bytes"
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
)

type PythonHandler struct {
        BaseHandler
}

func (h *PythonHandler) GetCommentTypes() []string <span class="cov1" title="1">{
        return []string{"comment"}
}</span>

func (h *PythonHandler) GetImportTypes() []string <span class="cov1" title="1">{
        return []string{"import_statement", "import_from_statement"}
}</span>

func (h *PythonHandler) GetDocCommentPrefix() string <span class="cov1" title="1">{
        return "\"\"\""
}</span>

func (h *PythonHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov9" title="12">{
        if node == nil || node.Type() != "call" </span><span class="cov3" title="2">{
                return false
        }</span>
        <span class="cov8" title="10">if node.StartByte() &gt;= uint32(len(content)) || node.EndByte() &gt; uint32(len(content)) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="10">callText := content[node.StartByte():node.EndByte()]
        return bytes.HasPrefix(callText, []byte("print(")) ||
                bytes.HasPrefix(callText, []byte("logging.")) ||
                bytes.HasPrefix(callText, []byte("logger."))</span>
}

func (h *PythonHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov10" title="15">{
        if node == nil || node.Type() != "function_definition" </span><span class="cov4" title="3">{
                return false
        }</span>
        <span class="cov9" title="12">if node.StartByte() &gt;= uint32(len(content)) || node.EndByte() &gt; uint32(len(content)) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for property decorator
        <span class="cov9" title="12">parent := node.Parent()
        if parent != nil </span><span class="cov9" title="12">{
                parentText := string(content[parent.StartByte():parent.EndByte()])
                if strings.Contains(parentText, "@property") </span><span class="cov3" title="2">{
                        return true
                }</span>
        }

        <span class="cov8" title="10">nameNode := node.ChildByFieldName("name")
        if nameNode == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="10">name := string(content[nameNode.StartByte():nameNode.EndByte()])
        return strings.HasPrefix(name, "get_") ||
                strings.HasPrefix(name, "set_")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "bytes"
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
)

// RubyHandler handles Ruby language specifics
type RubyHandler struct {
        BaseHandler
}

func (h *RubyHandler) GetCommentTypes() []string <span class="cov1" title="1">{
        return []string{"comment"}
}</span>

func (h *RubyHandler) GetImportTypes() []string <span class="cov1" title="1">{
        return []string{"require", "include", "require_relative"}
}</span>

func (h *RubyHandler) GetDocCommentPrefix() string <span class="cov1" title="1">{
        return "#"
}</span>

func (h *RubyHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov9" title="10">{
        if node == nil || len(content) == 0 </span><span class="cov3" title="2">{
                return false
        }</span>

        <span class="cov8" title="8">nodeType := node.Type()
        if nodeType != "call" &amp;&amp; nodeType != "method_call" &amp;&amp; nodeType != "command" </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov8" title="7">callText := content[node.StartByte():node.EndByte()]
        return bytes.HasPrefix(callText, []byte("puts ")) ||
                bytes.HasPrefix(callText, []byte("print ")) ||
                bytes.HasPrefix(callText, []byte("p ")) ||
                bytes.Contains(callText, []byte("logger."))</span>
}

func (h *RubyHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov10" title="12">{
        if node == nil || len(content) == 0 </span><span class="cov3" title="2">{
                return false
        }</span>

        <span class="cov9" title="10">nodeType := node.Type()
        if nodeType != "call" &amp;&amp; nodeType != "method" &amp;&amp; nodeType != "method_definition" </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov8" title="9">methodText := string(content[node.StartByte():node.EndByte()])
        return strings.Contains(methodText, "attr_reader") ||
                strings.Contains(methodText, "attr_writer") ||
                strings.Contains(methodText, "attr_accessor") ||
                strings.HasPrefix(methodText, "def get_") ||
                strings.HasPrefix(methodText, "def set_")</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
    sitter "github.com/smacker/go-tree-sitter"
)

// SQLHandler handles SQL language specifics
type SQLHandler struct {
    BaseHandler
}

func (h *SQLHandler) GetCommentTypes() []string <span class="cov1" title="1">{
    return []string{"comment", "block_comment"}
}</span>

func (h *SQLHandler) GetImportTypes() []string <span class="cov1" title="1">{
    // SQL doesn't have traditional imports, but we can consider these statements
    return []string{"create_extension_statement", "use_statement"}
}</span>

func (h *SQLHandler) GetDocCommentPrefix() string <span class="cov1" title="1">{
    return "--"
}</span>

func (h *SQLHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov10" title="6">{
    // SQL doesn't have traditional logging calls
    return false
}</span>

func (h *SQLHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov10" title="6">{
    // SQL doesn't have traditional getters/setters
    return false
}</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "bytes"
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
)

// SwiftHandler handles Swift language specifics
type SwiftHandler struct {
        BaseHandler
}

func (h *SwiftHandler) GetCommentTypes() []string <span class="cov1" title="1">{
        return []string{"comment", "multiline_comment", "documentation_comment"}
}</span>

func (h *SwiftHandler) GetImportTypes() []string <span class="cov1" title="1">{
        return []string{"import_declaration"}
}</span>

func (h *SwiftHandler) GetDocCommentPrefix() string <span class="cov1" title="1">{
        return "///"
}</span>

func (h *SwiftHandler) IsLoggingCall(node *sitter.Node, content []byte) bool <span class="cov10" title="6">{
        if node.Type() != "call_expression" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov10" title="6">callText := content[node.StartByte():node.EndByte()]
        return bytes.HasPrefix(callText, []byte("print(")) ||
                bytes.HasPrefix(callText, []byte("debugPrint(")) ||
                bytes.HasPrefix(callText, []byte("NSLog(")) ||
                bytes.Contains(callText, []byte("logger."))</span>
}

func (h *SwiftHandler) IsGetterSetter(node *sitter.Node, content []byte) bool <span class="cov6" title="3">{
        nodeType := node.Type()

        // For variable declarations or getter/setter specifiers
        if nodeType == "variable_declaration" || nodeType == "getter_specifier" || nodeType == "setter_specifier" </span><span class="cov4" title="2">{
                // Look for getter and setter declarations in the node's children
                var findAccessor func(*sitter.Node) bool
                findAccessor = func(n *sitter.Node) bool </span><span class="cov4" title="2">{
                        if n == nil </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        // Check if this node is a getter or setter
                        <span class="cov4" title="2">nType := n.Type()
                        if nType == "getter_specifier" || nType == "setter_specifier" </span><span class="cov4" title="2">{
                                return true
                        }</span>

                        // Check children
                        <span class="cov0" title="0">for i := 0; i &lt; int(n.NamedChildCount()); i++ </span><span class="cov0" title="0">{
                                if findAccessor(n.NamedChild(i)) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                        <span class="cov0" title="0">return false</span>
                }

                <span class="cov4" title="2">return findAccessor(node)</span>
        }

        // For function declarations, check if they look like getters/setters
        <span class="cov1" title="1">if nodeType == "function_declaration" </span><span class="cov1" title="1">{
                funcText := string(content[node.StartByte():node.EndByte()])
                funcName := ""

                // Find the function name
                for i := 0; i &lt; int(node.NamedChildCount()); i++ </span><span class="cov1" title="1">{
                        child := node.NamedChild(i)
                        if child.Type() == "simple_identifier" </span><span class="cov1" title="1">{
                                funcName = string(content[child.StartByte():child.EndByte()])
                                break</span>
                        }
                }

                // Check if it's a getter/setter
                <span class="cov1" title="1">return (strings.HasPrefix(funcName, "get") &amp;&amp; strings.Contains(funcText, "return")) ||
                        (strings.HasPrefix(funcName, "set") &amp;&amp; strings.Contains(funcText, "="))</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

// TypeScriptHandler extends JavaScript handler functionality
type TypeScriptHandler struct {
        JavaScriptHandler
}

func (h *TypeScriptHandler) GetImportTypes() []string <span class="cov8" title="1">{
        baseTypes := h.JavaScriptHandler.GetImportTypes()
        return append(baseTypes, "import_require_clause", "import_alias")
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package cleaner

// CleanerOptions defines the configuration options for the code cleaner
type CleanerOptions struct {
        // RemoveComments determines if comments should be removed
        RemoveComments bool

        // PreserveDocComments determines if documentation comments should be preserved
        PreserveDocComments bool

        // RemoveImports determines if import statements should be removed
        RemoveImports bool

        // RemoveLogging determines if logging statements should be removed
        RemoveLogging bool

        // RemoveGettersSetters determines if getter/setter methods should be removed
        RemoveGettersSetters bool

        // OptimizeWhitespace determines if whitespace should be optimized
        OptimizeWhitespace bool

        // RemoveEmptyLines determines if empty lines should be removed
        RemoveEmptyLines bool

        // LoggingPrefixes defines the prefixes of logging statements to remove
        LoggingPrefixes map[Language][]string
}

// DefaultOptions returns a new CleanerOptions with default settings
func DefaultOptions() *CleanerOptions <span class="cov10" title="8">{
        return &amp;CleanerOptions{
                RemoveComments:       true,
                PreserveDocComments:  true,
                RemoveImports:        false,
                RemoveLogging:        true,
                RemoveGettersSetters: true,
                OptimizeWhitespace:   true,
                RemoveEmptyLines:     true,
                LoggingPrefixes: map[Language][]string{
                        LangGo:         {"log.", "logger."},
                        LangJava:       {"Logger.", "System.out.", "System.err."},
                        LangPython:     {"logging.", "logger.", "print(", "print ("},
                        LangJavaScript: {"console.", "logger."},
                        LangTypeScript: {"console.", "logger."},
                        LangPHP:        {"error_log(", "print_r(", "var_dump("},
                        LangRuby:       {"puts ", "print ", "p ", "logger."},
                        LangCSharp:     {"Console.", "Debug.", "Logger."},
                        LangSwift:      {"print(", "debugPrint(", "NSLog("},
                        LangKotlin:     {"println(", "print(", "Logger."},
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package cleaner

// Language represents supported programming languages
type Language string

const (
        LangGo         Language = "go"
        LangJava       Language = "java"
        LangPython     Language = "python"
        LangSwift      Language = "swift"
        LangKotlin     Language = "kotlin"
        LangSQL        Language = "sql"
        LangHTML       Language = "html"
        LangJavaScript Language = "javascript"
        LangTypeScript Language = "typescript"
        LangCSS        Language = "css"
        LangCPP        Language = "cpp"
        LangCSharp     Language = "csharp"
        LangPHP        Language = "php"
        LangRuby       Language = "ruby"
        LangBash       Language = "bash"
)

// GetSupportedLanguages returns a list of all supported languages
func GetSupportedLanguages() []Language <span class="cov8" title="1">{
        return []Language{
                LangGo, LangJava, LangPython, LangSwift, LangKotlin,
                LangSQL, LangHTML, LangJavaScript, LangTypeScript, LangCSS,
                LangCPP, LangCSharp, LangPHP, LangRuby, LangBash,
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package core

import (
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "strings"
)

// FileFinder is responsible for discovering files that match specified patterns
// while respecting exclusion rules. It handles complex pattern matching including
// glob patterns and directory-specific exclusions.
type FileFinder struct {
        options *MixOptions // Configuration options for file discovery
}

// NewFileFinder creates a new FileFinder instance with the specified options.
//
// Parameters:
//   - options: Configuration settings for file discovery
//
// Returns:
//   - A new FileFinder instance
func NewFileFinder(options *MixOptions) *FileFinder <span class="cov7" title="19">{
        return &amp;FileFinder{options: options}
}</span>

// FindFiles discovers all files in the input directory that match the configured patterns
// while respecting exclusion rules. It uses filepath.WalkDir for efficient directory traversal
// and implements sophisticated pattern matching for both inclusion and exclusion.
//
// The function handles:
// - Multiple inclusion patterns (comma-separated)
// - Multiple exclusion patterns (comma-separated)
// - Special patterns like "**" for recursive matching
// - .git directory exclusion
//
// Returns:
//   - []string: Slice of matched file paths
//   - error: Error if any occurs during file discovery
func (f *FileFinder) FindFiles() ([]string, error) <span class="cov6" title="13">{
        var matches []string

        err := filepath.WalkDir(f.options.InputPath, func(path string, d fs.DirEntry, err error) error </span><span class="cov10" title="79">{
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error accessing path %s: %w", path, err)
                }</span>

                <span class="cov10" title="79">info, err := os.Stat(path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting file info for %s: %w", path, err)
                }</span>

                <span class="cov10" title="79">if info.IsDir() </span><span class="cov7" title="27">{
                        // Skip .git directory entirely
                        if d.Name() == ".git" </span><span class="cov0" title="0">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov7" title="27">return nil</span>
                }

                // Get path relative to input directory for pattern matching
                <span class="cov9" title="52">relPath, err := filepath.Rel(f.options.InputPath, path)
                if err != nil </span><span class="cov0" title="0">{
                        relPath = path // Fallback to full path if relative path fails
                }</span>

                // Check if file matches patterns
                <span class="cov9" title="52">match, err := f.matchesPattern(relPath, filepath.Base(path))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov9" title="52">if match </span><span class="cov6" title="16">{
                        matches = append(matches, path)
                }</span>
                <span class="cov9" title="52">return nil</span>
        })

        <span class="cov6" title="13">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="13">if len(matches) == 0 </span><span class="cov4" title="6">{
                return nil, fmt.Errorf("no files found matching pattern(s) %q (excluding %q) in %s",
                        f.options.Pattern, f.options.Exclude, f.options.InputPath)
        }</span>

        <span class="cov5" title="7">return matches, nil</span>
}

// matchesPattern checks if a file matches the inclusion patterns while not matching
// any exclusion patterns. It implements sophisticated pattern matching including:
// - Glob pattern support
// - Directory-specific exclusions using "**"
// - Both filename and full path matching
//
// Parameters:
//   - path: Full relative path to the file
//   - filename: Base name of the file
//
// Returns:
//   - bool: true if the file should be included, false otherwise
//   - error: Error if pattern matching fails
func (f *FileFinder) matchesPattern(path, filename string) (bool, error) <span class="cov9" title="52">{
    // Pattern syntax is already validated at this point
    if f.options.Exclude != "" </span><span class="cov5" title="7">{
        excludePatterns := strings.Split(f.options.Exclude, ",")
        for _, pattern := range excludePatterns </span><span class="cov6" title="12">{
            pattern = strings.TrimSpace(pattern)
            if pattern == "" </span><span class="cov0" title="0">{
                continue</span>
            }
            
            <span class="cov6" title="12">pattern = filepath.FromSlash(pattern)
            pathToCheck := filepath.FromSlash(path)
            
            if strings.Contains(pattern, "**") </span><span class="cov6" title="12">{
                basePattern := strings.TrimSuffix(pattern, string(filepath.Separator)+"**")
                basePattern = strings.TrimSuffix(basePattern, "**")
                if strings.HasPrefix(pathToCheck, basePattern) </span><span class="cov3" title="3">{
                    return false, nil
                }</span>
            } else<span class="cov0" title="0"> if strings.Contains(pattern, string(filepath.Separator)) </span><span class="cov0" title="0">{
                matched, _ := filepath.Match(pattern, pathToCheck)
                if matched </span><span class="cov0" title="0">{
                    return false, nil
                }</span>
            } else<span class="cov0" title="0"> {
                matched, _ := filepath.Match(pattern, filename)
                if matched </span><span class="cov0" title="0">{
                    return false, nil
                }</span>
            }
        }
    }

    <span class="cov9" title="49">patterns := strings.Split(f.options.Pattern, ",")
    for _, pattern := range patterns </span><span class="cov9" title="55">{
        pattern = strings.TrimSpace(pattern)
        if pattern == "" </span><span class="cov0" title="0">{
            continue</span>
        }
        
        <span class="cov9" title="55">matched, _ := filepath.Match(pattern, filename)
        if matched </span><span class="cov6" title="16">{
            return true, nil
        }</span>
    }
    
    <span class="cov8" title="33">return false, nil</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">package core

import (
        "fmt"
        "path/filepath"
)

// Mixer orchestrates the complete file processing pipeline, coordinating between
// file finding, processing, and output generation components. It implements the main
// business logic for combining multiple files into a single output document.
type Mixer struct {

        // options contains the configuration settings for the mixing process
        options *MixOptions

        // finder handles file discovery based on patterns and exclusions
        finder *FileFinder

        // processor handles reading and processing of individual files
        processor *FileProcessor

        // generator manages output file creation in various formats
        generator *OutputGenerator
}

// NewMixer creates a new Mixer instance with the provided options.
// It initializes all necessary components (finder, processor, and generator)
// but does not validate the options until Mix is called.
//
// Parameters:
//   - options: Configuration settings for the mixing process
//
// Returns:
//   - A new Mixer instance ready for use
func NewMixer(options *MixOptions) *Mixer <span class="cov10" title="10">{
        m := &amp;Mixer{
                options:   options,
                finder:    NewFileFinder(options),
                processor: NewFileProcessor(options),
                generator: NewOutputGenerator(options),
        }
        return m
}</span>

// Mix performs the complete file mixing process in three main steps:
// 1. Finds all files matching the configured patterns
// 2. Processes each file to extract its content
// 3. Generates the final output file in the specified format
//
// The function handles path resolution, including symlinks, and ensures
// all operations are performed safely and in the correct order.
//
// Returns:
//   - error: nil if successful, otherwise an error describing what went wrong
func (m *Mixer) Mix() error <span class="cov3" title="2">{

        // Resolve any symlinks in the input path for consistent handling
        resolvedPath, err := filepath.EvalSymlinks(m.options.InputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error resolving input path: %w", err)
        }</span>
        <span class="cov3" title="2">m.options.InputPath = resolvedPath

        // Find all files matching the configured patterns
        files, err := m.finder.FindFiles()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error finding files: %w", err)
        }</span>

        // Process discovered files to extract their content
        <span class="cov3" title="2">processor := NewFileProcessor(m.options)
        contents, err := processor.ProcessFiles(files)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error processing files: %w", err)
        }</span>

        // Generate the final output file
        <span class="cov3" title="2">if err := m.generator.Generate(contents); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error generating output: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// GetFoundFiles returns the list of files that were found and processed.
// This method is primarily used for testing and verification purposes,
// allowing inspection of which files were discovered without generating output.
//
// Returns:
//   - []FileContent: Slice of processed file contents
//   - error: nil if successful, otherwise an error describing what went wrong
func (m *Mixer) GetFoundFiles() ([]FileContent, error) <span class="cov3" title="2">{
        files, err := m.finder.FindFiles()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">return m.processor.ProcessFiles(files)</span>
}

// ValidateOptions performs comprehensive validation of the mixer configuration.
// It checks all required fields are set and have valid values before any
// processing begins.
//
// The validation includes checking:
// - Input and output paths are specified
// - File pattern is not empty
// - Size limits are positive values
// - Output format is supported
//
// Returns:
//   - error: nil if validation passes, otherwise a MixError describing the issue
func (m *Mixer) ValidateOptions() error <span class="cov10" title="10">{
        if m.options.InputPath == "" </span><span class="cov1" title="1">{
                return &amp;MixError{Message: "input path is required"}
        }</span>

        <span class="cov9" title="9">if m.options.OutputPath == "" </span><span class="cov1" title="1">{
                return &amp;MixError{Message: "output path is required"}
        }</span>

        <span class="cov9" title="8">if m.options.Pattern == "" </span><span class="cov3" title="2">{
                return &amp;MixError{Message: "pattern cannot be empty"}
        }</span>

        <span class="cov8" title="6">if m.options.MaxFileSize &lt;= 0 </span><span class="cov1" title="1">{
                return &amp;MixError{Message: "max file size must be greater than 0"}
        }</span>

        <span class="cov7" title="5">if m.options.MaxOutputSize &lt;= 0 </span><span class="cov1" title="1">{
                return &amp;MixError{Message: "max output size must be greater than 0"}
        }</span>

        <span class="cov6" title="4">switch m.options.OutputType </span>{
        case OutputTypeXML, OutputTypeJSON, OutputTypeYAML:<span class="cov3" title="2"></span>
                // Valid output types
        default:<span class="cov3" title="2">
                return &amp;MixError{Message: fmt.Sprintf("unsupported output type: %s", m.options.OutputType)}</span>
        }

        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package core

import (
        "encoding/json"
        "fmt"
        "os"
        "text/template"

        "gopkg.in/yaml.v3"
)

// OutputGenerator handles the creation of output files in various formats (XML, JSON, YAML).
// It implements safety measures such as:
// - Using temporary files for atomic writes
// - Size limit validation
// - Proper error handling and cleanup
type OutputGenerator struct {
        options *MixOptions // Configuration options for output generation
}

// NewOutputGenerator creates a new OutputGenerator instance with the specified options.
//
// Parameters:
//   - options: Configuration settings for output generation
//
// Returns:
//   - A new OutputGenerator instance
func NewOutputGenerator(options *MixOptions) *OutputGenerator <span class="cov10" title="21">{
        return &amp;OutputGenerator{options: options}
}</span>

// Generate creates an output file containing the provided file contents in the specified format.
// The function implements a safe generation process:
// 1. Creates a temporary file
// 2. Writes content in the specified format
// 3. Validates size constraints
// 4. Atomically moves the file to its final location
//
// Parameters:
//   - contents: Slice of FileContent to include in the output
//
// Returns:
//   - error: nil if successful, otherwise describes what went wrong
func (g *OutputGenerator) Generate(contents []FileContent) error <span class="cov8" title="13">{
        // Create a temporary file for safe writing
        tempFile, err := os.CreateTemp("", "filefusion-*")
        if err != nil </span><span class="cov0" title="0">{
                return &amp;MixError{
                        File:    g.options.OutputPath,
                        Message: fmt.Sprintf("error creating temporary file: %v", err),
                }
        }</span>
        <span class="cov8" title="13">tempPath := tempFile.Name()
        defer os.Remove(tempPath) // Clean up temp file in case of failure

        // Generate content in the specified format
        switch g.options.OutputType </span>{
        case OutputTypeJSON:<span class="cov4" title="3">
                err = g.generateJSON(tempFile, contents)</span>
        case OutputTypeYAML:<span class="cov4" title="3">
                err = g.generateYAML(tempFile, contents)</span>
        case OutputTypeXML:<span class="cov6" title="7">
                err = g.generateXML(tempFile, contents)</span>
        default:<span class="cov0" title="0">
                return &amp;MixError{Message: fmt.Sprintf("unsupported output type: %s", g.options.OutputType)}</span>
        }

        <span class="cov8" title="13">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Close the temp file to ensure all content is written
        <span class="cov8" title="13">tempFile.Close()

        // Check the size of the generated file
        info, err := os.Stat(tempPath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;MixError{Message: fmt.Sprintf("error checking output file size: %v", err)}
        }</span>

        <span class="cov8" title="13">if info.Size() &gt; g.options.MaxOutputSize </span><span class="cov4" title="3">{
                return &amp;MixError{
                        Message: fmt.Sprintf("output size (%d bytes) exceeds maximum allowed size (%d bytes)",
                                info.Size(), g.options.MaxOutputSize),
                }
        }</span>

        // Move temp file to final destination
        <span class="cov7" title="10">return os.Rename(tempPath, g.options.OutputPath)</span>
}

// generateJSON creates a JSON output file with the provided file contents.
// It wraps the contents in a "documents" array and writes it to the specified file.
//
// Parameters:
//   - file: The file to write the JSON output to
//   - contents: Slice of FileContent to include in the output
//
// Returns:
//   - error: nil if successful, otherwise describes what went wrong
func (g *OutputGenerator) generateJSON(file *os.File, contents []FileContent) error <span class="cov4" title="3">{
        // Create wrapper structure for consistent output format
        output := struct {
                Documents []struct {
                        Index           int    `json:"index"`
                        Source          string `json:"source"`
                        DocumentContent string `json:"document_content"`
                } `json:"documents"`
        }{
                Documents: make([]struct {
                        Index           int    `json:"index"`
                        Source          string `json:"source"`
                        DocumentContent string `json:"document_content"`
                }, len(contents)),
        }

        // Fill the structure
        for i, content := range contents </span><span class="cov8" title="12">{
                output.Documents[i] = struct {
                        Index           int    `json:"index"`
                        Source          string `json:"source"`
                        DocumentContent string `json:"document_content"`
                }{
                        Index:           i + 1,
                        Source:          content.Path,
                        DocumentContent: content.Content,
                }
        }</span>

        <span class="cov4" title="3">encoder := json.NewEncoder(file)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(output); err != nil </span><span class="cov0" title="0">{
                return &amp;MixError{Message: fmt.Sprintf("error encoding JSON: %v", err)}
        }</span>
        <span class="cov4" title="3">return nil</span>
}

// generateYAML writes the content in YAML format with proper indentation.
// The output maintains the same structure as JSON for consistency.
//
// Parameters:
//   - file: Open file to write to
//   - output: Interface containing the data to encode
//
// Returns:
//   - error: nil if successful, error if encoding fails
func (g *OutputGenerator) generateYAML(file *os.File, output interface{}) error <span class="cov4" title="3">{
        // Use same structure as JSON for consistency
        docs := struct {
                Documents []struct {
                        Index           int    `yaml:"index"`
                        Source          string `yaml:"source"`
                        DocumentContent string `yaml:"document_content"`
                } `yaml:"documents"`
        }{}

        // Convert the input to []FileContent
        contents, ok := output.([]FileContent)
        if !ok </span><span class="cov0" title="0">{
                return &amp;MixError{Message: "invalid input type for YAML generation"}
        }</span>

        // Fill the structure
        <span class="cov4" title="3">docs.Documents = make([]struct {
                Index           int    `yaml:"index"`
                Source          string `yaml:"source"`
                DocumentContent string `yaml:"document_content"`
        }, len(contents))

        for i, content := range contents </span><span class="cov8" title="12">{
                docs.Documents[i] = struct {
                        Index           int    `yaml:"index"`
                        Source          string `yaml:"source"`
                        DocumentContent string `yaml:"document_content"`
                }{
                        Index:           i + 1,
                        Source:          content.Path,
                        DocumentContent: content.Content,
                }
        }</span>

        <span class="cov4" title="3">encoder := yaml.NewEncoder(file)
        encoder.SetIndent(2)
        if err := encoder.Encode(docs); err != nil </span><span class="cov0" title="0">{
                return &amp;MixError{Message: fmt.Sprintf("error encoding YAML: %v", err)}
        }</span>
        <span class="cov4" title="3">return nil</span>
}

// generateXML writes the content in XML format using a template.
// The output includes proper XML declaration and document structure.
//
// Parameters:
//   - file: Open file to write to
//   - contents: Slice of FileContent to encode
//
// Returns:
//   - error: nil if successful, error if template execution fails
func (g *OutputGenerator) generateXML(file *os.File, contents []FileContent) error <span class="cov6" title="7">{
        const xmlTemplate = `&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;documents&gt;{{range $index, $file := .}}
&lt;document index="{{add $index 1}}"&gt;
&lt;source&gt;{{.Path}}&lt;/source&gt;
&lt;document_content&gt;{{.Content}}&lt;/document_content&gt;
&lt;/document&gt;{{end}}
&lt;/documents&gt;`

        t, err := template.New("llm").Funcs(template.FuncMap{
                "add": func(a, b int) int </span><span class="cov9" title="18">{ return a + b }</span>,
        }).Parse(xmlTemplate)
        <span class="cov6" title="7">if err != nil </span><span class="cov0" title="0">{
                return &amp;MixError{Message: fmt.Sprintf("error parsing template: %v", err)}
        }</span>

        <span class="cov6" title="7">if err := t.Execute(file, contents); err != nil </span><span class="cov0" title="0">{
                return &amp;MixError{Message: fmt.Sprintf("error executing template: %v", err)}
        }</span>
        <span class="cov6" title="7">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package core

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/drgsn/filefusion/internal/core/cleaner"
)

// FileResult represents the outcome of processing a single file.
// It can contain either the processed content or an error, but not both.
type FileResult struct {
        Content FileContent // Processed file content and metadata
        Error   error       // Error that occurred during processing, if any
}

// FileProcessor handles the concurrent processing of multiple files,
// including content cleaning when enabled. It manages a pool of cleaners
// for different languages and ensures proper resource cleanup.
type FileProcessor struct {
        options  *MixOptions
        cleaners map[cleaner.Language]*cleaner.Cleaner
        mu       sync.RWMutex
}

// NewFileProcessor creates a new FileProcessor instance with the specified options.
// It initializes the cleaner map if cleaning is enabled but defers actual cleaner
// creation until needed.
func NewFileProcessor(options *MixOptions) *FileProcessor <span class="cov8" title="20">{
        return &amp;FileProcessor{
                options:  options,
                cleaners: make(map[cleaner.Language]*cleaner.Cleaner),
        }
}</span>

// ProcessFiles processes multiple files concurrently using a worker pool pattern.
// It respects file size limits and handles errors gracefully, continuing to process
// files even if some fail.
//
// Parameters:
//   - paths: Slice of file paths to process
//
// Returns:
//   - []FileContent: Slice of successfully processed file contents
//   - error: First error encountered during processing, if any
func (p *FileProcessor) ProcessFiles(paths []string) ([]FileContent, error) <span class="cov7" title="11">{
        // Use reasonable number of workers
        numWorkers := min(len(paths), 10)
        results := make(chan FileResult, len(paths))
        var wg sync.WaitGroup

        // Create a channel for distributing work
        jobs := make(chan string, len(paths))
        for _, path := range paths </span><span class="cov9" title="32">{
                jobs &lt;- path
        }</span>
        <span class="cov7" title="11">close(jobs)

        // Start worker pool
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov9" title="32">{
                wg.Add(1)
                go func() </span><span class="cov9" title="32">{
                        defer wg.Done()
                        for path := range jobs </span><span class="cov9" title="32">{
                                result := p.processFile(path)
                                results &lt;- result
                        }</span>
                }()
        }

        // Wait for all workers to finish and close results channel
        <span class="cov7" title="11">go func() </span><span class="cov7" title="11">{
                wg.Wait()
                close(results)
        }</span>()

        // Collect results and handle errors
        <span class="cov7" title="11">var contents []FileContent
        var errors []error

        for result := range results </span><span class="cov9" title="32">{
                if result.Error != nil </span><span class="cov2" title="2">{
                        errors = append(errors, result.Error)
                        continue</span>
                }
                <span class="cov9" title="30">if result.Content.Size &gt; 0 </span><span class="cov9" title="27">{
                        contents = append(contents, result.Content)
                }</span>
        }

        // Return the first error encountered, but still return processed files
        <span class="cov7" title="11">var firstError error
        if len(errors) &gt; 0 </span><span class="cov2" title="2">{
                firstError = errors[0]
        }</span>

        <span class="cov7" title="11">return contents, firstError</span>
}

// processFile handles the processing of a single file, including reading,
// cleaning (if enabled), and metadata collection.
func (p *FileProcessor) processFile(path string) FileResult <span class="cov10" title="35">{
        // Get file info and perform initial checks
        info, err := os.Stat(path)
        if err != nil </span><span class="cov1" title="1">{
                return FileResult{
                        Error: &amp;MixError{
                                File:    path,
                                Message: fmt.Sprintf("error getting file info: %v", err),
                        },
                }
        }</span>

        <span class="cov9" title="34">if info.IsDir() </span><span class="cov1" title="1">{
                return FileResult{
                        Error: &amp;MixError{
                                File:    path,
                                Message: "is a directory",
                        },
                }
        }</span>

        // Check size limit
        <span class="cov9" title="33">if info.Size() &gt; p.options.MaxFileSize </span><span class="cov4" title="4">{
                fmt.Fprintf(os.Stderr, "Warning: Skipping %s (size %d bytes exceeds limit %d bytes)\n",
                        path, info.Size(), p.options.MaxFileSize)
                return FileResult{}
        }</span>

        // Read file content
        <span class="cov9" title="29">content, err := os.ReadFile(path)
        if err != nil </span><span class="cov2" title="2">{
                return FileResult{
                        Error: &amp;MixError{
                                File:    path,
                                Message: fmt.Sprintf("error reading file: %v", err),
                        },
                }
        }</span>

        // Clean content if enabled and language is supported
        <span class="cov9" title="27">if p.options.CleanerOptions != nil </span><span class="cov0" title="0">{
                if cleaned, err := p.cleanContent(path, content); err == nil </span><span class="cov0" title="0">{
                        content = cleaned
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(os.Stderr, "Warning: Failed to clean %s: %v\n", path, err)
                }</span>
        }

        // Create relative path
        <span class="cov9" title="27">relPath, err := p.createRelativePath(path)
        if err != nil </span><span class="cov0" title="0">{
                relPath = path
        }</span>

        // Return successful result
        <span class="cov9" title="27">return FileResult{
                Content: FileContent{
                        Path:      filepath.ToSlash(relPath),
                        Name:      filepath.Base(path),
                        Extension: strings.TrimPrefix(filepath.Ext(path), "."),
                        Content:   string(content),
                        Size:      int64(len(content)),
                },
        }</span>
}

// cleanContent attempts to clean the content using the appropriate language cleaner
func (p *FileProcessor) cleanContent(path string, content []byte) ([]byte, error) <span class="cov0" title="0">{
        lang := p.detectLanguage(path)
        if lang == "" </span><span class="cov0" title="0">{
                return content, nil
        }</span>

        <span class="cov0" title="0">c, err := p.getOrCreateCleaner(lang)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return c.Clean(content)</span>
}

// getOrCreateCleaner safely gets or creates a cleaner for the given language
func (p *FileProcessor) getOrCreateCleaner(lang cleaner.Language) (*cleaner.Cleaner, error) <span class="cov0" title="0">{
        // Try to get existing cleaner
        p.mu.RLock()
        c, exists := p.cleaners[lang]
        p.mu.RUnlock()

        if exists </span><span class="cov0" title="0">{
                return c, nil
        }</span>

        // Create new cleaner if needed
        <span class="cov0" title="0">p.mu.Lock()
        defer p.mu.Unlock()

        // Check again in case another goroutine created it
        if c, exists = p.cleaners[lang]; exists </span><span class="cov0" title="0">{
                return c, nil
        }</span>

        // Create new cleaner
        <span class="cov0" title="0">c, err := cleaner.NewCleaner(lang, p.options.CleanerOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">p.cleaners[lang] = c
        return c, nil</span>
}

// createRelativePath creates a path relative to the input directory
func (p *FileProcessor) createRelativePath(path string) (string, error) <span class="cov9" title="27">{
        baseDir := filepath.Clean(p.options.InputPath)
        cleanPath := filepath.Clean(path)

        // Convert both paths to slashes for consistent handling
        baseDir = filepath.ToSlash(baseDir)
        cleanPath = filepath.ToSlash(cleanPath)

        relPath := cleanPath
        if strings.HasPrefix(cleanPath, baseDir) </span><span class="cov9" title="27">{
                relPath = cleanPath[len(baseDir):]
                // Remove leading slash if present
                relPath = strings.TrimPrefix(relPath, "/")
        }</span>

        <span class="cov9" title="27">return relPath, nil</span>
}

// detectLanguage determines the language based on file extension
func (p *FileProcessor) detectLanguage(path string) cleaner.Language <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(path))
        switch ext </span>{
        case ".go":<span class="cov0" title="0">
                return cleaner.LangGo</span>
        case ".java":<span class="cov0" title="0">
                return cleaner.LangJava</span>
        case ".py":<span class="cov0" title="0">
                return cleaner.LangPython</span>
        case ".js":<span class="cov0" title="0">
                return cleaner.LangJavaScript</span>
        case ".ts":<span class="cov0" title="0">
                return cleaner.LangTypeScript</span>
        case ".html":<span class="cov0" title="0">
                return cleaner.LangHTML</span>
        case ".css":<span class="cov0" title="0">
                return cleaner.LangCSS</span>
        case ".cpp", ".cc", ".h":<span class="cov0" title="0">
                return cleaner.LangCPP</span>
        case ".cs":<span class="cov0" title="0">
                return cleaner.LangCSharp</span>
        case ".php":<span class="cov0" title="0">
                return cleaner.LangPHP</span>
        case ".rb":<span class="cov0" title="0">
                return cleaner.LangRuby</span>
        case ".sh", ".bash":<span class="cov0" title="0">
                return cleaner.LangBash</span>
        case ".swift":<span class="cov0" title="0">
                return cleaner.LangSwift</span>
        case ".kt":<span class="cov0" title="0">
                return cleaner.LangKotlin</span>
        case ".sql":<span class="cov0" title="0">
                return cleaner.LangSQL</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// min returns the smaller of two integers.
// This helper function is used to limit the number of concurrent workers.
func min(a, b int) int <span class="cov7" title="11">{
        if a &lt; b </span><span class="cov7" title="11">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package core

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/drgsn/filefusion/internal/core/cleaner"
)

type FileContent struct {
        Path      string `json:"path"`
        Name      string `json:"name"`
        Content   string `json:"content"`
        Extension string `json:"extension"`
        Size      int64  `json:"size"`
}

type OutputType string

const (
        OutputTypeXML  OutputType = "XML"
        OutputTypeJSON OutputType = "JSON"
        OutputTypeYAML OutputType = "YAML"
)

type MixOptions struct {
        InputPath      string
        OutputPath     string
        Pattern        string
        Exclude        string
        MaxFileSize    int64
        MaxOutputSize  int64
        OutputType     OutputType
        CleanerOptions *cleaner.CleanerOptions
}

func validatePattern(pattern string) error <span class="cov0" title="0">{
        if pattern == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("pattern cannot be empty")
        }</span>

        <span class="cov0" title="0">patterns := strings.Split(pattern, ",")
        for _, p := range patterns </span><span class="cov0" title="0">{
                p = strings.TrimSpace(p)
                if p == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Try to match against a test string to verify pattern syntax
                <span class="cov0" title="0">if _, err := filepath.Match(p, "test"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("syntax error in pattern %q: %w", p, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func validateExcludePatterns(exclude string) error <span class="cov0" title="0">{
        if exclude == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">patterns := strings.Split(exclude, ",")
        for _, p := range patterns </span><span class="cov0" title="0">{
                p = strings.TrimSpace(p)
                if p == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip validation for glob patterns with **
                <span class="cov0" title="0">if strings.Contains(p, "**") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Try to match against a test string to verify pattern syntax
                <span class="cov0" title="0">if _, err := filepath.Match(p, "test"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid exclusion pattern %q: %w", p, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *MixOptions) Validate() error <span class="cov0" title="0">{
        if m.InputPath == "" </span><span class="cov0" title="0">{
                return &amp;MixError{Message: "input path is required"}
        }</span>
        <span class="cov0" title="0">if m.OutputPath == "" </span><span class="cov0" title="0">{
                return &amp;MixError{Message: "output path is required"}
        }</span>
        <span class="cov0" title="0">if err := validatePattern(m.Pattern); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := validateExcludePatterns(m.Exclude); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if m.MaxFileSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;MixError{Message: "max file size must be greater than 0"}
        }</span>
        <span class="cov0" title="0">if m.MaxOutputSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;MixError{Message: "max output size must be greater than 0"}
        }</span>
        <span class="cov0" title="0">switch m.OutputType </span>{
        case OutputTypeXML, OutputTypeJSON, OutputTypeYAML:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return &amp;MixError{Message: fmt.Sprintf("unsupported output type: %s", m.OutputType)}</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type MixError struct {
        File    string
        Message string
}

func (e *MixError) Error() string <span class="cov10" title="13">{
        if e.File != "" </span><span class="cov4" title="3">{
                return "file " + e.File + ": " + e.Message
        }</span>
        <span class="cov9" title="10">return e.Message</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
