<?xml version="1.0" encoding="UTF-8"?>
<documents>
<document index="1">
<source>main.go</source>
<document_content>package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/drgsn/filefusion/internal/core"
	"github.com/spf13/cobra"
)

type FileInfo struct {
	Path string `json:"path"`
	Size int64  `json:"size"`
}

var (
	outputPath  string
	pattern     string
	exclude     string
	maxFileSize string
	jsonOutput  bool
)

var rootCmd = &cobra.Command{
	Use:   "filefusion [paths...]",
	Short: "Filefusion - File concatenation tool optimized for LLM usage",
	Long: `Filefusion concatenates files into a format optimized for Large Language Models (LLMs).
It preserves file metadata and structures the output in an XML-like or JSON format.
Complete documentation is available at https://github.com/drgsn/filefusion`,
	RunE: runMix,
}

func init() {
	rootCmd.PersistentFlags().StringVarP(&outputPath, "output", "o", "", "output file path (if not specified, generates files based on input paths)")
	rootCmd.PersistentFlags().StringVarP(&pattern, "pattern", "p", "*.go,*.json,*.yaml,*.yml", "comma-separated file patterns (e.g., '*.go,*.json')")
	rootCmd.PersistentFlags().StringVarP(&exclude, "exclude", "e", "", "comma-separated patterns to exclude (e.g., 'build/**,*.jar')")
	rootCmd.PersistentFlags().StringVar(&maxFileSize, "max-size", "10MB", "maximum size per file")
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func deriveOutputPath(inputPath string) string {
	// Get the last component of the path
	base := filepath.Base(strings.TrimSuffix(inputPath, string(os.PathSeparator)))

	// If it's a file, use its name with .xml extension
	if ext := filepath.Ext(base); ext != "" {
		return base + ".xml"
	}

	// For directories, append .xml
	return base + ".xml"
}

func runMix(cmd *cobra.Command, args []string) error {

	if len(args) == 0 {
		currentDir, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get current directory: %w", err)
		}
		args = []string{currentDir}
	}

	// Validate pattern first
	if pattern == "" {
		return fmt.Errorf("pattern cannot be empty")
	}

	// Parse max file size
	maxBytes, err := parseSize(maxFileSize)
	if err != nil {
		return fmt.Errorf("invalid max-size value: %w", err)
	}

	// If output path is specified, validate and determine output type
	var globalOutputType core.OutputType
	if outputPath != "" {
		ext := strings.ToLower(filepath.Ext(outputPath))
		switch ext {
		case ".json":
			globalOutputType = core.OutputTypeJSON
		case ".yaml", ".yml":
			globalOutputType = core.OutputTypeYAML
		case ".xml":
			globalOutputType = core.OutputTypeXML
		default:
			return fmt.Errorf("invalid output file extension: must be .xml, .json, .yaml, or .yml")
		}
	}

	// Process each input path
	for _, inputPath := range args {
		// Determine output path and type for this input
		var currentOutputPath string
		var outputType core.OutputType

		if outputPath != "" {
			// Use global output path if specified
			currentOutputPath = outputPath
			outputType = globalOutputType
		} else {
			// Generate output path based on input path
			currentOutputPath = deriveOutputPath(inputPath)
			outputType = core.OutputTypeXML // Default to XML for auto-generated paths
		}

		// Create mixer options
		options := &core.MixOptions{
			InputPath:   inputPath,
			OutputPath:  currentOutputPath,
			Pattern:     pattern,
			Exclude:     exclude,
			MaxFileSize: maxBytes,
			OutputType:  outputType,
		}

		// First, scan for files and check total size
		files, totalSize, err := scanFiles(options)
		if err != nil {
			return fmt.Errorf("error processing %s: %w", inputPath, err)
		}

		// Print summary before processing
		fmt.Printf("Processing %s:\n", inputPath)
		fmt.Printf("Found %d files matching pattern\n", len(files))
		fmt.Printf("Total size: %s\n", formatSize(totalSize))

		// Check if total size exceeds maximum
		if totalSize > maxBytes {
			fmt.Printf("\nError: Total size (%s) exceeds maximum allowed size (%s)\n",
				formatSize(totalSize), maxFileSize)
			fmt.Println("\nMatching files:")

			for _, file := range files {
				fmt.Printf("- %s (%s)\n", file.Path, formatSize(file.Size))
			}

			return fmt.Errorf("total size exceeds maximum allowed size for %s", inputPath)
		}

		// Create and run mixer
		mixer := core.NewMixer(options)
		if err := mixer.Mix(); err != nil {
			return fmt.Errorf("error mixing %s: %w", inputPath, err)
		}

		fmt.Printf("Successfully created %s\n\n", currentOutputPath)

		// If using a global output path, only process the first input
		if outputPath != "" {
			fmt.Println("Note: Using specified output path. Additional inputs will be ignored.")
			break
		}
	}

	return nil
}

func scanFiles(options *core.MixOptions) ([]FileInfo, int64, error) {
	var files []FileInfo
	var totalSize int64

	// Prepare patterns
	patterns := strings.Split(options.Pattern, ",")
	for i := range patterns {
		patterns[i] = strings.TrimSpace(patterns[i])
	}

	// Prepare exclude patterns
	var excludePatterns []string
	if options.Exclude != "" {
		excludePatterns = strings.Split(options.Exclude, ",")
		for i := range excludePatterns {
			excludePatterns[i] = strings.TrimSpace(excludePatterns[i])
		}
	}

	err := filepath.Walk(options.InputPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip directories
		if info.IsDir() {
			// Skip .git directory
			if filepath.Base(path) == ".git" {
				return filepath.SkipDir
			}
			return nil
		}

		// Get relative path for pattern matching
		relPath, err := filepath.Rel(options.InputPath, path)
		if err != nil {
			relPath = path
		}

		// Check exclusions first
		for _, pattern := range excludePatterns {
			if pattern == "" {
				continue
			}

			// Handle directory wildcards
			if strings.Contains(pattern, "**") {
				pattern = strings.ReplaceAll(pattern, "**", "*")
				if matched, _ := filepath.Match(pattern, relPath); matched {
					return nil
				}
			} else {
				if matched, _ := filepath.Match(pattern, relPath); matched {
					return nil
				}
			}
		}

		// Check if file matches any inclusion pattern
		for _, pattern := range patterns {
			match, err := filepath.Match(pattern, filepath.Base(path))
			if err != nil {
				return err
			}
			if match {
				// Check file size
				if info.Size() <= options.MaxFileSize {
					files = append(files, FileInfo{
						Path: relPath,
						Size: info.Size(),
					})
					totalSize += info.Size()
				}
				break
			}
		}
		return nil
	})

	if err != nil {
		return nil, 0, err
	}

	return files, totalSize, nil
}

// parseSize converts a size string (e.g., "10MB") to bytes

func parseSize(size string) (int64, error) {
	// Remove all spaces and convert to uppercase
	size = strings.ToUpper(strings.ReplaceAll(size, " ", ""))

	if size == "" {
		return 0, fmt.Errorf("size cannot be empty")
	}

	var multiplier int64 = 1
	var value string

	// Check for valid suffix first
	switch {
	case strings.HasSuffix(size, "TB"):
		multiplier = 1024 * 1024 * 1024 * 1024
		value = strings.TrimSuffix(size, "TB")
	case strings.HasSuffix(size, "GB"):
		multiplier = 1024 * 1024 * 1024
		value = strings.TrimSuffix(size, "GB")
	case strings.HasSuffix(size, "MB"):
		multiplier = 1024 * 1024
		value = strings.TrimSuffix(size, "MB")
	case strings.HasSuffix(size, "KB"):
		multiplier = 1024
		value = strings.TrimSuffix(size, "KB")
	case strings.HasSuffix(size, "B"):
		value = strings.TrimSuffix(size, "B")
	default:
		return 0, fmt.Errorf("invalid size format: must end with B, KB, MB, GB, or TB")
	}

	// Parse the numeric value
	num, err := strconv.ParseInt(value, 10, 64)
	if err != nil {
		return 0, fmt.Errorf("invalid size number: %w", err)
	}

	// Check for negative numbers
	if num <= 0 {
		return 0, fmt.Errorf("size must be a positive number")
	}

	return num * multiplier, nil
}

// formatSize converts bytes to a human-readable string
func formatSize(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}
</document_content>
</document>
<document index="2">
<source>main_test.go</source>
<document_content>package main

import (
	"bytes"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/drgsn/filefusion/internal/core"
	"github.com/spf13/cobra"
)

func setupRootCmd() {
	// Reset the command and its flags completely
	rootCmd = &cobra.Command{
		Use:   "filefusion [paths...]",
		Short: "Filefusion - File concatenation tool optimized for LLM usage",
		Long: `Filefusion concatenates files into a format optimized for Large Language Models (LLMs).
It preserves file metadata and structures the output in an XML-like or JSON format.`,
		RunE: runMix,
	}

	// Re-initialize all flags
	rootCmd.PersistentFlags().StringVarP(&outputPath, "output", "o", "", "output file path")
	rootCmd.PersistentFlags().StringVarP(&pattern, "pattern", "p", "*.go,*.json,*.yaml,*.yml", "file patterns")
	rootCmd.PersistentFlags().StringVarP(&exclude, "exclude", "e", "", "exclude patterns")
	rootCmd.PersistentFlags().StringVar(&maxFileSize, "max-size", "10MB", "maximum size per file")
}


// Helper function to capture stdout for testing
func captureOutput(fn func() error) (string, error) {
	old := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err := fn()

	// Restore stdout and get output
	os.Stdout = old
	w.Close()
	var buf bytes.Buffer
	io.Copy(&buf, r)

	return buf.String(), err
}

func TestDeriveOutputPath(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "directory path",
			input:    "/service/user-service",
			expected: "user-service.xml",
		},
		{
			name:     "directory path with trailing slash",
			input:    "/service/user-service/",
			expected: "user-service.xml",
		},
		{
			name:     "file path",
			input:    "/service/user-service/openapi.json",
			expected: "openapi.json.xml",
		},
		{
			name:     "simple directory name",
			input:    "config",
			expected: "config.xml",
		},
		{
			name:     "simple file name",
			input:    "config.yaml",
			expected: "config.yaml.xml",
		},
		{
			name:     "complex path with file",
			input:    "/very/long/path/to/some/config.json",
			expected: "config.json.xml",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := deriveOutputPath(tt.input)
			if result != tt.expected {
				t.Errorf("Expected %q, got %q", tt.expected, result)
			}
		})
	}
}

func TestMultipleInputPaths(t *testing.T) {
	// Create temporary test directories
	tmpDir1, err := os.MkdirTemp("", "filefusion-test1-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir 1: %v", err)
	}
	defer os.RemoveAll(tmpDir1)

	tmpDir2, err := os.MkdirTemp("", "filefusion-test2-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir 2: %v", err)
	}
	defer os.RemoveAll(tmpDir2)

	// Create test files in first directory
	files1 := map[string]string{
		"test1.go":  "package main\nfunc main() {}\n",
		"data.json": `{"key": "value"}`,
	}

	// Create test files in second directory
	files2 := map[string]string{
		"test2.go":    "package other\nfunc helper() {}\n",
		"config.yaml": "name: test",
		"ignore.txt":  "ignored file",
	}

	// Create files in first directory
	for name, content := range files1 {
		path := filepath.Join(tmpDir1, name)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create test file %s: %v", name, err)
		}
	}

	// Create files in second directory
	for name, content := range files2 {
		path := filepath.Join(tmpDir2, name)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create test file %s: %v", name, err)
		}
	}

	tests := []struct {
		name          string
		args          []string
		flags         map[string]string
		expectedFiles []string
		shouldError   bool
		errorContains string
	}{
		{
			name:          "multiple directories without output flag",
			args:          []string{tmpDir1, tmpDir2},
			flags:         map[string]string{"pattern": "*.go,*.json,*.yaml"},
			expectedFiles: []string{filepath.Base(tmpDir1) + ".xml", filepath.Base(tmpDir2) + ".xml"},
			shouldError:   false,
		},
		{
			name:          "multiple directories with output flag",
			args:          []string{tmpDir1, tmpDir2},
			flags:         map[string]string{"pattern": "*.go,*.json,*.yaml", "output": "combined.json"},
			expectedFiles: []string{"combined.json"},
			shouldError:   false,
		},
		{
			name:          "invalid pattern",
			args:          []string{tmpDir1, tmpDir2},
			flags:         map[string]string{"pattern": "["},
			shouldError:   true,
			errorContains: "syntax error in pattern",
		},
		{
			name:          "no matching files",
			args:          []string{tmpDir1, tmpDir2},
			flags:         map[string]string{"pattern": "*.cpp"},
			shouldError:   true,
			errorContains: "no files found matching pattern",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Save current working directory
			wd, err := os.Getwd()
			if err != nil {
				t.Fatalf("Failed to get working directory: %v", err)
			}

			// Create temporary directory for output files
			outputDir, err := os.MkdirTemp("", "filefusion-output-*")
			if err != nil {
				t.Fatalf("Failed to create output directory: %v", err)
			}
			defer os.RemoveAll(outputDir)

			// Change to output directory
			if err := os.Chdir(outputDir); err != nil {
				t.Fatalf("Failed to change directory: %v", err)
			}
			defer os.Chdir(wd)

			// Reset and reinitialize command for each test
			setupRootCmd()

			// Build command arguments
			var cmdArgs []string

			// Add flags first
			for flag, value := range tt.flags {
				cmdArgs = append(cmdArgs, "--"+flag, value)
			}

			// Add positional arguments
			cmdArgs = append(cmdArgs, tt.args...)

			// Set the command args
			rootCmd.SetArgs(cmdArgs)

			// Execute command
			err = rootCmd.Execute()

			// Check error status
			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
					return
				}
				if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
					t.Errorf("Expected error containing %q, got %q", tt.errorContains, err.Error())
				}
				return
			} else if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			// Check output files
			files, err := os.ReadDir(outputDir)
			if err != nil {
				t.Fatalf("Failed to read output directory: %v", err)
			}

			// Create a map of expected files
			expectedFiles := make(map[string]bool)
			for _, f := range tt.expectedFiles {
				expectedFiles[f] = true
			}

			// Check that all expected files exist
			for _, file := range files {
				if !expectedFiles[file.Name()] {
					t.Errorf("Unexpected file created: %s", file.Name())
				}
				delete(expectedFiles, file.Name())
			}

			// Check if any expected files are missing
			for f := range expectedFiles {
				t.Errorf("Expected file not created: %s", f)
			}
		})
	}
}

func TestScanFiles(t *testing.T) {
	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-scan-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test files with specific sizes
	files := map[string]struct {
		size     int64
		content  string
		expected bool
	}{
		"small.go":     {size: 100, content: strings.Repeat("a", 100), expected: true},
		"medium.go":    {size: 1024, content: strings.Repeat("b", 1024), expected: true},
		"large.go":     {size: 2048, content: strings.Repeat("c", 2048), expected: false},
		"ignored.txt":  {size: 100, content: strings.Repeat("d", 100), expected: false},
		"test/nest.go": {size: 100, content: strings.Repeat("e", 100), expected: true},
		".git/hide.go": {size: 100, content: strings.Repeat("f", 100), expected: false},
	}

	// Create the files
	for name, info := range files {
		path := filepath.Join(tmpDir, name)
		err := os.MkdirAll(filepath.Dir(path), 0755)
		if err != nil {
			t.Fatalf("Failed to create directory for %s: %v", name, err)
		}
		err = os.WriteFile(path, []byte(info.content), 0644)
		if err != nil {
			t.Fatalf("Failed to create test file %s: %v", name, err)
		}
	}

	tests := []struct {
		name          string
		pattern       string
		exclude       string
		maxSize       int64
		expectedCount int
		shouldError   bool
	}{
		{
			name:          "standard scan",
			pattern:       "*.go",
			maxSize:       1500,
			expectedCount: 3,
			shouldError:   false,
		},
		{
			name:          "exclude nested",
			pattern:       "*.go",
			exclude:       "test/**",
			maxSize:       1500,
			expectedCount: 2,
			shouldError:   false,
		},
		{
			name:          "small size limit",
			pattern:       "*.go",
			maxSize:       500,
			expectedCount: 2,
			shouldError:   false,
		},
		{
			name:          "multiple patterns",
			pattern:       "*.go,*.txt",
			maxSize:       1500,
			expectedCount: 4,
			shouldError:   false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			options := &core.MixOptions{
				InputPath:   tmpDir,
				Pattern:     tt.pattern,
				Exclude:     tt.exclude,
				MaxFileSize: tt.maxSize,
			}

			files, totalSize, err := scanFiles(options)
			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if len(files) != tt.expectedCount {
				t.Errorf("Expected %d files, got %d", tt.expectedCount, len(files))
			}

			// Verify total size calculation
			var expectedTotal int64
			for _, file := range files {
				expectedTotal += file.Size
			}

			if totalSize != expectedTotal {
				t.Errorf("Expected total size %d, got %d", expectedTotal, totalSize)
			}
		})
	}
}

func TestParseSize(t *testing.T) {
	tests := []struct {
		name      string
		input     string
		expected  int64
		shouldErr bool
	}{
		{
			name:      "bytes",
			input:     "1024B",
			expected:  1024,
			shouldErr: false,
		},
		{
			name:      "kilobytes",
			input:     "1KB",
			expected:  1024,
			shouldErr: false,
		},
		{
			name:      "megabytes",
			input:     "1MB",
			expected:  1024 * 1024,
			shouldErr: false,
		},
		{
			name:      "gigabytes",
			input:     "1GB",
			expected:  1024 * 1024 * 1024,
			shouldErr: false,
		},
		{
			name:      "terabytes",
			input:     "1TB",
			expected:  1024 * 1024 * 1024 * 1024,
			shouldErr: false,
		},
		{
			name:      "with spaces",
			input:     " 5 MB ",
			expected:  5 * 1024 * 1024,
			shouldErr: false,
		},
		{
			name:      "invalid format",
			input:     "1XB",
			shouldErr: true,
		},
		{
			name:      "invalid number",
			input:     "abcMB",
			shouldErr: true,
		},
		{
			name:      "negative number",
			input:     "-1MB",
			shouldErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := parseSize(tt.input)
			if tt.shouldErr {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if result != tt.expected {
				t.Errorf("Expected %d bytes, got %d", tt.expected, result)
			}
		})
	}
}

func TestFormatSize(t *testing.T) {
	tests := []struct {
		name     string
		input    int64
		expected string
	}{
		{
			name:     "bytes",
			input:    500,
			expected: "500 B",
		},
		{
			name:     "kilobytes",
			input:    1024,
			expected: "1.0 KB",
		},
		{
			name:     "megabytes",
			input:    1024 * 1024,
			expected: "1.0 MB",
		},
		{
			name:     "gigabytes",
			input:    1024 * 1024 * 1024,
			expected: "1.0 GB",
		},
		{
			name:     "partial unit",
			input:    1536, // 1.5 KB
			expected: "1.5 KB",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := formatSize(tt.input)
			if result != tt.expected {
				t.Errorf("Expected %s, got %s", tt.expected, result)
			}
		})
	}
}

func TestRootCommandFlags(t *testing.T) {
	tests := []struct {
		name          string
		args          []string
		expectedError string
	}{
		{
			name:          "invalid max size format",
			args:          []string{"--max-size", "10Z", "some/path"},
			expectedError: "invalid max-size value: invalid size format: must end with B, KB, MB, GB, or TB",
		},
		{
			name:          "negative max size",
			args:          []string{"--max-size", "-5MB", "--pattern", "*.go", "some/path"},
			expectedError: "invalid max-size value: size must be a positive number",
		},
		{
			name:          "empty pattern",
			args:          []string{"--pattern", "", "some/path"},
			expectedError: "pattern cannot be empty",
		},
		{
			name:          "invalid output extension",
			args:          []string{"--output", "output.txt", "--pattern", "*.go", "--max-size", "10MB", "some/path"},
			expectedError: "invalid output file extension: must be .xml, .json, .yaml, or .yml",
		},
		{
			name:          "no input paths",
			args:          []string{"--pattern", "*.go"},
			expectedError: "pattern cannot be empty", // This matches the actual error from runMix
		},
		{
			name:          "multiple inputs with invalid output",
			args:          []string{"--output", "out.txt", "path1", "path2"},
			expectedError: "invalid output file extension: must be .xml, .json, .yaml, or .yml",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			setupRootCmd()
			rootCmd.SetArgs(tt.args)
			err := rootCmd.Execute()

			if err == nil {
				t.Error("Expected error but got none")
				return
			}

			if err.Error() != tt.expectedError {
				t.Errorf("Expected error %q, got %q", tt.expectedError, err.Error())
			}
		})
	}
}

func TestOutputContents(t *testing.T) {
	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-output-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test files
	testFiles := map[string]string{
		"test.go":   "package main\nfunc main() {}\n",
		"data.json": `{"key": "value"}`,
	}

	for name, content := range testFiles {
		path := filepath.Join(tmpDir, name)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create test file: %v", err)
		}
	}

	tests := []struct {
		name          string
		outputFlag    string
		expectedStart string
		notExpected   string
	}{
		{
			name:          "XML output",
			outputFlag:    "output.xml",
			expectedStart: "<?xml",
			notExpected:   "yaml",
		},
		{
			name:          "JSON output",
			outputFlag:    "output.json",
			expectedStart: "{",
			notExpected:   "xml",
		},
		{
			name:          "YAML output",
			outputFlag:    "output.yaml",
			expectedStart: "documents:",
			notExpected:   "xml",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			outputPath := filepath.Join(tmpDir, tt.outputFlag)

			// Reset and set up command
			rootCmd.ResetFlags()
			setupRootCmd()

			rootCmd.SetArgs([]string{
				"--output", outputPath,
				"--pattern", "*.go,*.json",
				tmpDir,
			})

			if err := rootCmd.Execute(); err != nil {
				t.Fatalf("Command execution failed: %v", err)
			}

			// Read and check output file
			content, err := os.ReadFile(outputPath)
			if err != nil {
				t.Fatalf("Failed to read output file: %v", err)
			}

			// Check content starts with expected string
			if !strings.Contains(string(content), tt.expectedStart) {
				t.Errorf("Output should contain %q", tt.expectedStart)
			}

			// Check content doesn't contain unexpected string
			if strings.Contains(string(content), tt.notExpected) {
				t.Errorf("Output should not contain %q", tt.notExpected)
			}
		})
	}
}

func TestRunMixWithNoArgs(t *testing.T) {
	// Create a temporary directory for testing
	tmpDir, err := os.MkdirTemp("", "filefusion-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create a test file in the temp directory
	testFile := filepath.Join(tmpDir, "test.go")
	if err := os.WriteFile(testFile, []byte("package main\n\nfunc main() {}\n"), 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Change to the temporary directory
	originalDir, err := os.Getwd()
	if err != nil {
		t.Fatalf("Failed to get current directory: %v", err)
	}
	if err := os.Chdir(tmpDir); err != nil {
		t.Fatalf("Failed to change directory: %v", err)
	}
	defer os.Chdir(originalDir)

	// Reset and setup the root command
	setupRootCmd()

	// Test with no args (should use current directory)
	rootCmd.SetArgs([]string{})

	// Execute the command
	if err := rootCmd.Execute(); err != nil {
		t.Errorf("Command execution failed: %v", err)
	}

	// Get the base name of the directory for the expected output file
	baseName := filepath.Base(tmpDir)
	expectedOutput := filepath.Join(tmpDir, baseName+".xml")

	// Check if output file exists and has content
	fileInfo, err := os.Stat(expectedOutput)
	if os.IsNotExist(err) {
		t.Errorf("Expected output file %s was not created", expectedOutput)
	} else if err != nil {
		t.Errorf("Error checking output file: %v", err)
	} else if fileInfo.Size() == 0 {
		t.Error("Output file was created but is empty")
	}

	// Optionally, verify the content of the output file
	content, err := os.ReadFile(expectedOutput)
	if err != nil {
		t.Errorf("Failed to read output file: %v", err)
	} else if !bytes.Contains(content, []byte("package main")) {
		t.Error("Output file doesn't contain expected content")
	}
}
</document_content>
</document>
</documents>