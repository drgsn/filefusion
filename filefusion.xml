<?xml version="1.0" encoding="UTF-8"?>
<documents>
<document index="1">
<source>.github/workflows/release.yml</source>
<document_content>name: Release

on:
  push:
    # Trigger this workflow only when you push a tag that starts with "v",
    # e.g. "v1.0.0" or "v2.0.0".
    tags:
      - 'v*.*.*'

# Add permissions needed for creating releases
permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Check out the repository
        uses: actions/checkout@v4
        with:
          # We fetch all commits & tags so GoReleaser can properly read the tag version
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Run GoReleaser
        # The official GoReleaser GitHub Action
        uses: goreleaser/goreleaser-action@v4
        with:
          # By default, it will look for .goreleaser.yml in the repo root
          version: latest
          args: release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</document_content>
</document>
<document index="2">
<source>.goreleaser.yml</source>
<document_content>version: 2

before:
  hooks:
    # If you have tests, uncomment:
    - go test ./...
    - echo "Starting GoReleaser..."

builds:
  - id: filefusion
    # If your main.go is in the root folder, use "." or "./".
    main: ./cmd/filefusion/main.go
    # The base output filename (GoReleaser adds .exe for Windows).
    binary: filefusion
    # Target OS/Arch combos:
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    # Disable CGO if not needed:
    env:
      - CGO_ENABLED=0

archives:
  - id: filefusion-archive
    # Name format for each archive
    name_template: '{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}'
    # Linux & macOS get tar.gz by default; Windows gets .zip
    format_overrides:
      - goos: windows
        format: zip
    # Files to include in the archive
    files:
      - README*
      - LICENSE*
    allow_different_binary_count: true

# Publishes a GitHub release for the git tag you push (e.g., v0.0.2).
release:
  prerelease: auto
  draft: false
  name_template: "v{{ .Version }}"

# Generate checksums for the archives
checksum:
  name_template: "checksums.txt"
  algorithm: sha256
</document_content>
</document>
<document index="3">
<source>cmd/filefusion/main.go</source>
<document_content>package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/drgsn/filefusion/internal/core"
	"github.com/spf13/cobra"
)

type FileInfo struct {
	Path string `json:"path"`
	Size int64  `json:"size"`
}

var (
	outputPath  string
	pattern     string
	exclude     string
	maxFileSize string
	jsonOutput  bool
)

var rootCmd = &cobra.Command{
	Use:   "filefusion [paths...]",
	Short: "Filefusion - File concatenation tool optimized for LLM usage",
	Long: `Filefusion concatenates files into a format optimized for Large Language Models (LLMs).
It preserves file metadata and structures the output in an XML-like or JSON format.
Complete documentation is available at https://github.com/drgsn/filefusion`,
	RunE: runMix,
}

func init() {
	rootCmd.PersistentFlags().StringVarP(&outputPath, "output", "o", "", "output file path (if not specified, generates files based on input paths)")
	rootCmd.PersistentFlags().StringVarP(&pattern, "pattern", "p", "*.go,*.json,*.yaml,*.yml", "comma-separated file patterns (e.g., '*.go,*.json')")
	rootCmd.PersistentFlags().StringVarP(&exclude, "exclude", "e", "", "comma-separated patterns to exclude (e.g., 'build/**,*.jar')")
	rootCmd.PersistentFlags().StringVar(&maxFileSize, "max-size", "10MB", "maximum size per file")
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func deriveOutputPath(inputPath string) string {
	// Get the last component of the path
	base := filepath.Base(strings.TrimSuffix(inputPath, string(os.PathSeparator)))

	// If it's a file, use its name with .xml extension
	if ext := filepath.Ext(base); ext != "" {
		return base + ".xml"
	}

	// For directories, append .xml
	return base + ".xml"
}

func runMix(cmd *cobra.Command, args []string) error {

	if len(args) == 0 {
		currentDir, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get current directory: %w", err)
		}
		args = []string{currentDir}
	}

	// Validate pattern first
	if pattern == "" {
		return fmt.Errorf("pattern cannot be empty")
	}

	// Parse max file size
	maxBytes, err := parseSize(maxFileSize)
	if err != nil {
		return fmt.Errorf("invalid max-size value: %w", err)
	}

	// If output path is specified, validate and determine output type
	var globalOutputType core.OutputType
	if outputPath != "" {
		ext := strings.ToLower(filepath.Ext(outputPath))
		switch ext {
		case ".json":
			globalOutputType = core.OutputTypeJSON
		case ".yaml", ".yml":
			globalOutputType = core.OutputTypeYAML
		case ".xml":
			globalOutputType = core.OutputTypeXML
		default:
			return fmt.Errorf("invalid output file extension: must be .xml, .json, .yaml, or .yml")
		}
	}

	// Process each input path
	for _, inputPath := range args {
		// Determine output path and type for this input
		var currentOutputPath string
		var outputType core.OutputType

		if outputPath != "" {
			// Use global output path if specified
			currentOutputPath = outputPath
			outputType = globalOutputType
		} else {
			// Generate output path based on input path
			currentOutputPath = deriveOutputPath(inputPath)
			outputType = core.OutputTypeXML // Default to XML for auto-generated paths
		}

		// Create mixer options
		options := &core.MixOptions{
			InputPath:   inputPath,
			OutputPath:  currentOutputPath,
			Pattern:     pattern,
			Exclude:     exclude,
			MaxFileSize: maxBytes,
			OutputType:  outputType,
		}

		// First, scan for files and check total size
		files, totalSize, err := scanFiles(options)
		if err != nil {
			return fmt.Errorf("error processing %s: %w", inputPath, err)
		}

		// Print summary before processing
		fmt.Printf("Processing %s:\n", inputPath)
		fmt.Printf("Found %d files matching pattern\n", len(files))
		fmt.Printf("Total size: %s\n", formatSize(totalSize))

		// Check if total size exceeds maximum
		if totalSize > maxBytes {
			fmt.Printf("\nError: Total size (%s) exceeds maximum allowed size (%s)\n",
				formatSize(totalSize), maxFileSize)
			fmt.Println("\nMatching files:")

			for _, file := range files {
				fmt.Printf("- %s (%s)\n", file.Path, formatSize(file.Size))
			}

			return fmt.Errorf("total size exceeds maximum allowed size for %s", inputPath)
		}

		// Create and run mixer
		mixer := core.NewMixer(options)
		if err := mixer.Mix(); err != nil {
			return fmt.Errorf("error mixing %s: %w", inputPath, err)
		}

		fmt.Printf("Successfully created %s\n\n", currentOutputPath)

		// If using a global output path, only process the first input
		if outputPath != "" {
			fmt.Println("Note: Using specified output path. Additional inputs will be ignored.")
			break
		}
	}

	return nil
}

func scanFiles(options *core.MixOptions) ([]FileInfo, int64, error) {
	var files []FileInfo
	var totalSize int64

	// Prepare patterns
	patterns := strings.Split(options.Pattern, ",")
	for i := range patterns {
		patterns[i] = strings.TrimSpace(patterns[i])
	}

	// Prepare exclude patterns
	var excludePatterns []string
	if options.Exclude != "" {
		excludePatterns = strings.Split(options.Exclude, ",")
		for i := range excludePatterns {
			excludePatterns[i] = strings.TrimSpace(excludePatterns[i])
		}
	}

	err := filepath.Walk(options.InputPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip directories
		if info.IsDir() {
			// Skip .git directory
			if filepath.Base(path) == ".git" {
				return filepath.SkipDir
			}
			return nil
		}

		// Get relative path for pattern matching
		relPath, err := filepath.Rel(options.InputPath, path)
		if err != nil {
			relPath = path
		}

		// Check exclusions first
		for _, pattern := range excludePatterns {
			if pattern == "" {
				continue
			}

			// Handle directory wildcards
			if strings.Contains(pattern, "**") {
				pattern = strings.ReplaceAll(pattern, "**", "*")
				if matched, _ := filepath.Match(pattern, relPath); matched {
					return nil
				}
			} else {
				if matched, _ := filepath.Match(pattern, relPath); matched {
					return nil
				}
			}
		}

		// Check if file matches any inclusion pattern
		for _, pattern := range patterns {
			match, err := filepath.Match(pattern, filepath.Base(path))
			if err != nil {
				return err
			}
			if match {
				// Check file size
				if info.Size() <= options.MaxFileSize {
					files = append(files, FileInfo{
						Path: relPath,
						Size: info.Size(),
					})
					totalSize += info.Size()
				}
				break
			}
		}
		return nil
	})

	if err != nil {
		return nil, 0, err
	}

	return files, totalSize, nil
}

// parseSize converts a size string (e.g., "10MB") to bytes

func parseSize(size string) (int64, error) {
	// Remove all spaces and convert to uppercase
	size = strings.ToUpper(strings.ReplaceAll(size, " ", ""))

	if size == "" {
		return 0, fmt.Errorf("size cannot be empty")
	}

	var multiplier int64 = 1
	var value string

	// Check for valid suffix first
	switch {
	case strings.HasSuffix(size, "TB"):
		multiplier = 1024 * 1024 * 1024 * 1024
		value = strings.TrimSuffix(size, "TB")
	case strings.HasSuffix(size, "GB"):
		multiplier = 1024 * 1024 * 1024
		value = strings.TrimSuffix(size, "GB")
	case strings.HasSuffix(size, "MB"):
		multiplier = 1024 * 1024
		value = strings.TrimSuffix(size, "MB")
	case strings.HasSuffix(size, "KB"):
		multiplier = 1024
		value = strings.TrimSuffix(size, "KB")
	case strings.HasSuffix(size, "B"):
		value = strings.TrimSuffix(size, "B")
	default:
		return 0, fmt.Errorf("invalid size format: must end with B, KB, MB, GB, or TB")
	}

	// Parse the numeric value
	num, err := strconv.ParseInt(value, 10, 64)
	if err != nil {
		return 0, fmt.Errorf("invalid size number: %w", err)
	}

	// Check for negative numbers
	if num <= 0 {
		return 0, fmt.Errorf("size must be a positive number")
	}

	return num * multiplier, nil
}

// formatSize converts bytes to a human-readable string
func formatSize(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}
</document_content>
</document>
<document index="4">
<source>.github/workflows/test.yml</source>
<document_content>name: Run tests and upload coverage

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read

jobs:
  test:
    name: Run tests and collect coverage
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Install dependencies
        run: go mod download

      - name: Run tests
        run: go test ./... -coverprofile=coverage.txt -covermode=atomic

      - name: Upload results to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          file: coverage.txt
          fail_ci_if_error: true
</document_content>
</document>
<document index="5">
<source>internal/core/mixer.go</source>
<document_content>package core

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"text/template"

	"gopkg.in/yaml.v3"
)

// FileResult represents the result of processing a single file
type FileResult struct {
	Content FileContent
	Error   error
}

// Mixer handles file concatenation
type Mixer struct {
	options *MixOptions
}

// NewMixer creates a new Mixer instance
func NewMixer(options *MixOptions) *Mixer {
	if options.MaxFileSize == 0 {
		options.MaxFileSize = 10 * 1024 * 1024 // Default 10MB
	}
	return &Mixer{options: options}
}

// Mix processes and concatenates files
func (m *Mixer) Mix() error {
	// Find all matching files
	files, err := m.findFiles()
	if err != nil {
		return fmt.Errorf("error finding files: %w", err)
	}

	// Read and process files concurrently
	contents, err := m.readFilesConcurrently(files)
	if err != nil {
		return fmt.Errorf("error reading files: %w", err)
	}

	// Generate LLM-optimized output
	return m.generateLLMOutput(contents)
}

// matchesAnyPattern checks if a file matches any of the provided patterns
func (m *Mixer) matchesAnyPattern(path, filename string) (bool, error) {
	// First check exclusions
	if m.options.Exclude != "" {
		excludePatterns := strings.Split(m.options.Exclude, ",")
		for _, pattern := range excludePatterns {
			pattern = strings.TrimSpace(pattern)
			if pattern == "" {
				continue
			}

			// Convert all slashes to platform-specific separator
			pattern = filepath.FromSlash(pattern)
			pathToCheck := filepath.FromSlash(path)

			// Handle directory-based exclusions with **
			if strings.Contains(pattern, "**") {
				basePattern := strings.TrimSuffix(pattern, string(filepath.Separator)+"**")
				basePattern = strings.TrimSuffix(basePattern, "**")

				// Check if the path starts with the base pattern (excluding the **)
				if strings.HasPrefix(pathToCheck, basePattern) {
					return false, nil
				}
			} else if strings.Contains(pattern, string(filepath.Separator)) {
				// Handle path-based exclusions (contains path separator)
				if match, err := filepath.Match(pattern, pathToCheck); err != nil {
					return false, fmt.Errorf("invalid exclusion pattern %q: %w", pattern, err)
				} else if match {
					return false, nil
				}
			} else {
				// Handle file-based exclusions (no path separator)
				if match, err := filepath.Match(pattern, filename); err != nil {
					return false, fmt.Errorf("invalid exclusion pattern %q: %w", pattern, err)
				} else if match {
					return false, nil
				}
			}
		}
	}

	// Then check inclusion patterns
	patterns := strings.Split(m.options.Pattern, ",")
	for _, pattern := range patterns {
		pattern = strings.TrimSpace(pattern)
		if pattern == "" {
			continue
		}

		// For inclusion patterns, we only match against the filename
		match, err := filepath.Match(pattern, filename)
		if err != nil {
			return false, fmt.Errorf("invalid pattern %q: %w", pattern, err)
		}
		if match {
			return true, nil
		}
	}

	return false, nil
}

// findFiles finds all files matching any of the patterns recursively
func (m *Mixer) findFiles() ([]string, error) {
	var matches []string

	err := filepath.Walk(m.options.InputPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return fmt.Errorf("error accessing path %s: %w", path, err)
		}

		// Skip directories themselves
		if info.IsDir() {
			return nil
		}

		// Get relative path for pattern matching
		relPath, err := filepath.Rel(m.options.InputPath, path)
		if err != nil {
			relPath = path
		}

		// Check if file matches patterns
		match, err := m.matchesAnyPattern(relPath, filepath.Base(path))
		if err != nil {
			return err
		}

		if match {
			matches = append(matches, path)
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	if len(matches) == 0 {
		return nil, fmt.Errorf("no files found matching pattern(s) %q (excluding %q) in %s",
			m.options.Pattern, m.options.Exclude, m.options.InputPath)
	}

	return matches, nil
}

// readFilesConcurrently reads all files concurrently using worker pool
func (m *Mixer) readFilesConcurrently(paths []string) ([]FileContent, error) {
	numWorkers := min(len(paths), 10) // Limit max number of concurrent workers
	results := make(chan FileResult, len(paths))
	var wg sync.WaitGroup

	// Create a channel for distributing work
	jobs := make(chan string, len(paths))
	for _, path := range paths {
		jobs <- path
	}
	close(jobs)

	// Start worker pool
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for path := range jobs {
				result := m.processFile(path)
				results <- result
			}
		}()
	}

	// Wait for all workers to finish in a separate goroutine
	go func() {
		wg.Wait()
		close(results)
	}()

	// Collect results and handle errors
	var contents []FileContent
	var errors []error

	for result := range results {
		if result.Error != nil {
			errors = append(errors, result.Error)
			continue
		}
		if result.Content.Size > 0 { // Skip empty results (from skipped files)
			contents = append(contents, result.Content)
		}
	}

	// If any errors occurred, return the first one
	if len(errors) > 0 {
		return nil, errors[0]
	}

	return contents, nil
}

// processFile handles reading and processing of a single file
func (m *Mixer) processFile(path string) FileResult {
	// Get file info
	info, err := os.Stat(path)
	if err != nil {
		return FileResult{
			Error: &MixError{
				File:    path,
				Message: fmt.Sprintf("error getting file info: %v", err),
			},
		}
	}

	// Skip if file is too large
	if info.Size() > m.options.MaxFileSize {
		fmt.Fprintf(os.Stderr, "Warning: Skipping %s (size %d bytes exceeds limit %d bytes)\n",
			path, info.Size(), m.options.MaxFileSize)
		return FileResult{} // Return empty result for skipped files
	}

	// Read file content
	content, err := os.ReadFile(path)
	if err != nil {
		return FileResult{
			Error: &MixError{
				File:    path,
				Message: fmt.Sprintf("error reading file: %v", err),
			},
		}
	}

	// Get relative path from input directory
	relPath, err := filepath.Rel(m.options.InputPath, path)
	if err != nil {
		relPath = path // Fallback to full path if relative path cannot be determined
	}

	return FileResult{
		Content: FileContent{
			Path:      relPath,
			Name:      filepath.Base(path),
			Extension: strings.TrimPrefix(filepath.Ext(path), "."),
			Content:   string(content),
			Size:      info.Size(),
		},
	}
}

// generateLLMOutput generates output optimized for LLM consumption
func (m *Mixer) generateLLMOutput(contents []FileContent) error {
	file, err := os.Create(m.options.OutputPath)
	if err != nil {
		return &MixError{
			File:    m.options.OutputPath,
			Message: fmt.Sprintf("error creating output file: %v", err),
		}
	}
	defer file.Close()

	// Common structure for JSON and YAML output
	type Document struct {
		Index           int    `json:"index" yaml:"index"`
		Source          string `json:"source" yaml:"source"`
		DocumentContent string `json:"document_content" yaml:"document_content"`
	}

	type Output struct {
		Documents []Document `json:"documents" yaml:"documents"`
	}

	// Convert contents to output format
	output := Output{
		Documents: make([]Document, len(contents)),
	}

	for i, content := range contents {
		output.Documents[i] = Document{
			Index:           i + 1,
			Source:          content.Path,
			DocumentContent: content.Content,
		}
	}

	switch m.options.OutputType {
	case OutputTypeJSON:
		encoder := json.NewEncoder(file)
		encoder.SetIndent("", "  ")
		if err := encoder.Encode(output); err != nil {
			return &MixError{Message: fmt.Sprintf("error encoding JSON: %v", err)}
		}
		return nil

	case OutputTypeYAML:
		encoder := yaml.NewEncoder(file)
		encoder.SetIndent(2)
		if err := encoder.Encode(output); err != nil {
			return &MixError{Message: fmt.Sprintf("error encoding YAML: %v", err)}
		}
		return nil

	case OutputTypeXML:
		// XML output
		const xmlTemplate = `<?xml version="1.0" encoding="UTF-8"?>
<documents>{{range $index, $file := .}}
<document index="{{add $index 1}}">
<source>{{.Path}}</source>
<document_content>{{.Content}}</document_content>
</document>{{end}}
</documents>`

		// Create template with custom functions
		t, err := template.New("llm").Funcs(template.FuncMap{
			"add": func(a, b int) int { return a + b },
		}).Parse(xmlTemplate)
		if err != nil {
			return &MixError{Message: fmt.Sprintf("error parsing template: %v", err)}
		}

		// Execute template
		if err := t.Execute(file, contents); err != nil {
			return &MixError{Message: fmt.Sprintf("error executing template: %v", err)}
		}
		return nil

	default:
		return &MixError{Message: fmt.Sprintf("unsupported output type: %s", m.options.OutputType)}
	}
}

// min returns the smaller of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
</document_content>
</document>
<document index="6">
<source>cmd/filefusion/main_test.go</source>
<document_content>package main

import (
	"bytes"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/drgsn/filefusion/internal/core"
	"github.com/spf13/cobra"
)

func setupRootCmd() {
	// Reset the command and its flags completely
	rootCmd = &cobra.Command{
		Use:   "filefusion [paths...]",
		Short: "Filefusion - File concatenation tool optimized for LLM usage",
		Long: `Filefusion concatenates files into a format optimized for Large Language Models (LLMs).
It preserves file metadata and structures the output in an XML-like or JSON format.`,
		Args: cobra.MinimumNArgs(1),
		RunE: runMix,
	}

	// Re-initialize all flags
	rootCmd.PersistentFlags().StringVarP(&outputPath, "output", "o", "", "output file path")
	rootCmd.PersistentFlags().StringVarP(&pattern, "pattern", "p", "*.go,*.json,*.yaml,*.yml", "file patterns")
	rootCmd.PersistentFlags().StringVarP(&exclude, "exclude", "e", "", "exclude patterns")
	rootCmd.PersistentFlags().StringVar(&maxFileSize, "max-size", "10MB", "maximum size per file")
}

func TestDeriveOutputPath(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "directory path",
			input:    "/service/user-service",
			expected: "user-service.xml",
		},
		{
			name:     "directory path with trailing slash",
			input:    "/service/user-service/",
			expected: "user-service.xml",
		},
		{
			name:     "file path",
			input:    "/service/user-service/openapi.json",
			expected: "openapi.json.xml",
		},
		{
			name:     "simple directory name",
			input:    "config",
			expected: "config.xml",
		},
		{
			name:     "simple file name",
			input:    "config.yaml",
			expected: "config.yaml.xml",
		},
		{
			name:     "complex path with file",
			input:    "/very/long/path/to/some/config.json",
			expected: "config.json.xml",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := deriveOutputPath(tt.input)
			if result != tt.expected {
				t.Errorf("Expected %q, got %q", tt.expected, result)
			}
		})
	}
}

func TestMultipleInputPaths(t *testing.T) {
	// Create temporary test directories
	tmpDir1, err := os.MkdirTemp("", "filefusion-test1-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir 1: %v", err)
	}
	defer os.RemoveAll(tmpDir1)

	tmpDir2, err := os.MkdirTemp("", "filefusion-test2-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir 2: %v", err)
	}
	defer os.RemoveAll(tmpDir2)

	// Create test files in first directory
	files1 := map[string]string{
		"test1.go":  "package main\nfunc main() {}\n",
		"data.json": `{"key": "value"}`,
	}

	// Create test files in second directory
	files2 := map[string]string{
		"test2.go":    "package other\nfunc helper() {}\n",
		"config.yaml": "name: test",
		"ignore.txt":  "ignored file",
	}

	// Create files in first directory
	for name, content := range files1 {
		path := filepath.Join(tmpDir1, name)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create test file %s: %v", name, err)
		}
	}

	// Create files in second directory
	for name, content := range files2 {
		path := filepath.Join(tmpDir2, name)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create test file %s: %v", name, err)
		}
	}

	tests := []struct {
		name          string
		args          []string
		flags         map[string]string
		expectedFiles []string
		shouldError   bool
		errorContains string
	}{
		{
			name:          "multiple directories without output flag",
			args:          []string{tmpDir1, tmpDir2},
			flags:         map[string]string{"pattern": "*.go,*.json,*.yaml"},
			expectedFiles: []string{filepath.Base(tmpDir1) + ".xml", filepath.Base(tmpDir2) + ".xml"},
			shouldError:   false,
		},
		{
			name:          "multiple directories with output flag",
			args:          []string{tmpDir1, tmpDir2},
			flags:         map[string]string{"pattern": "*.go,*.json,*.yaml", "output": "combined.json"},
			expectedFiles: []string{"combined.json"},
			shouldError:   false,
		},
		{
			name:          "invalid pattern",
			args:          []string{tmpDir1, tmpDir2},
			flags:         map[string]string{"pattern": "["},
			shouldError:   true,
			errorContains: "syntax error in pattern",
		},
		{
			name:          "no matching files",
			args:          []string{tmpDir1, tmpDir2},
			flags:         map[string]string{"pattern": "*.cpp"},
			shouldError:   true,
			errorContains: "no files found matching pattern",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Save current working directory
			wd, err := os.Getwd()
			if err != nil {
				t.Fatalf("Failed to get working directory: %v", err)
			}

			// Create temporary directory for output files
			outputDir, err := os.MkdirTemp("", "filefusion-output-*")
			if err != nil {
				t.Fatalf("Failed to create output directory: %v", err)
			}
			defer os.RemoveAll(outputDir)

			// Change to output directory
			if err := os.Chdir(outputDir); err != nil {
				t.Fatalf("Failed to change directory: %v", err)
			}
			defer os.Chdir(wd)

			// Reset and reinitialize command for each test
			setupRootCmd()

			// Build command arguments
			var cmdArgs []string

			// Add flags first
			for flag, value := range tt.flags {
				cmdArgs = append(cmdArgs, "--"+flag, value)
			}

			// Add positional arguments
			cmdArgs = append(cmdArgs, tt.args...)

			// Set the command args
			rootCmd.SetArgs(cmdArgs)

			// Execute command
			err = rootCmd.Execute()

			// Check error status
			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
					return
				}
				if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
					t.Errorf("Expected error containing %q, got %q", tt.errorContains, err.Error())
				}
				return
			} else if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			// Check output files
			files, err := os.ReadDir(outputDir)
			if err != nil {
				t.Fatalf("Failed to read output directory: %v", err)
			}

			// Create a map of expected files
			expectedFiles := make(map[string]bool)
			for _, f := range tt.expectedFiles {
				expectedFiles[f] = true
			}

			// Check that all expected files exist
			for _, file := range files {
				if !expectedFiles[file.Name()] {
					t.Errorf("Unexpected file created: %s", file.Name())
				}
				delete(expectedFiles, file.Name())
			}

			// Check if any expected files are missing
			for f := range expectedFiles {
				t.Errorf("Expected file not created: %s", f)
			}
		})
	}
}

func TestScanFiles(t *testing.T) {
	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-scan-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test files with specific sizes
	files := map[string]struct {
		size     int64
		content  string
		expected bool
	}{
		"small.go":     {size: 100, content: strings.Repeat("a", 100), expected: true},
		"medium.go":    {size: 1024, content: strings.Repeat("b", 1024), expected: true},
		"large.go":     {size: 2048, content: strings.Repeat("c", 2048), expected: false},
		"ignored.txt":  {size: 100, content: strings.Repeat("d", 100), expected: false},
		"test/nest.go": {size: 100, content: strings.Repeat("e", 100), expected: true},
		".git/hide.go": {size: 100, content: strings.Repeat("f", 100), expected: false},
	}

	// Create the files
	for name, info := range files {
		path := filepath.Join(tmpDir, name)
		err := os.MkdirAll(filepath.Dir(path), 0755)
		if err != nil {
			t.Fatalf("Failed to create directory for %s: %v", name, err)
		}
		err = os.WriteFile(path, []byte(info.content), 0644)
		if err != nil {
			t.Fatalf("Failed to create test file %s: %v", name, err)
		}
	}

	tests := []struct {
		name          string
		pattern       string
		exclude       string
		maxSize       int64
		expectedCount int
		shouldError   bool
	}{
		{
			name:          "standard scan",
			pattern:       "*.go",
			maxSize:       1500,
			expectedCount: 3,
			shouldError:   false,
		},
		{
			name:          "exclude nested",
			pattern:       "*.go",
			exclude:       "test/**",
			maxSize:       1500,
			expectedCount: 2,
			shouldError:   false,
		},
		{
			name:          "small size limit",
			pattern:       "*.go",
			maxSize:       500,
			expectedCount: 2,
			shouldError:   false,
		},
		{
			name:          "multiple patterns",
			pattern:       "*.go,*.txt",
			maxSize:       1500,
			expectedCount: 4,
			shouldError:   false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			options := &core.MixOptions{
				InputPath:   tmpDir,
				Pattern:     tt.pattern,
				Exclude:     tt.exclude,
				MaxFileSize: tt.maxSize,
			}

			files, totalSize, err := scanFiles(options)
			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if len(files) != tt.expectedCount {
				t.Errorf("Expected %d files, got %d", tt.expectedCount, len(files))
			}

			// Verify total size calculation
			var expectedTotal int64
			for _, file := range files {
				expectedTotal += file.Size
			}

			if totalSize != expectedTotal {
				t.Errorf("Expected total size %d, got %d", expectedTotal, totalSize)
			}
		})
	}
}

func TestParseSize(t *testing.T) {
	tests := []struct {
		name      string
		input     string
		expected  int64
		shouldErr bool
	}{
		{
			name:      "bytes",
			input:     "1024B",
			expected:  1024,
			shouldErr: false,
		},
		{
			name:      "kilobytes",
			input:     "1KB",
			expected:  1024,
			shouldErr: false,
		},
		{
			name:      "megabytes",
			input:     "1MB",
			expected:  1024 * 1024,
			shouldErr: false,
		},
		{
			name:      "gigabytes",
			input:     "1GB",
			expected:  1024 * 1024 * 1024,
			shouldErr: false,
		},
		{
			name:      "terabytes",
			input:     "1TB",
			expected:  1024 * 1024 * 1024 * 1024,
			shouldErr: false,
		},
		{
			name:      "with spaces",
			input:     " 5 MB ",
			expected:  5 * 1024 * 1024,
			shouldErr: false,
		},
		{
			name:      "invalid format",
			input:     "1XB",
			shouldErr: true,
		},
		{
			name:      "invalid number",
			input:     "abcMB",
			shouldErr: true,
		},
		{
			name:      "negative number",
			input:     "-1MB",
			shouldErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := parseSize(tt.input)
			if tt.shouldErr {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if result != tt.expected {
				t.Errorf("Expected %d bytes, got %d", tt.expected, result)
			}
		})
	}
}

func TestFormatSize(t *testing.T) {
	tests := []struct {
		name     string
		input    int64
		expected string
	}{
		{
			name:     "bytes",
			input:    500,
			expected: "500 B",
		},
		{
			name:     "kilobytes",
			input:    1024,
			expected: "1.0 KB",
		},
		{
			name:     "megabytes",
			input:    1024 * 1024,
			expected: "1.0 MB",
		},
		{
			name:     "gigabytes",
			input:    1024 * 1024 * 1024,
			expected: "1.0 GB",
		},
		{
			name:     "partial unit",
			input:    1536, // 1.5 KB
			expected: "1.5 KB",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := formatSize(tt.input)
			if result != tt.expected {
				t.Errorf("Expected %s, got %s", tt.expected, result)
			}
		})
	}
}

func TestRootCommandFlags(t *testing.T) {
	tests := []struct {
		name          string
		args          []string
		expectedError string
	}{
		{
			name:          "invalid max size format",
			args:          []string{"--max-size", "10Z", "some/path"},
			expectedError: "invalid max-size value: invalid size format: must end with B, KB, MB, GB, or TB",
		},
		{
			name:          "negative max size",
			args:          []string{"--max-size", "-5MB", "--pattern", "*.go", "some/path"},
			expectedError: "invalid max-size value: size must be a positive number",
		},
		{
			name:          "empty pattern",
			args:          []string{"--pattern", "", "some/path"},
			expectedError: "pattern cannot be empty",
		},
		{
			name:          "invalid output extension",
			args:          []string{"--output", "output.txt", "--pattern", "*.go", "--max-size", "10MB", "some/path"},
			expectedError: "invalid output file extension: must be .xml, .json, .yaml, or .yml",
		},
		{
			name:          "no input paths",
			args:          []string{"--pattern", "*.go"},
			expectedError: "requires at least 1 arg(s), only received 0",
		},
		{
			name:          "multiple inputs with invalid output",
			args:          []string{"--output", "out.txt", "path1", "path2"},
			expectedError: "invalid output file extension: must be .xml, .json, .yaml, or .yml",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rootCmd.SetArgs(tt.args)
			err := rootCmd.Execute()

			if err == nil {
				t.Error("Expected error but got none")
				return
			}

			if err.Error() != tt.expectedError {
				t.Errorf("Expected error %q, got %q", tt.expectedError, err.Error())
			}
		})
	}
}

// Helper function to capture stdout for testing
func captureOutput(fn func() error) (string, error) {
	old := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err := fn()

	// Restore stdout and get output
	os.Stdout = old
	w.Close()
	var buf bytes.Buffer
	io.Copy(&buf, r)

	return buf.String(), err
}

func TestOutputContents(t *testing.T) {
	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-output-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test files
	testFiles := map[string]string{
		"test.go":   "package main\nfunc main() {}\n",
		"data.json": `{"key": "value"}`,
	}

	for name, content := range testFiles {
		path := filepath.Join(tmpDir, name)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create test file: %v", err)
		}
	}

	tests := []struct {
		name          string
		outputFlag    string
		expectedStart string
		notExpected   string
	}{
		{
			name:          "XML output",
			outputFlag:    "output.xml",
			expectedStart: "<?xml",
			notExpected:   "yaml",
		},
		{
			name:          "JSON output",
			outputFlag:    "output.json",
			expectedStart: "{",
			notExpected:   "xml",
		},
		{
			name:          "YAML output",
			outputFlag:    "output.yaml",
			expectedStart: "documents:",
			notExpected:   "xml",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			outputPath := filepath.Join(tmpDir, tt.outputFlag)

			// Reset and set up command
			rootCmd.ResetFlags()
			setupRootCmd()

			rootCmd.SetArgs([]string{
				"--output", outputPath,
				"--pattern", "*.go,*.json",
				tmpDir,
			})

			if err := rootCmd.Execute(); err != nil {
				t.Fatalf("Command execution failed: %v", err)
			}

			// Read and check output file
			content, err := os.ReadFile(outputPath)
			if err != nil {
				t.Fatalf("Failed to read output file: %v", err)
			}

			// Check content starts with expected string
			if !strings.Contains(string(content), tt.expectedStart) {
				t.Errorf("Output should contain %q", tt.expectedStart)
			}

			// Check content doesn't contain unexpected string
			if strings.Contains(string(content), tt.notExpected) {
				t.Errorf("Output should not contain %q", tt.notExpected)
			}
		})
	}
}

func TestRunMixWithNoArgs(t *testing.T) {
	// Create a temporary directory for testing
	tmpDir, err := os.MkdirTemp("", "filefusion-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create a test file in the temp directory
	testFile := filepath.Join(tmpDir, "test.go")
	if err := os.WriteFile(testFile, []byte("package main\n\nfunc main() {}\n"), 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Change to the temporary directory
	originalDir, err := os.Getwd()
	if err != nil {
		t.Fatalf("Failed to get current directory: %v", err)
	}
	if err := os.Chdir(tmpDir); err != nil {
		t.Fatalf("Failed to change directory: %v", err)
	}
	defer os.Chdir(originalDir)

	// Reset and setup the root command
	setupRootCmd()
	rootCmd.SetArgs([]string{})

	// Execute the command
	if err := rootCmd.Execute(); err != nil {
		t.Errorf("Command execution failed: %v", err)
	}

	// Check if output file was created
	expectedOutput := filepath.Join(tmpDir, filepath.Base(tmpDir)+".xml")
	if _, err := os.Stat(expectedOutput); os.IsNotExist(err) {
		t.Errorf("Expected output file %s was not created", expectedOutput)
	}
}
</document_content>
</document>
<document index="7">
<source>internal/core/types.go</source>
<document_content>package core

// FileContent represents a file's content and metadata
type FileContent struct {
	Path      string `json:"path"`      // Path to the file (relative to input directory)
	Name      string `json:"name"`      // Name of the file
	Content   string `json:"content"`   // Content of the file
	Extension string `json:"extension"` // File extension without dot
	Size      int64  `json:"size"`      // File size in bytes
}

// OutputType represents the type of output format
type OutputType string

const (
	OutputTypeXML  OutputType = "XML"
	OutputTypeJSON OutputType = "JSON"
	OutputTypeYAML OutputType = "YAML"
)

// MixOptions represents configuration options for the mixer
type MixOptions struct {
	InputPath   string     // Directory to process
	OutputPath  string     // Output file path
	Pattern     string     // Comma-separated file matching patterns
	Exclude     string     // Comma-separated exclusion patterns
	MaxFileSize int64      // Maximum total size in bytes
	OutputType  OutputType // Type of output format
}

// MixError represents an error that occurred during mixing
type MixError struct {
	File    string // File where error occurred
	Message string // Error message
}

// Error implements the error interface for MixError
func (e *MixError) Error() string {
	if e.File != "" {
		return "file " + e.File + ": " + e.Message
	}
	return e.Message
}
</document_content>
</document>
<document index="8">
<source>internal/core/mixer_test.go</source>
<document_content>package core

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
	"testing"
	"time"

	"gopkg.in/yaml.v3"
)

func TestMixerFindFiles(t *testing.T) {
	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test file structure
	files := map[string]string{
		"test1.go":           "package main\nfunc main() {}\n",
		"test2.go":           "package main\nfunc helper() {}\n",
		"data.json":          `{"key": "value"}`,
		"config.yaml":        "name: test",
		"subfolder/test.go":  "package sub\n",
		"subfolder/data.txt": "ignored file",
		".hidden/test.go":    "package hidden",
	}

	for path, content := range files {
		fullPath := filepath.Join(tmpDir, path)
		err := os.MkdirAll(filepath.Dir(fullPath), 0755)
		if err != nil {
			t.Fatalf("Failed to create directory: %v", err)
		}
		err = os.WriteFile(fullPath, []byte(content), 0644)
		if err != nil {
			t.Fatalf("Failed to create test file: %v", err)
		}
	}

	tests := []struct {
		name          string
		pattern       string
		exclude       string
		expectedCount int
		shouldError   bool
	}{
		{
			name:          "find all go files",
			pattern:       "*.go",
			expectedCount: 4,
			shouldError:   false,
		},
		{
			name:          "find json and yaml",
			pattern:       "*.json,*.yaml",
			expectedCount: 2,
			shouldError:   false,
		},
		{
			name:          "exclude subfolder",
			pattern:       "*.go",
			exclude:       "subfolder/**,.hidden/**", // Updated to exclude both subfolder and .hidden
			expectedCount: 2,
			shouldError:   false,
		},
		{
			name:          "exclude hidden folders",
			pattern:       "*.go",
			exclude:       ".hidden/**",
			expectedCount: 3,
			shouldError:   false,
		},
		{
			name:          "exclude specific files",
			pattern:       "*.go,*.json",
			exclude:       "data.json",
			expectedCount: 4,
			shouldError:   false,
		},
		{
			name:          "no matches",
			pattern:       "*.cpp",
			expectedCount: 0,
			shouldError:   true,
		},
		{
			name:          "invalid pattern",
			pattern:       "[",
			expectedCount: 0,
			shouldError:   true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mixer := NewMixer(&MixOptions{
				InputPath: tmpDir,
				Pattern:   tt.pattern,
				Exclude:   tt.exclude,
			})

			files, err := mixer.findFiles()

			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if len(files) != tt.expectedCount {
				t.Errorf("Expected %d files, got %d. Files: %v",
					tt.expectedCount, len(files), files)
			}
		})
	}
}

func TestConcurrentFileProcessing(t *testing.T) {
	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create multiple test files
	const numFiles = 20
	expectedContents := make(map[string]string)

	for i := 0; i < numFiles; i++ {
		content := fmt.Sprintf("content-%d", i)
		filename := fmt.Sprintf("test%d.txt", i)
		path := filepath.Join(tmpDir, filename)

		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create test file: %v", err)
		}
		expectedContents[filename] = content
	}

	mixer := NewMixer(&MixOptions{
		InputPath:   tmpDir,
		OutputPath:  filepath.Join(tmpDir, "output.xml"),
		Pattern:     "*.txt",
		MaxFileSize: 1024 * 1024,
	})

	// Find and process files
	files, err := mixer.findFiles()
	if err != nil {
		t.Fatalf("Failed to find files: %v", err)
	}

	// Test concurrent processing
	contents, err := mixer.readFilesConcurrently(files)
	if err != nil {
		t.Fatalf("Failed to read files concurrently: %v", err)
	}

	// Basic validation
	if len(contents) != numFiles {
		t.Errorf("Expected %d files, got %d", numFiles, len(contents))
	}

	// Verify content correctness
	for _, content := range contents {
		expected, exists := expectedContents[content.Name]
		if !exists {
			t.Errorf("Unexpected file in results: %s", content.Name)
			continue
		}
		if content.Content != expected {
			t.Errorf("Content mismatch for %s: expected %q, got %q",
				content.Name, expected, content.Content)
		}
	}

	// Optional performance test (benchmark-style)
	t.Run("PerformanceComparison", func(t *testing.T) {
		if testing.Short() {
			t.Skip("Skipping performance comparison in short mode")
		}

		// Run concurrent version multiple times to get more stable measurements
		var concurrentTimes []time.Duration
		for i := 0; i < 5; i++ {
			start := time.Now()
			contents, err := mixer.readFilesConcurrently(files)
			duration := time.Since(start)
			if err != nil {
				t.Errorf("Concurrent processing failed on iteration %d: %v", i, err)
				continue
			}
			if len(contents) != numFiles {
				t.Errorf("Concurrent processing returned wrong number of files on iteration %d: got %d, want %d",
					i, len(contents), numFiles)
				continue
			}
			concurrentTimes = append(concurrentTimes, duration)
		}

		// Run sequential version multiple times
		var sequentialTimes []time.Duration
		for i := 0; i < 5; i++ {
			start := time.Now()
			var seqContents []FileContent
			for _, file := range files {
				result := mixer.processFile(file)
				if result.Error == nil && result.Content.Size > 0 {
					seqContents = append(seqContents, result.Content)
				}
			}
			duration := time.Since(start)
			if len(seqContents) != numFiles {
				t.Errorf("Sequential processing returned wrong number of files on iteration %d: got %d, want %d",
					i, len(seqContents), numFiles)
				continue
			}
			sequentialTimes = append(sequentialTimes, duration)
		}

		// Calculate median times
		concurrentMedian := calculateMedian(concurrentTimes)
		sequentialMedian := calculateMedian(sequentialTimes)

		// Log the results for analysis
		t.Logf("Concurrent processing median time: %v", concurrentMedian)
		t.Logf("Sequential processing median time: %v", sequentialMedian)
		t.Logf("Concurrent/Sequential ratio: %.2f", float64(concurrentMedian)/float64(sequentialMedian))

		// Only fail if concurrent is extremely slow compared to sequential
		// This is a very conservative check that should only fail in extreme cases
		if numFiles >= 10 && concurrentMedian > sequentialMedian*3 {
			t.Errorf("Concurrent processing was unexpectedly slow: concurrent=%v, sequential=%v, ratio=%.2f",
				concurrentMedian, sequentialMedian, float64(concurrentMedian)/float64(sequentialMedian))
		}
	})
}

// Helper function to calculate median duration
func calculateMedian(durations []time.Duration) time.Duration {
	if len(durations) == 0 {
		return 0
	}

	// Sort the durations
	sorted := make([]time.Duration, len(durations))
	copy(sorted, durations)
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i] < sorted[j]
	})

	// Calculate median
	mid := len(sorted) / 2
	if len(sorted)%2 == 0 {
		return (sorted[mid-1] + sorted[mid]) / 2
	}
	return sorted[mid]
}

func TestConcurrentProcessingWithErrors(t *testing.T) {
	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create some valid files
	validFiles := map[string]string{
		"valid1.txt": "content1",
		"valid2.txt": "content2",
	}

	for name, content := range validFiles {
		path := filepath.Join(tmpDir, name)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create test file: %v", err)
		}
	}

	// Create a directory that looks like a file
	if err := os.Mkdir(filepath.Join(tmpDir, "invalid.txt"), 0755); err != nil {
		t.Fatalf("Failed to create test directory: %v", err)
	}

	// Create a file that exceeds size limit
	largeContent := strings.Repeat("a", 2*1024) // 2KB
	if err := os.WriteFile(filepath.Join(tmpDir, "large.txt"), []byte(largeContent), 0644); err != nil {
		t.Fatalf("Failed to create large test file: %v", err)
	}

	mixer := NewMixer(&MixOptions{
		InputPath:   tmpDir,
		OutputPath:  filepath.Join(tmpDir, "output.xml"),
		Pattern:     "*.txt",
		MaxFileSize: 1024, // 1KB limit
	})

	files, err := mixer.findFiles()
	if err != nil {
		t.Fatalf("Failed to find files: %v", err)
	}

	contents, err := mixer.readFilesConcurrently(files)

	// We should get valid contents, with invalid and large files skipped
	if err != nil {
		t.Errorf("Expected successful processing with skipped files, got error: %v", err)
	}

	if len(contents) != len(validFiles) {
		t.Errorf("Expected %d valid files, got %d", len(validFiles), len(contents))
	}

	// Verify valid contents were processed correctly
	for _, content := range contents {
		expected, exists := validFiles[content.Name]
		if !exists {
			t.Errorf("Unexpected file in results: %s", content.Name)
			continue
		}
		if content.Content != expected {
			t.Errorf("Content mismatch for %s: expected %q, got %q",
				content.Name, expected, content.Content)
		}
	}
}

func TestOutputFormats(t *testing.T) {
	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test files
	files := map[string]string{
		"test1.txt": "content1",
		"test2.txt": "content2",
	}

	for name, content := range files {
		path := filepath.Join(tmpDir, name)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create test file: %v", err)
		}
	}

	tests := []struct {
		name       string
		outputType OutputType
		validate   func(t *testing.T, output []byte)
	}{
		{
			name:       "XML output",
			outputType: OutputTypeXML,
			validate: func(t *testing.T, output []byte) {
				if !bytes.Contains(output, []byte("<documents>")) {
					t.Error("Expected XML output to contain <documents> tag")
				}
				if !bytes.Contains(output, []byte("<document index=\"1\">")) {
					t.Error("Expected XML output to contain indexed document tags")
				}
				if !bytes.Contains(output, []byte("<source>")) {
					t.Error("Expected XML output to contain source tags")
				}
				if !bytes.Contains(output, []byte("<document_content>")) {
					t.Error("Expected XML output to contain document_content tags")
				}
			},
		},
		{
			name:       "JSON output",
			outputType: OutputTypeJSON,
			validate: func(t *testing.T, output []byte) {
				var result struct {
					Documents []struct {
						Index           int    `json:"index"`
						Source          string `json:"source"`
						DocumentContent string `json:"document_content"`
					} `json:"documents"`
				}

				if err := json.Unmarshal(output, &result); err != nil {
					t.Errorf("Failed to parse JSON output: %v", err)
					return
				}

				if len(result.Documents) != 2 {
					t.Errorf("Expected 2 documents in JSON output, got %d", len(result.Documents))
				}

				// Verify document order and content
				for i, doc := range result.Documents {
					if doc.Index != i+1 {
						t.Errorf("Expected document index %d, got %d", i+1, doc.Index)
					}
					expectedContent := fmt.Sprintf("content%d", i+1)
					if doc.DocumentContent != expectedContent {
						t.Errorf("Expected content %q, got %q", expectedContent, doc.DocumentContent)
					}
				}
			},
		},
		{
			name:       "YAML output",
			outputType: OutputTypeYAML,
			validate: func(t *testing.T, output []byte) {
				var result struct {
					Documents []struct {
						Index           int    `yaml:"index"`
						Source          string `yaml:"source"`
						DocumentContent string `yaml:"document_content"`
					} `yaml:"documents"`
				}

				if err := yaml.Unmarshal(output, &result); err != nil {
					t.Errorf("Failed to parse YAML output: %v", err)
					return
				}

				if len(result.Documents) != 2 {
					t.Errorf("Expected 2 documents in YAML output, got %d", len(result.Documents))
				}

				// Verify document order and content
				for i, doc := range result.Documents {
					if doc.Index != i+1 {
						t.Errorf("Expected document index %d, got %d", i+1, doc.Index)
					}
					expectedContent := fmt.Sprintf("content%d", i+1)
					if doc.DocumentContent != expectedContent {
						t.Errorf("Expected content %q, got %q", expectedContent, doc.DocumentContent)
					}
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			outputPath := filepath.Join(tmpDir, fmt.Sprintf("output%s", tt.outputType))
			mixer := NewMixer(&MixOptions{
				InputPath:   tmpDir,
				OutputPath:  outputPath,
				Pattern:     "*.txt",
				MaxFileSize: 1024 * 1024,
				OutputType:  tt.outputType,
			})

			if err := mixer.Mix(); err != nil {
				t.Fatalf("Mix failed: %v", err)
			}

			output, err := os.ReadFile(outputPath)
			if err != nil {
				t.Fatalf("Failed to read output file: %v", err)
			}

			tt.validate(t, output)
		})
	}
}

func TestMixerSizeLimit(t *testing.T) {
	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create files of different sizes
	files := map[string]int{
		"small.txt":  512,  // 512 bytes
		"medium.txt": 1024, // 1KB
		"large.txt":  2048, // 2KB
		"huge.txt":   4096, // 4KB
	}

	// Create the test files
	for name, size := range files {
		content := strings.Repeat("a", size)
		path := filepath.Join(tmpDir, name)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create test file %s: %v", name, err)
		}
	}

	tests := []struct {
		name          string
		maxSize       int64
		expectedFiles int
		expectedNames []string // Add expected file names
	}{
		{
			name:          "all files under limit",
			maxSize:       5 * 1024, // 5KB
			expectedFiles: 4,
			expectedNames: []string{"small.txt", "medium.txt", "large.txt", "huge.txt"},
		},
		{
			name:          "medium size limit",
			maxSize:       2 * 1024, // 2KB
			expectedFiles: 3,
			expectedNames: []string{"small.txt", "medium.txt", "large.txt"},
		},
		{
			name:          "small size limit",
			maxSize:       1024, // 1KB
			expectedFiles: 2,
			expectedNames: []string{"small.txt", "medium.txt"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mixer := NewMixer(&MixOptions{
				InputPath:   tmpDir,
				OutputPath:  filepath.Join(tmpDir, "output.xml"),
				Pattern:     "*.txt",
				MaxFileSize: tt.maxSize,
			})

			// Process files
			contents, err := mixer.readFilesConcurrently([]string{
				filepath.Join(tmpDir, "small.txt"),
				filepath.Join(tmpDir, "medium.txt"),
				filepath.Join(tmpDir, "large.txt"),
				filepath.Join(tmpDir, "huge.txt"),
			})

			if err != nil {
				t.Fatalf("Failed to process files: %v", err)
			}

			if len(contents) != tt.expectedFiles {
				t.Errorf("Expected %d files, got %d", tt.expectedFiles, len(contents))
			}

			// Create a map of expected files for easier checking
			expectedFiles := make(map[string]bool)
			for _, name := range tt.expectedNames {
				expectedFiles[name] = true
			}

			// Verify all included files are within size limit and expected
			for _, content := range contents {
				if content.Size > tt.maxSize {
					t.Errorf("File %s exceeds size limit: %d > %d",
						content.Name, content.Size, tt.maxSize)
				}
				if !expectedFiles[content.Name] {
					t.Errorf("Unexpected file in results: %s", content.Name)
				}
			}
		})
	}
}

func TestErrorHandling(t *testing.T) {
	// Skip this test on Windows as permission handling is different
	if runtime.GOOS == "windows" {
		t.Skip("Skipping permission test on Windows")
	}

	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "filefusion-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test scenarios
	tests := []struct {
		name        string
		setup       func(dir string) error
		pattern     string
		shouldError bool
		errorCheck  func(error) bool
	}{
		{
			name: "non-existent directory",
			setup: func(dir string) error {
				return nil // Do nothing, we'll use a non-existent path
			},
			pattern:     "*.txt",
			shouldError: true,
			errorCheck: func(err error) bool {
				return strings.Contains(err.Error(), "no such file or directory")
			},
		},
		{
			name: "permission denied",
			setup: func(dir string) error {
				subdir := filepath.Join(dir, "noaccess")
				if err := os.Mkdir(subdir, 0755); err != nil {
					return err
				}
				if err := os.WriteFile(filepath.Join(subdir, "test.txt"), []byte("test"), 0644); err != nil {
					return err
				}
				// Change permissions after creating the file
				return os.Chmod(subdir, 0000)
			},
			pattern:     "*.txt",
			shouldError: true,
			errorCheck: func(err error) bool {
				return strings.Contains(err.Error(), "permission denied") ||
					strings.Contains(err.Error(), "no files found")
			},
		},
		{
			name: "invalid output path",
			setup: func(dir string) error {
				return os.WriteFile(filepath.Join(dir, "test.txt"), []byte("test"), 0644)
			},
			pattern:     "*.txt",
			shouldError: true,
			errorCheck: func(err error) bool {
				return strings.Contains(err.Error(), "permission denied") ||
					strings.Contains(err.Error(), "no such file or directory")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Set up test scenario
			if err := tt.setup(tmpDir); err != nil {
				t.Fatalf("Failed to set up test: %v", err)
			}

			var inputPath string
			if tt.name == "non-existent directory" {
				inputPath = filepath.Join(tmpDir, "nonexistent")
			} else {
				inputPath = tmpDir
			}

			mixer := NewMixer(&MixOptions{
				InputPath:   inputPath,
				OutputPath:  "/nonexistent/output.xml", // Invalid output path
				Pattern:     tt.pattern,
				MaxFileSize: 1024 * 1024,
			})

			err := mixer.Mix()

			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
					return
				}
				if !tt.errorCheck(err) {
					t.Errorf("Expected specific error condition, got: %v", err)
				}
			} else if err != nil {
				t.Errorf("Unexpected error: %v", err)
			}

			// Clean up permissions so the deferred cleanup can work
			if tt.name == "permission denied" {
				os.Chmod(filepath.Join(tmpDir, "noaccess"), 0755)
			}
		})
	}
}
</document_content>
</document>
</documents>